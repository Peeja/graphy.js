@import '../share/iris.jmacs';

// import type RDFJS from '@@rdfjs/types';

import * as Api from './term';

import type {
	Merge,
} from 'ts-toolbelt/out/Object/_api';

import type {
	Iri,
} from './root';

@*{
	function explicit_union_mutations(s_word) {
		const a_forms = [];

		const a_source = s_word.split('');
		const nl_perms = 1 << s_word.length;
		for(let i_perm=0; i_perm<nl_perms; i_perm++) {
			a_forms.push(a_source.reduce((s_out, s_char, i_char) => s_out+((i_perm >> i_char) & 1? s_char.toUpperCase(): s_char), ''));
		}

		return `type Literally${s_word[0].toUpperCase()}${s_word.slice(1)} = ${a_forms.map(s => `'${s}'`).join(' | ')};`;
	}

	const A_WORDS = [
		'true',
		'false',
	];

	for(const s_word of A_WORDS) {
		yield explicit_union_mutations(s_word)+'\n';
	}

	yield `type LiterallyTrueOrFalse = LiterallyTrue | LiterallyFalse;\n`;
}

type LiterallyInteger = string;
type LiterallyDouble = string;
type LiterallyDecimal = string;

type Bcp47 = string;

@.{
	const ode = Object.entries;

	const H_GENERICS_EXTENDS = {
		s_value: 'string',
		s_language: 'Bcp47',
		s_datatype: 'Iri',
	};

	const fit_generic = si_generic => `${si_generic} extends ${H_GENERICS_EXTENDS[si_generic]}=${H_GENERICS_EXTENDS[si_generic]}`;

	const A_GENERICS_TERM_VALUE = [/* syntax: ts */ `s_value extends string=string`];

	const R_GENERIC = /[^<]*<([^>]+)>/y;
	function generics_from(sj_union) {
		const as_terms = new Set();
		R_GENERIC.lastIndex = 0;
		for(;;) {
			const m_generic = R_GENERIC.exec(sj_union);
			if(m_generic) {
				m_generic[1].split(/\s*,\s*/g).forEach((s_term) => {
					as_terms.add(s_term);
				});
				continue;
			}

			break;
		}

		return [...as_terms];
	}

	function generics_for(si, a_only=null) {
		const g_term = H_TERMS[si];
		if(g_term?.generics?.length) {
			return g_term.generics
				.map(s => `${s.replace(/^(\w+).*/, '$1')}`)
				.filter(s => a_only? a_only.includes(s): true);
		}
	}

	const parametric = (a_generics) => a_generics && a_generics.length? `<${a_generics.join(', ')}>`: '';

	const paragenerics = (...a_args) => parametric(generics_for(...a_args));

	const docstring = (s_desc, s_super='Term') => si => `
		A${/^[AEIOUY]/i.test(si)? 'n': ''} ${si} is a {@link ${s_super}} that ${s_desc.trim()}
	`;

	const H_TERM_GENERIC = {
		properties: {
			isGraphyTerm:         true,
			isGraphyQuad:         false,
			isAbleGraph:          false,
			isAbleSubject:        false,
			isAblePredicate:      false,
			isAbleObject:         false,
			isDefaultGraph:       false,
			isNode:               false,
			isNamedNode:          false,
			isAbsoluteIri:        false,
			isRelativeIri:        false,
			isRdfTypeAlias:       false,
			isBlankNode:          false,
			isAnonymousBlankNode: false,
			isEphemeralBlankNode: false,
			isLiteral:            false,
			isSimpleLiteral:      false,
			isLanguagedLiteral:   false,
			isDatatypedLiteral:   false,
			isNumericLiteral:     false,
			isBooleanLiteral:     false,
			isIntegerLiteral:     false,
			isDoubleLiteral:      false,
			isInfiniteLiteral:    false,
			isNaNLiteral:         false,
			isDecimalLiteral:     false,
			isVariable:           false,
		},

		methods: {
			// equals:       si => /* syntax: ts */ `(other: RDFJS.Term): boolean`,
			flat:         si => /* syntax: ts */ `(prefixes?: PrefixMap): F1.${si}${paragenerics(si)}`,
			concise:      si => /* syntax: ts */ `(prefixes?: PrefixMap): C1.${si}${paragenerics(si)}`,
			terse:        si => /* syntax: ts */ `(prefixes?: PrefixMap): Terse.${si}`,
			star:         si => /* syntax: ts */ `(prefixes?: PrefixMap): Star.${si}`,
			verbose:      si => /* syntax: ts */ `(): Verbose.${si}${paragenerics(si)}`,
			isolate:      si => /* syntax: ts */ `(): Isolated.${si}${paragenerics(si)}`,
			hash:         si => /* syntax: ts */ `(): string`,
			replaceIri:   si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
			replaceText:  si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
			replaceValue: si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
		},
	};

	const H_TERM_GRAPHABLE = {
		properties: {
			...H_TERM_GENERIC.properties,
			isAbleGraph:  true,
		},
	};

	const H_TERM_DEFAULT_GRAPH = {
		f1: `'*'`,
		implements: /* syntax: js */ `Api.DefaultGraph`,
		properties: {
			...H_TERM_GRAPHABLE.properties,
			isDefaultGraph:       true,
		},
	};

	const H_TERM_NODE = {
		properties: {
			...H_TERM_GRAPHABLE.properties,
			isNode:           true,
			isAbleSubject:    true,
			isAblePredicate:  true,
			isAbleObject:     true,
		},
	};

	const SX_C1_ABSOLUTE_IRI = '`>${s_value}`';

	const H_TERM_NAMED_NODE = {
		c1: '`${string}:${string}`',
		f1: SX_C1_ABSOLUTE_IRI,
		generics: [/* syntax: ts */ `s_value extends Iri=Iri`],
		super_args: 's_value',
		implements: /* syntax: js */ `Api.NamedNode`,
		docs: docstring(`
			encapsulates an absolute IRI. It is free from any context such as namespace or document.
			@see RelativeIri for using relative IRIs.
		`),
		properties: {
			...H_TERM_NODE.properties,
			isNamedNode:          true,
			isAbsoluteIri:        true,
		},
	};

	const H_TERM_RELATIVE_IRI = {
		c1: ['void'],
		f1: SX_C1_ABSOLUTE_IRI,
		generics: [/* syntax: ts */ `s_value extends IriRelativeRef=IriRelativeRef`],
		docs: docstring(`
			encapsulates a relative IRI. In order to be used, it requires a base IRI context from a {@link PrefixMap} or document; however, such a context is not stored with this Term.
		`),
		properties: {
			...H_TERM_NODE.properties,
			isAbsoluteIri: false,
			isRelativeIri: true,

			termType:             /* syntax: ts */ `'NamedNode'`,
			value:                /* syntax: ts */ `s_value`,
		},
		methods: {
			flat:     () => /* syntax: ts */ `(prefixes?: PrefixMap): F1.NamedNode | never`,
			concise:  () => /* syntax: ts */ `(prefixes?: PrefixMap): C1.NamedNode | never`,
			terse:    () => /* syntax: ts */ `(prefixes?: PrefixMap): Terse.NamedNode`,
			star:     () => /* syntax: ts */ `(prefixes?: PrefixMap): Star.NamedNode`,
			verbose:  () => /* syntax: ts */ `(): never`,
			hash:     () => /* syntax: ts */ `(): never`,
			isolate:  () => /* syntax: ts */ `(): Isolated.NamedNode`,
		},
	};

	const H_TERM_BLANK_NODE = {
		// f1: 'LabeldBlankNode | AnonymousBlankNode',
		generics: A_GENERICS_TERM_VALUE,
		implements: /* syntax: js */ `Api.BlankNode`,
		super_args: 's_value',
		properties: {
			...H_TERM_NODE.properties,
			isBlankNode:          true,
		},
	};

	const SX_F1_BLANK_NODE = '`#${string}`';

	const H_TERM_LABELED_BLANK_NODE = {
		class: 'BlankNode',
		super_args: '`#${string}`',
		f1: '`#${s_value}`',
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring(`
			encapsulates a blank node that was created or read with a specific label.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
		},
	};

	const H_TERM_ANONYMOUS_BLANK_NODE = {
		class: 'BlankNode',
		f1: SX_F1_BLANK_NODE,
		docs: docstring(`
			encapsulates a blank node that was read from a syntactically anonymous blank node token.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
			isAnonymousBlankNode: true,
		},
	};

	const H_TERM_EPHEMERAL_BLANK_NODE = {
		class: 'BlankNode',
		super_args: '`#${string}`',
		f1: '`##${string}`',
		docs: docstring(`
			encapsulates a blank node that was created in order to be serialized as an anonymous blank node token.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
			isAnonymousBlankNode: true,
			isEphemeralBlankNode: true,

			value:                 /* syntax: ts */ `string`,
		},
	};

	const H_TERM_LITERAL = {
		implements: sj_super_args => /* syntax: js */ `Api.Literal${sj_super_args}`,
		generics: A_GENERICS_TERM_VALUE,
		properties: {
			...H_TERM_GENERIC.properties,
			isAbleObject:          true,
			isLiteral:             true,

			// termType:              /* syntax: ts */ `'Literal'`,
			// value:                 /* syntax: ts */ `s_value`,
			// language:              /* syntax: ts */ `string`,
			// datatype:              /* syntax: ts */ `Datatype`,

			boolean:               /* syntax: ts */ `typeof NaN`,
			number:                /* syntax: ts */ `typeof NaN`,
			bigint:                /* syntax: ts */ `typeof NaN`,
		},
	};

	const H_TERM_SIMPLE_LITERAL = {
		class: 'Literal',
		f1: '`"${s_value}`',
		generics: A_GENERICS_TERM_VALUE,
		super_args: `s_value, void, void`,
		docs: docstring(`
			encapsulates a literal without any explicit datatype nor language tag.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isSimpleLiteral:      true,
		},
	};

	const H_TERM_LANGUAGED_LITERAL = {
		class: 'Literal',
		// TODO: narrow to BCP47 pattern
		f1: '`@${s_language}"${s_value}`',
		generics: [...A_GENERICS_TERM_VALUE, /* syntax: ts */ `s_language extends Bcp47=Bcp47`],
		super_args: `s_value, s_language, '${P_IRI_XSD}langString'`,
		docs: docstring(`
			encapsulates a literal with a specific language tag.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isLanguagedLiteral: true,

			// language:              /* syntax: ts */ `s_language`,
		},
	};

	const H_TERM_DATATYPED_LITERAL = {
		class: 'Literal',
		f1: '`^${NamedNode<s_datatype>}"${s_value}`',
		c1: ['`^${NamedNode<s_datatype>}"${s_value}`'],
		generics: [...A_GENERICS_TERM_VALUE, /* syntax: ts */ `s_datatype extends Iri=Iri`],
		super_args: 's_value, void, s_datatype',
		docs: docstring(`
			encapsulates a literal with an explicit datatype.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isDatatypedLiteral:  true,

			datatype:              /* syntax: ts */ `Datatype<s_datatype>`,
		},
	};

	const SX_F1_DATATYPE_XSD = '`^>http://www.w3.org/2001/XMLSchema#';
	const SX_F1_DATATYPE_LITERAL_XSD = SX_F1_DATATYPE_XSD+'${string}"${s_value}`';

	const H_TERM_NUMERIC_LITERAL = {
		class: 'Literal',
		generics: A_GENERICS_TERM_VALUE,
		properties: {
			...H_TERM_LITERAL.properties,
			isNumericLiteral:  true,

			datatype:           /* syntax: ts */ `DatatypeXsdInteger | DatatypeXsdDouble | DatatypeXsdDecimal`,
		},
	};

	const docstring_xsd = (s_post='', s_super='Literal') => si => docstring(`
		has an XSD datatype of ${si.toLowerCase().replace(/Literal.*$/, '')}${s_post? ' '+s_post: '.'}
	`, s_super)(si);

	const H_TERM_BOOLEAN_LITERAL = {
		class: 'Literal',
		super_args: `s_value, void, '${P_IRI_XSD}boolean'`,
		f1: SX_F1_DATATYPE_XSD+'boolean"${s_value}`',
		c1: '`^${string}:${string}"${s_value}`',
		generics: [/* syntax: ts */ `s_value extends LiterallyTrueOrFalse=LiterallyTrueOrFalse`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isBooleanLiteral:  true,
			isNumberPrecise:   true,

			// value:              /* syntax: ts */ `s_value`,
			boolean:            /* syntax: ts */ `boolean`,
			number:             /* syntax: ts */ `number`,
			bigint:             /* syntax: ts */ `number`,
			// datatype:           /* syntax: ts */ `DatatypeXsdBoolean`,
		},
	};


	const H_TERM_INTEGER_LITERAL = {
		class: 'Literal',
		super_args: `s_value, void, '${P_IRI_XSD}integer'`,
		f1: SX_F1_DATATYPE_XSD+'integer"${s_value}`',
		c1: '`^${string}:${string}"${number}`',
		generics: [/* syntax: ts */ 's_value extends LiterallyInteger=LiterallyInteger'],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_NUMERIC_LITERAL.properties,
			isIntegerLiteral:   true,
			isNumberPrecise:    true,

			number:             /* syntax: ts */ `number`,
			bigint:             /* syntax: ts */ `number`,
		},
	};

	const SX_F1_DOUBLE_LITERAL = SX_F1_DATATYPE_XSD+'double"${s_value}`';
	const H_TERM_DOUBLE_LITERAL = {
		class: 'Literal',
		super_args: `s_value, void, '${P_IRI_XSD}double'`,
		f1: SX_F1_DOUBLE_LITERAL,
		c1: '`^${string}:${string}"${s_value}`',
		generics: [/* syntax: ts */ `s_value extends LiterallyDouble=LiterallyDouble`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_NUMERIC_LITERAL.properties,
			isDoubleLiteral:    true,
			isNumberPrecise:    true,

			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_POSITIVE_INFINITY_LITERAL = {
		class: 'Literal',
		super_args: `'INF', void, '${P_IRI_XSD}double'`,
		f1: SX_F1_DATATYPE_XSD+'double"INF`',
		c1: '`^${string}:${string}"INF`',
		docs: docstring_xsd('and a value of positive infinity', 'DoubleLiteral'),
		properties: {
			...H_TERM_DOUBLE_LITERAL.properties,
			isInfiniteLiteral:  true,
			isNumberPrecise:    false,

			// number:             /* syntax: ts */ `9e999 /* Infinity */`,
		},
	};

	const H_TERM_NEGATIVE_INFINITY_LITERAL = {
		class: 'Literal',
		super_args: `'-INF', void, '${P_IRI_XSD}double'`,
		f1: SX_F1_DATATYPE_XSD+'double"-INF`',
		c1: '`^${string}:${string}"-INF`',
		docs: docstring_xsd('and a value of negative infinity', 'DoubleLiteral'),
		properties: {
			...H_TERM_POSITIVE_INFINITY_LITERAL.properties,

			// number:             /* syntax: ts */ `-9e999 /* -Infinity */`,
		},
	};

	const H_TERM_NAN_LITERAL = {
		class: 'Literal',
		super_args: `'NaN', void, '${P_IRI_XSD}double'`,
		f1: SX_F1_DATATYPE_XSD+'double"NaN`',
		c1: '`^${string}:${string}"NaN`',
		docs: docstring_xsd('and the reserved value of NaN', 'DoubleLiteral'),
		properties: {
			...H_TERM_DOUBLE_LITERAL.properties,
			isNaNLiteral:    true,
			isNumberPrecise: false,

			number:             /* syntax: ts */ `typeof NaN`,
		},
	};

	const SX_C1_DATATYPE_GENERIC = '`^${string}:${string}"${string}`';

	const H_TERM_DECIMAL_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'decimal"${s_value}`',
		c1: SX_C1_DATATYPE_GENERIC,
		generics: [/* syntax: ts */ `s_value extends LiterallyDecimal=LiterallyDecimal`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isNumericLiteral:   true,
			isDecimalLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `boolean`,

			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_DATE_LITERAL = {
		class: 'Literal',
		super_args: `s_value, void, '${P_IRI_XSD}date'`,
		f1: SX_F1_DATATYPE_XSD+'date"${s_value}`',
		c1: SX_C1_DATATYPE_GENERIC,
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isDateLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `true`,

			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_DATETIME_LITERAL = {
		class: 'Literal',
		super_args: `s_value, void, '${P_IRI_XSD}dateTime'`,
		f1: SX_F1_DATATYPE_XSD+'dateTime"${s_value}`',
		c1: SX_C1_DATATYPE_GENERIC,
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isDateTimeLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `true`,

			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_VARIABLE = {
		f1: '`?${s_value}`',
		// implements: /* syntax: js */ `Api.Variable`,
		class: 'Variable',
		super_args: 's_value',
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring(`
			encapsulates a query variable.
		`),
		properties: {
			...H_TERM_GENERIC.properties,
			isVariable: true,
		},
	};

	const H_TERM_QUAD = {
		implements: /* syntax: js */ `Api.Quad`,
		generics: [
			/* syntax: ts */ `s_value_subject extends string=string`,
			/* syntax: ts */ `s_value_predicate extends Iri=Iri`,
			/* syntax: ts */ `s_value_object extends string=string`,
			/* syntax: ts */ `s_language_object extends Bcp47=Bcp47`,
			/* syntax: ts */ `s_datatype_object extends Iri=Iri`,
			/* syntax: ts */ `s_value_graph extends string=string`,
		],
		new_args: [
			/* syntax: ts */ `kt_subject: Term.Subject<s_value_subject>`,
			/* syntax: ts */ `kt_predicate: Term.Predicate<s_value_predicate>`,
			/* syntax: ts */ `kt_object: Term.Object<s_value_object>`,
			/* syntax: ts */ `kt_graph: Term.Graph<s_value_graph>`,
		],
		properties: {
			...H_TERM_GENERIC.properties,
			isGraphyQuad: true,
		},
		body: /* syntax: ts */ `
			readonly subject: Term.Subject<s_value_subject>;
			readonly predicate: Term.Predicate<s_value_predicate>;
			readonly object: Term.Object<s_value_object, s_language_object, s_datatype_object>;
			readonly graph: Term.Graph<s_value_graph>;

			reify(label?: string): Reification;
		`,
	};

	const H_TERMS = {
		DefaultGraph: H_TERM_DEFAULT_GRAPH,
		NamedNode: H_TERM_NAMED_NODE,
		RelativeIri: H_TERM_RELATIVE_IRI,
		LabeledBlankNode: H_TERM_LABELED_BLANK_NODE,
		AnonymousBlankNode: H_TERM_ANONYMOUS_BLANK_NODE,
		EphemeralBlankNode: H_TERM_EPHEMERAL_BLANK_NODE,
		SimpleLiteral: H_TERM_SIMPLE_LITERAL,
		LanguagedLiteral: H_TERM_LANGUAGED_LITERAL,
		DatatypedLiteral: H_TERM_DATATYPED_LITERAL,
		BooleanLiteral: H_TERM_BOOLEAN_LITERAL,
		IntegerLiteral: H_TERM_INTEGER_LITERAL,
		DoubleLiteral: H_TERM_DOUBLE_LITERAL,
		PositiveInfinityLiteral: H_TERM_POSITIVE_INFINITY_LITERAL,
		NegativeInfinityLiteral: H_TERM_NEGATIVE_INFINITY_LITERAL,
		NaNLiteral: H_TERM_NAN_LITERAL,
		DecimalLiteral: H_TERM_DECIMAL_LITERAL,
		DateLiteral: H_TERM_DATE_LITERAL,
		DateTimeLiteral: H_TERM_DATETIME_LITERAL,
		Variable: H_TERM_VARIABLE,
		Quad: H_TERM_QUAD,
	};

	// const H_TERMS_ALL = {
	// 	...H_TERMS,
	// 	BlankNode: H_TERM_BLANK_NODE,
	// };
}

@*{
	yield /* syntax: ts */ `export namespace Term {`;

	// generic type
	{
		yield `\n\texport interface GenericTerm extends Api.CoreData {`;
		for(const [si_property, z_default] of Object.entries(H_TERM_GENERIC.properties)) {
			let s_value;

			if(true === z_default) {
				s_value = 'true';
			}
			else if(false === z_default) {
				s_value = 'boolean';
			}
			else {
				s_value = z_default;
			}

			yield `\n\t\treadonly ${si_property}: ${s_value};`;
		}
		yield `\n\t}\n\n`;
	}

	let s_accepted = '';

	for(const [si_term, g_term] of ode(H_TERMS)) {
		const sj_generics = g_term.generics? `<${g_term.generics}>`: '';
		const sj_super_args = g_term.super_args? `<${g_term.super_args}>`: '';

		let sj_implements = '';
		if(g_term.implements) {
			let z_implements = g_term.implements;
			if('function' === typeof z_implements) {
				z_implements = z_implements(sj_super_args);
			}
			else if(sj_super_args) {
				z_implements += sj_super_args;
			}
			sj_implements = `Merge<${z_implements}, `;
		}
		else if(g_term.class) {
			let z_class = g_term.class;
			if('function' === typeof z_class) {
				z_class = z_class(sj_super_args);
			}
			else if(sj_super_args) {
				z_class += sj_super_args;
			}
			sj_implements = `Merge<Api.${z_class}, `;
		}
		if(g_term.docs) {
			let s_docs = g_term.docs;

			if('function' === typeof g_term.docs) {
				s_docs = g_term.docs(si_term) || '';
			}

			const a_lines = s_docs.trim().split(/\s*\n\s*/g);
			yield `\t/**${a_lines.map(s => `\n\t * ${s}`)}\n\t */\n`;
		}

		yield /* syntax: ts */ `\texport type ${si_term}${sj_generics} = ${sj_implements || ''}{\n`;

		for(const [si_property, sj_property] of ode(g_term.properties)) {
			yield /* syntax: ts */ `\t\treadonly ${si_property}: ${sj_property};\n`;
		}

		const s_properties = Object.keys(g_term.properties).sort().join('\n');
		if(s_properties !== s_accepted) {
			if(!s_accepted) {
				s_accepted = s_properties;
			}
			else {
				let s_missing = '';
				let s_extra = '';
				const as_acc = new Set(s_accepted.split('\n'));
				const as_prp = new Set(s_properties.split('\n'));
				for(const s_each of as_acc) {
					if(!as_prp.has(s_each)) {
						s_missing += s_each+'\n';
					}
				}
				for(const s_each of as_prp) {
					if(!as_acc.has(s_each)) {
						s_extra += s_each+'\n';
					}
				}
				console.warn(`key mismatch discovered on ${si_term}: missing: '''\n${s_missing}\n'''. extra: '''\n${s_extra}\n'''`);
			}
		}

		if(g_term.body) {
			yield '\t\t'+g_term.body.trim().split(/\s*\n+\s*/g).join('\n\t\t')+'\n';
		}

		const si_class = g_term.class || si_term;

		for(const [si_method, f_method] of ode({...H_TERM_GENERIC.methods, ...(g_term.methods || {})})) {
			yield /* syntax: ts */ `\t\t${si_method}${f_method(si_term)};\n`;
		}

		yield /* syntax: ts */ `\t}${sj_implements? '>;': ''}\n\n`;

		// constructor
		yield /* syntax: ts */ `\texport interface ${si_term}Constructor {\n`
			+`\t\tnew${sj_generics}(${
				g_term.new_args
					? g_term.new_args.map(s => `\n\t\t\t${s}`).join(',')
					: (generics_for(si_term) || [])
						.map(s => `s_${s.toLowerCase().replace(/string$/, '')}: ${s}`)
			}): ${si_term}${paragenerics(si_term)};\n`
			+`\t}\n\n`
			+`\texport declare const ${si_term}: ${si_term}Constructor;\n\n`;
	}

	yield /* syntax: ts */ `
		export interface Reification {
			readonly node: BlankNode;
			readonly quads: Quad[];
		}

		export type BlankNode<s_value extends string=string> = s_value extends Iri
			? never
			: LabeledBlankNode<s_value> | AnonymousBlankNode | EphemeralBlankNode;

		export type Node<s_value extends string=string> = NamedNode<s_value> | BlankNode<s_value>;

		export type Literal<s_value extends string=string, s_language extends never | string=string, s_datatype extends never | Iri=Iri> = SimpleLiteral<s_value>
			| s_datatype extends never
				? (s_language extends never
					? never
					: LanguagedLiteral<s_value, s_language>)
				: (DatatypedLiteral<s_value, s_datatype>
					| s_language extends never
						? never
						: LanguagedLiteral<s_value, s_language>
					);

		export type NumericLiteral<s_value extends string=string> = IntegerLiteral<s_value> | DoubleLiteral<s_value> | DecimalLiteral<s_value>;

		export type Graph<s_value extends string=string> = DefaultGraph
			| string extends ''
				? never
				: Node<s_value>;

		export type Subject<s_value extends string=string> = Node<s_value>;

		export type Predicate<s_value extends Iri=Iri> = NamedNode<s_value>;

		export type Object<s_value extends string=string, s_language extends Bcp47=Bcp47, s_datatype extends Iri=Iri> = Node<s_value> | Literal<s_value, s_language, s_datatype>;

		export type Datatype<s_datatype extends Iri=Iri> = NamedNode<s_datatype>;

		export type DatatypeXsdBoolean = Datatype<'${P_IRI_XSD}boolean'>;
		export type DatatypeXsdInteger = Datatype<'${P_IRI_XSD}integer'>;
		export type DatatypeXsdDouble = Datatype<'${P_IRI_XSD}double'>;
		export type DatatypeXsdDecimal = Datatype<'${P_IRI_XSD}decimal'>;
		export type DatatypeXsdDate = Datatype<'${P_IRI_XSD}date'>;
		export type DatatypeXsdDateTime = Datatype<'${P_IRI_XSD}dateTime'>;

		export type Data<s_value extends string=string, s_language extends Bcp47=Bcp47, s_datatype extends Iri=Iri> = 
			| Graph<s_value> | Subject<s_value> | Object<s_value, s_language, s_datatype>
			| (s_value extends Iri? Predicate<s_value>: never);

		export type Any = Data | Variable | Quad | RelativeIri;
	`.replace(/\n/g, '\n\t')+'\n';

	yield /* syntax: ts */ `}\n\n`;
}

@*{
	const cv_extras = (s_cv) => ({
		Json: /* syntax: ts */ `string`,
		Directive: /* syntax: ts */ `string`,
		QuadBundle: {
			'.extends': /* syntax: ts */ `Iterable<Quad>`,
			'[Symbol.iterator]': /* syntax: ts */ `() => Iterator<Quad>`,
			'toString()': /* syntax: ts */ `${s_cv}.Json`,
		},
	});

	const H_FORMS = {
		F1: {
			primitive: (si, g) => 'f1' in g? g.f1: /* syntax: ts */ `string`,
			extras: cv_extras('F1'),
		},
		C1: {
			primitive: (si, g) => {
				let a_types = [];
				if('f1' in g) a_types.push(`F1.${si}${paragenerics(si)}`);
				if('c1' in g) {
					if('string' === typeof g.c1) a_types.push(g.c1);
					else a_types = g.c1;
				}
				return a_types.length? a_types.join(' | '): /* syntax: ts */ `string`;
			},
			extras: cv_extras('C1'),
		},
		Verbose: {
			primitive: si => /* syntax: ts */ 'DefaultGraph' === si? `''`: `string`,
		},
		Terse: {
			primitive: si => /* syntax: ts */ 'DefaultGraph' === si? `''`: `string`,
		},
		Star: {
			primitive: si => /* syntax: ts */ `Terse.${si}`,
			compose: {
				Subject: sj => /* syntax: ts */ `${sj} | Quad`,
				Object: sj => /* syntax: ts */ `${sj} | Quad`,
			},
		},
		Isolated: {
			primitive: (si) => {
				switch(si) {
					case 'DefaultGraph': return {
						termType: /* syntax: ts */ `'DefaultGraph'`,
						value: /* syntax: ts */ `''`,
					};

					case 'Literal': return {
						termType: /* syntax: ts */ `'Literal'`,
						value: /* syntax: ts */ `s_value`,
						language: /* syntax: ts */ `s_language`,
						datatype: /* syntax: ts */ `Datatype<s_datatype>`,
					};

					case 'Quad': return {
						termType: /* syntax: ts */ `'Quad'`,
						value: /* syntax: ts */ `''`,
						subject: /* syntax: ts */ `Subject`,
						predicate: /* syntax: ts */ `Predicate`,
						object: /* syntax: ts */ `Object`,
						graph: /* syntax: ts */ `Graph`,
					};

					default: return {
						termType: /* syntax: ts */ `'${si}'`,
						value: generics_for(si, ['s_value'])?.length? 's_value': /* syntax: ts */ `string`,
					};
				}
			},
		},
	};

	const H_PRIMITIVES = {
		...H_TERMS,
		NamedNode: H_TERM_NAMED_NODE,
		BlankNode: {
			generics: A_GENERICS_TERM_VALUE,
			c1: 'LabeledBlankNode<s_value> | AnonymousBlankNode | EphemeralBlankNode',
		},
		DefaultGraph: H_TERM_DEFAULT_GRAPH,
		Literal: {
			generics: [
				...A_GENERICS_TERM_VALUE,
				/* syntax: ts */ `s_language extends Bcp47=Bcp47`,
				/* syntax: ts */ `s_datatype extends Iri=Iri`,
			],
			c1: 'SimpleLiteral<s_value> | LanguagedLiteral<s_value, s_language> | DatatypedLiteral<s_value, s_datatype>',
		},
		Variable: H_TERM_VARIABLE,
		Quad: H_TERM_QUAD,
	};

	const H_COMPOSE_DEFAULT = {
		Node: /* syntax: ts */ `NamedNode<s_value> | BlankNode<s_value>`,
		Graph: /* syntax: ts */ `DefaultGraph | (s_value extends ''? never: Node<s_value>)`,
		Subject: /* syntax: ts */ `Node<s_value>`,
		Predicate: /* syntax: ts */ `NamedNode<s_value>`,
		Object: /* syntax: ts */ `Node<s_value> | Literal<s_value, s_language, s_datatype>`,
		Datatype: /* syntax: ts */ `NamedNode<s_value>`,
	};

	function map_typing(si_prim, z_typing) {
		const g_term = H_TERMS[si_prim];
		const g_prim = H_PRIMITIVES[si_prim];

		const sj_generics =parametric(g_term?.generics) || parametric(g_prim?.generics);

		if('string' === typeof z_typing) {
			return `\texport type ${si_prim}${sj_generics} = ${z_typing};\n`;
		}
		else {
			const s_extends = z_typing['.extends'];
			delete z_typing['.extends'];

			let s_interface = '';
			for(const [si_key, sj_type] of ode(z_typing)) {
				s_interface += `\t\t${si_key}: ${sj_type};\n`;
			}

			return `\texport interface ${si_prim}${sj_generics} ${s_extends? `extends ${s_extends}`: ''} {`
				+`\n${s_interface}\t}\n\n`;
		}
	}

	for(const [si_namespace, g_form] of ode(H_FORMS)) {
		let s_body = '';
		const h_compose = {
			...H_COMPOSE_DEFAULT,
		};

		if(g_form.compose) {
			for(const [s_role, f_map] of ode(g_form.compose)) {
				h_compose[s_role] = f_map(h_compose[s_role]);
			}
		}

		const a_data = [...Object.keys(h_compose)];
		const a_anies = ['Data', 'Variable', 'Quad'];

		const f_prim = g_form.primitive;

		for(const si_prim in H_PRIMITIVES) {
			s_body += map_typing(si_prim, f_prim(si_prim, H_PRIMITIVES[si_prim]));
		}

		const g_extras = g_form.extras;
		if(g_extras) {
			for(const [si_extra, z_typing] of ode(g_extras)) {
				s_body += map_typing(si_extra, z_typing);
				if('string' === typeof z_typing) {
					a_anies.push(si_extra);
				}
			}
		}

		for(const [si_role, sj_typing] of ode(h_compose)) {
			s_body += `\texport type ${si_role}${
				parametric((generics_from(sj_typing) || []).map(fit_generic))
			} = ${sj_typing};\n`;
		}

		s_body += /* syntax: ts */ `\texport type Data = ${a_data.join(' | ')};\n`;
		s_body += /* syntax: ts */ `\texport type Any = ${a_anies.join(' | ')};\n`;

		yield `
			export namespace ${si_namespace} {\n${s_body}}
		`.trim()+'\n\n';
	}
}

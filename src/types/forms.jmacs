@import '../share/iris.jmacs';

@*{
	function explicit_union_mutations(s_word) {
		const a_forms = [];

		const a_source = s_word.split('');
		const nl_perms = 1 << s_word.length;
		for(let i_perm=0; i_perm<nl_perms; i_perm++) {
			a_forms.push(a_source.reduce((s_out, s_char, i_char) => s_out+((i_perm >> i_char) & 1? s_char.toUpperCase(): s_char), ''));
		}

		return `type Literally${s_word[0].toUpperCase()}${s_word.slice(1)} = ${a_forms.map(s => `'${s}'`).join(' | ')};`;
	}

	const A_WORDS = [
		'true',
		'false',
	];

	for(const s_word of A_WORDS) {
		yield explicit_union_mutations(s_word)+'\n';
	}

	yield `type LiterallyTrueOrFalse = LiterallyTrue | LiterallyFalse;\n`;
}

type LiterallyInteger = string;
type LiterallyDouble = string;
type LiterallyDecimal = string;

type Bcp47 = string;

@.{
	const ode = Object.entries;

	const H_GENERICS_EXTENDS = {
		ValueString: 'string',
		LanguageString: 'Bcp47',
		DatatypeString: 'Iri',
	};

	const fit_generic = si_generic => `${si_generic} extends ${H_GENERICS_EXTENDS[si_generic]}=${H_GENERICS_EXTENDS[si_generic]}`;

	const A_GENERICS_TERM_VALUE = [/* syntax: ts */ `ValueString extends string=string`];

	const R_GENERIC = /[^<]*<([^>]+)>/y;
	function generics_from(sj_union) {
		const as_terms = new Set();
		R_GENERIC.lastIndex = 0;
		for(;;) {
			const m_generic = R_GENERIC.exec(sj_union);
			if(m_generic) {
				m_generic[1].split(/\s*,\s*/g).forEach((s_term) => {
					as_terms.add(s_term);
				});
				continue;
			}

			break;
		}

		return [...as_terms];
	}

	function generics_for(si, a_only=null) {
		const g_term = H_TERMS[si];
		if(g_term?.generics?.length) {
			return g_term.generics
				.map(s => `${s.replace(/^(\w+).*/, '$1')}`)
				.filter(s => a_only? a_only.includes(s): true);
		}
	}

	const parametric = (a_generics) => a_generics && a_generics.length? `<${a_generics.join(', ')}>`: '';

	const paragenerics = (...a_args) => parametric(generics_for(...a_args));

	const docstring = (s_desc, s_super='Term') => si => `
		A${/^[AEIOUY]/i.test(si)? 'n': ''} ${si} is a {@link ${s_super}} that ${s_desc.trim()}
	`;

	const H_TERM_GENERIC = {
		properties: {
			isGraphyTerm:         true,
			isGraphyQuad:         false,
			isAbleGraph:          false,
			isAbleSubject:        false,
			isAblePredicate:      false,
			isAbleObject:         false,
			isDefaultGraph:       false,
			isNode:               false,
			isNamedNode:          false,
			isAbsoluteIri:        false,
			isRelativeIri:        false,
			isRdfTypeAlias:       false,
			isBlankNode:          false,
			isAnonymousBlankNode: false,
			isEphemeralBlankNode: false,
			isLiteral:            false,
			isSimpleLiteral:      false,
			isLanguagedLiteral:   false,
			isDatatypedLiteral:   false,
			isNumericLiteral:     false,
			isBooleanLiteral:     false,
			isIntegerLiteral:     false,
			isDoubleLiteral:      false,
			isInfiniteLiteral:    false,
			isNaNLiteral:         false,
			isDecimalLiteral:     false,
			isVariable:           false,

			termType:             /* syntax: ts */ `string`,
			value:                /* syntax: ts */ `string`,
		},

		methods: {
			equals:       si => /* syntax: ts */ `(other: RDFJS.Term): boolean`,
			flat:         si => /* syntax: ts */ `(prefixes?: PrefixMap): F1.${si}${paragenerics(si)}`,
			concise:      si => /* syntax: ts */ `(prefixes?: PrefixMap): C1.${si}${paragenerics(si)}`,
			terse:        si => /* syntax: ts */ `(prefixes?: PrefixMap): Terse.${si}`,
			star:         si => /* syntax: ts */ `(prefixes?: PrefixMap): Star.${si}`,
			verbose:      si => /* syntax: ts */ `(): Verbose.${si}${paragenerics(si)}`,
			isolate:      si => /* syntax: ts */ `(): Isolated.${si}${paragenerics(si)}`,
			hash:         si => /* syntax: ts */ `(): string`,
			replaceIri:   si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
			replaceText:  si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
			replaceValue: si => /* syntax: ts */ `(searchValue: any, replaceValue: any): ${si}`,
		},
	};

	const H_TERM_GRAPHABLE = {
		properties: {
			...H_TERM_GENERIC.properties,
			isAbleGraph:  true,
		},
	};

	const H_TERM_DEFAULT_GRAPH = {
		f1: `'*'`,
		implements: /* syntax: js */ `RDFJS.DefaultGraph`,
		properties: {
			...H_TERM_GRAPHABLE.properties,
			isDefaultGraph:       true,

			termType:             /* syntax: ts */ `'DefaultGraph'`,
			value:                /* syntax: ts */ `''`,
		},
	};

	const H_TERM_NODE = {
		properties: {
			...H_TERM_GRAPHABLE.properties,
			isNode:           true,
			isAbleSubject:    true,
			isAblePredicate:  true,
			isAbleObject:     true,
		},
	};

	const SX_C1_ABSOLUTE_IRI = '`>${ValueString}`';

	const H_TERM_NAMED_NODE = {
		c1: '`${string}:${string}`',
		f1: SX_C1_ABSOLUTE_IRI,
		generics: [/* syntax: ts */ `ValueString extends Iri=Iri`],
		implements: /* syntax: js */ `RDFJS.NamedNode`,
		docs: docstring(`
			encapsulates an absolute IRI. It is free from any context such as namespace or document.
			@see RelativeIri for using relative IRIs.
		`),
		properties: {
			...H_TERM_NODE.properties,
			isNamedNode:          true,
			isAbsoluteIri:        true,

			termType:             /* syntax: ts */ `'NamedNode'`,
			value:                /* syntax: ts */ `ValueString`,
		},
	};

	const H_TERM_RELATIVE_IRI = {
		c1: ['void'],
		f1: SX_C1_ABSOLUTE_IRI,
		generics: [/* syntax: ts */ `ValueString extends IriRelativeRef=IriRelativeRef`],
		docs: docstring(`
			encapsulates a relative IRI. In order to be used, it requires a base IRI context from a {@link PrefixMap} or document; however, such a context is not stored with this Term.
		`),
		properties: {
			...H_TERM_NODE.properties,
			isAbsoluteIri: false,
			isRelativeIri: true,

			termType:             /* syntax: ts */ `'NamedNode'`,
			value:                /* syntax: ts */ `ValueString`,
		},
		methods: {
			flat:     () => /* syntax: ts */ `(prefixes?: PrefixMap): F1.NamedNode | never`,
			concise:  () => /* syntax: ts */ `(prefixes?: PrefixMap): C1.NamedNode | never`,
			terse:    () => /* syntax: ts */ `(prefixes?: PrefixMap): Terse.NamedNode`,
			star:     () => /* syntax: ts */ `(prefixes?: PrefixMap): Star.NamedNode`,
			verbose:  () => /* syntax: ts */ `(): never`,
			hash:     () => /* syntax: ts */ `(): never`,
			isolate:  () => /* syntax: ts */ `(): Isolated.NamedNode`,
		},
	};

	const H_TERM_BLANK_NODE = {
		// f1: 'LabeldBlankNode | AnonymousBlankNode',
		generics: A_GENERICS_TERM_VALUE,
		implements: /* syntax: js */ `RDFJS.BlankNode`,
		properties: {
			...H_TERM_NODE.properties,
			isBlankNode:          true,

			termType:             /* syntax: ts */ `'BlankNode'`,
			value:                /* syntax: ts */ `ValueString`,
		},
	};

	const SX_F1_BLANK_NODE = '`#${string}`';

	const H_TERM_LABELED_BLANK_NODE = {
		class: 'BlankNode',
		f1: '`#${ValueString}`',
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring(`
			encapsulates a blank node that was created or read with a specific label.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
		},
	};

	const H_TERM_ANONYMOUS_BLANK_NODE = {
		class: 'BlankNode',
		f1: SX_F1_BLANK_NODE,
		docs: docstring(`
			encapsulates a blank node that was read from a syntactically anonymous blank node token.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
			isAnonymousBlankNode: true,
		},
	};

	const H_TERM_EPHEMERAL_BLANK_NODE = {
		class: 'BlankNode',
		f1: '`##${string}`',
		docs: docstring(`
			encapsulates a blank node that was created in order to be serialized as an anonymous blank node token.
		`),
		properties: {
			...H_TERM_BLANK_NODE.properties,
			isAnonymousBlankNode: true,
			isEphemeralBlankNode: true,

			value:                 /* syntax: ts */ `string`,
		},
	};

	const H_TERM_LITERAL = {
		implements: /* syntax: js */ `RDFJS.Literal`,
		generics: A_GENERICS_TERM_VALUE,
		properties: {
			...H_TERM_GENERIC.properties,
			isAbleObject:          true,
			isLiteral:             true,

			termType:              /* syntax: ts */ `'Literal'`,
			value:                 /* syntax: ts */ `ValueString`,
			language:              /* syntax: ts */ `string`,
			datatype:              /* syntax: ts */ `Datatype`,

			boolean:               /* syntax: ts */ `typeof NaN`,
			number:                /* syntax: ts */ `typeof NaN`,
			bigint:                /* syntax: ts */ `typeof NaN`,
		},
	};

	const H_TERM_SIMPLE_LITERAL = {
		class: 'Literal',
		f1: '`"${ValueString}`',
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring(`
			encapsulates a literal without any explicit datatype nor language tag.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isSimpleLiteral:      true,
		},
	};

	const H_TERM_LANGUAGED_LITERAL = {
		class: 'Literal',
		// TODO: narrow to BCP47 pattern
		f1: '`@${LanguageString}"${ValueString}`',
		generics: [...A_GENERICS_TERM_VALUE, /* syntax: ts */ `LanguageString extends Bcp47=Bcp47`],
		docs: docstring(`
			encapsulates a literal with a specific language tag.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isLanguagedLiteral: true,

			language:              /* syntax: ts */ `LanguageString`,
		},
	};

	const H_TERM_DATATYPED_LITERAL = {
		class: 'Literal',
		f1: '`^${NamedNode<DatatypeString>}"${ValueString}`',
		c1: ['`^${NamedNode<DatatypeString>}"${ValueString}`'],
		generics: [...A_GENERICS_TERM_VALUE, /* syntax: ts */ `DatatypeString extends Iri=Iri`],
		docs: docstring(`
			encapsulates a literal with an explicit datatype.
		`),
		properties: {
			...H_TERM_LITERAL.properties,
			isDatatypedLiteral:  true,

			datatype:              /* syntax: ts */ `Datatype<DatatypeString>`,
		},
	};

	const SX_F1_DATATYPE_XSD = '`^>http://www.w3.org/2001/XMLSchema#';
	const SX_F1_DATATYPE_LITERAL_XSD = SX_F1_DATATYPE_XSD+'${string}"${ValueString}`';

	const H_TERM_NUMERIC_LITERAL = {
		class: 'Literal',
		generics: A_GENERICS_TERM_VALUE,
		properties: {
			...H_TERM_LITERAL.properties,
			isNumericLiteral:  true,

			datatype:           /* syntax: ts */ `DatatypeXsdInteger | DatatypeXsdDouble | DatatypeXsdDecimal`,
		},
	};

	const docstring_xsd = (s_post='', s_super='Literal') => si => docstring(`
		has an XSD datatype of ${si.toLowerCase().replace(/Literal.*$/, '')}${s_post? ' '+s_post: '.'}
	`, s_super)(si);

	const H_TERM_BOOLEAN_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'boolean"${LiterallyTrueOrFalse}`',
		c1: '`^${string}:${string}"${LiterallyTrueOrFalse}`',
		generics: [/* syntax: ts */ `ValueString extends LiterallyTrueOrFalse=LiterallyTrueOrFalse`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isBooleanLiteral:  true,
			isNumberPrecise:   true,

			value:              /* syntax: ts */ `ValueString`,
			boolean:            /* syntax: ts */ `boolean`,
			number:             /* syntax: ts */ `number`,
			bigint:             /* syntax: ts */ `number`,
			datatype:           /* syntax: ts */ `DatatypeXsdBoolean`,
		},
	};


	const H_TERM_INTEGER_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'integer"${ValueString}`',
		c1: '`^${string}:${string}"${number}`',
		generics: [/* syntax: ts */ 'ValueString extends LiterallyInteger=LiterallyInteger'],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_NUMERIC_LITERAL.properties,
			isIntegerLiteral:   true,
			isNumberPrecise:    true,

			number:             /* syntax: ts */ `number`,
			bigint:             /* syntax: ts */ `number`,
			datatype:           /* syntax: ts */ `DatatypeXsdInteger`,
		},
	};

	const SX_F1_DOUBLE_LITERAL = SX_F1_DATATYPE_XSD+'double"${ValueString}`';
	const H_TERM_DOUBLE_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DOUBLE_LITERAL,
		c1: '`^${string}:${string}"${LiterallyDouble}`',
		generics: [/* syntax: ts */ `ValueString extends LiterallyDouble=LiterallyDouble`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_NUMERIC_LITERAL.properties,
			isDoubleLiteral:    true,
			isNumberPrecise:    true,

			number:             /* syntax: ts */ `number`,
			datatype:           /* syntax: ts */ `DatatypeXsdDouble`,
		},
	};

	const H_TERM_POSITIVE_INFINITY_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'double"INF`',
		c1: '`^${string}:${string}"INF`',
		docs: docstring_xsd('and a value of positive infinity', 'DoubleLiteral'),
		properties: {
			...H_TERM_DOUBLE_LITERAL.properties,
			isInfiniteLiteral:  true,
			isNumberPrecise:    false,

			// number:             /* syntax: ts */ `9e999 /* Infinity */`,
			value:              /* syntax: ts */ `'INF'`,
			datatype:           /* syntax: ts */ `DatatypeXsdDouble`,
		},
	};

	const H_TERM_NEGATIVE_INFINITY_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'double"-INF`',
		c1: '`^${string}:${string}"-INF`',
		docs: docstring_xsd('and a value of negative infinity', 'DoubleLiteral'),
		properties: {
			...H_TERM_POSITIVE_INFINITY_LITERAL.properties,

			// number:             /* syntax: ts */ `-9e999 /* -Infinity */`,
			value:              /* syntax: ts */ `'-INF'`,
			datatype:           /* syntax: ts */ `DatatypeXsdDouble`,
		},
	};

	const H_TERM_NAN_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'double"NaN`',
		c1: '`^${string}:${string}"NaN`',
		docs: docstring_xsd('and the reserved value of NaN', 'DoubleLiteral'),
		properties: {
			...H_TERM_DOUBLE_LITERAL.properties,
			isNaNLiteral:    true,
			isNumberPrecise: false,

			number:             /* syntax: ts */ `typeof NaN`,
			value:              /* syntax: ts */ `typeof NaN`,
			datatype:           /* syntax: ts */ `DatatypeXsdDouble`,
		},
	};

	const SX_C1_DATATYPE_GENERIC = '`^${string}:${string}"${string}`';

	const H_TERM_DECIMAL_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'decimal"${ValueString}`',
		c1: SX_C1_DATATYPE_GENERIC,
		generics: [/* syntax: ts */ `ValueString extends LiterallyDecimal=LiterallyDecimal`],
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isNumericLiteral:   true,
			isDecimalLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `boolean`,

			datatype:           /* syntax: ts */ `DatatypeXsdDecimal`,
			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_DATE_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'date"${ValueString}`',
		c1: SX_C1_DATATYPE_GENERIC,
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isDateLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `true`,

			datatype:           /* syntax: ts */ `DatatypeXsdDate`,
			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_DATETIME_LITERAL = {
		class: 'Literal',
		f1: SX_F1_DATATYPE_XSD+'dateTime"${ValueString}`',
		c1: SX_C1_DATATYPE_GENERIC,
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring_xsd(),
		properties: {
			...H_TERM_DATATYPED_LITERAL.properties,
			isDateTimeLiteral:   true,
			isNumberPrecise:    /* syntax: ts */ `true`,

			value:              /* syntax: ts */ `ValueString`,
			datatype:           /* syntax: ts */ `DatatypeXsdDateTime`,
			number:             /* syntax: ts */ `number`,
		},
	};

	const H_TERM_VARIABLE = {
		f1: '`?${ValueString}`',
		implements: /* syntax: js */ `RDFJS.Variable`,
		generics: A_GENERICS_TERM_VALUE,
		docs: docstring(`
			encapsulates a query variable.
		`),
		properties: {
			...H_TERM_GENERIC.properties,
			isVariable: true,

			value:             /* syntax: ts */ `ValueString`,
			termType:          /* syntax: ts */ `'Variable'`,
		},
	};

	const H_TERM_QUAD = {
		implements: /* syntax: js */ `RDFJS.Quad`,
		generics: [
			/* syntax: ts */ `SubjectValueString extends string=string`,
			/* syntax: ts */ `PredicateValueString extends Iri=Iri`,
			/* syntax: ts */ `ObjectValueString extends string=string`,
			/* syntax: ts */ `ObjectLanguageString extends Bcp47=Bcp47`,
			/* syntax: ts */ `ObjectDatatypeString extends Iri=Iri`,
			/* syntax: ts */ `GraphValueString extends string=string`,
		],
		new_args: [
			/* syntax: ts */ `kt_subject: Term.Subject<SubjectValueString>`,
			/* syntax: ts */ `kt_predicate: Term.Predicate<PredicateValueString>`,
			/* syntax: ts */ `kt_object: Term.Object<ObjectValueString>`,
			/* syntax: ts */ `kt_graph: Term.Graph<GraphValueString>`,
		],
		properties: {
			...H_TERM_GENERIC.properties,
			isGraphyQuad: true,
			termType:         /* syntax: ts */ `'Quad'`,
			value:            /* syntax: ts */ `''`,
		},
		body: /* syntax: ts */ `
			readonly subject: Term.Subject<SubjectValueString>;
			readonly predicate: Term.Predicate<PredicateValueString>;
			readonly object: Term.Object<ObjectValueString, ObjectLanguageString, ObjectDatatypeString>;
			readonly graph: Term.Graph<GraphValueString>;

			reify(label?: string): Reification;
		`,
	};

	const H_TERMS = {
		DefaultGraph: H_TERM_DEFAULT_GRAPH,
		NamedNode: H_TERM_NAMED_NODE,
		RelativeIri: H_TERM_RELATIVE_IRI,
		LabeledBlankNode: H_TERM_LABELED_BLANK_NODE,
		AnonymousBlankNode: H_TERM_ANONYMOUS_BLANK_NODE,
		EphemeralBlankNode: H_TERM_EPHEMERAL_BLANK_NODE,
		SimpleLiteral: H_TERM_SIMPLE_LITERAL,
		LanguagedLiteral: H_TERM_LANGUAGED_LITERAL,
		DatatypedLiteral: H_TERM_DATATYPED_LITERAL,
		BooleanLiteral: H_TERM_BOOLEAN_LITERAL,
		IntegerLiteral: H_TERM_INTEGER_LITERAL,
		DoubleLiteral: H_TERM_DOUBLE_LITERAL,
		PositiveInfinityLiteral: H_TERM_POSITIVE_INFINITY_LITERAL,
		NegativeInfinityLiteral: H_TERM_NEGATIVE_INFINITY_LITERAL,
		NaNLiteral: H_TERM_NAN_LITERAL,
		DecimalLiteral: H_TERM_DECIMAL_LITERAL,
		DateLiteral: H_TERM_DATE_LITERAL,
		DateTimeLiteral: H_TERM_DATETIME_LITERAL,
		Variable: H_TERM_VARIABLE,
		Quad: H_TERM_QUAD,
	};

	// const H_TERMS_ALL = {
	// 	...H_TERMS,
	// 	BlankNode: H_TERM_BLANK_NODE,
	// };
}

@*{
	yield /* syntax: ts */ `export namespace Term {`;

	// generic type
	{
		yield `\n\texport interface GenericTerm {`;
		for(const [si_property, z_default] of Object.entries(H_TERM_GENERIC.properties)) {
			let s_value;

			if(true === z_default) {
				s_value = 'true';
			}
			else if(false === z_default) {
				s_value = 'boolean';
			}
			else {
				s_value += z_default;
			}

			yield `\n\t\treadonly ${si_property}: ${s_value};`;
		}
		yield `\n\t}\n\n`;
	}

	let s_accepted = '';

	for(const [si_term, g_term] of ode(H_TERMS)) {
		const sj_generics = g_term.generics? `<${g_term.generics}>`: '';

		let sj_implements = '';
		if(g_term.implements) {
			sj_implements = `extends ${g_term.implements}`;
		}
		else if(g_term.class) {
			sj_implements = `extends RDFJS.${g_term.class}`;
		}
		if(g_term.docs) {
			let s_docs = g_term.docs;

			if('function' === typeof g_term.docs) {
				s_docs = g_term.docs(si_term) || '';
			}

			const a_lines = s_docs.trim().split(/\s*\n\s*/g);
			yield `\t/**${a_lines.map(s => `\n\t * ${s}`)}\n\t */\n`;
		}

		yield /* syntax: ts */ `\texport interface ${si_term}${sj_generics} ${sj_implements || ''} {\n`;

		for(const [si_property, sj_property] of ode(g_term.properties)) {
			yield /* syntax: ts */ `\t\treadonly ${si_property}: ${sj_property};\n`;
		}

		const s_properties = Object.keys(g_term.properties).sort().join('\n');
		if(s_properties !== s_accepted) {
			if(!s_accepted) {
				s_accepted = s_properties;
			}
			else {
				let s_missing = '';
				let s_extra = '';
				const as_acc = new Set(s_accepted.split('\n'));
				const as_prp = new Set(s_properties.split('\n'));
				for(const s_each of as_acc) {
					if(!as_prp.has(s_each)) {
						s_missing += s_each+'\n';
					}
				}
				for(const s_each of as_prp) {
					if(!as_acc.has(s_each)) {
						s_extra += s_each+'\n';
					}
				}
				console.warn(`key mismatch discovered on ${si_term}: missing: '''\n${s_missing}\n'''. extra: '''\n${s_extra}\n'''`);
			}
		}

		if(g_term.body) {
			yield '\t\t'+g_term.body.trim().split(/\s*\n+\s*/g).join('\n\t\t')+'\n';
		}

		const si_class = g_term.class || si_term;

		for(const [si_method, f_method] of ode({...H_TERM_GENERIC.methods, ...(g_term.methods || {})})) {
			yield /* syntax: ts */ `\t\t${si_method}${f_method(si_term)};\n`;
		}

		yield /* syntax: ts */ `\t}\n\n`;

		// constructor
		yield /* syntax: ts */ `\texport interface ${si_term}Constructor {\n`
			+`\t\tnew${sj_generics}(${
				g_term.new_args
					? g_term.new_args.map(s => `\n\t\t\t${s}`).join(',')
					: (generics_for(si_term) || [])
						.map(s => `s_${s.toLowerCase().replace(/string$/, '')}: ${s}`)
			}): ${si_term}${paragenerics(si_term)};\n`
			+`\t}\n\n`
			+`\texport declare const ${si_term}: ${si_term}Constructor;\n\n`;
	}

	yield /* syntax: ts */ `
		export interface Reification {
			readonly node: BlankNode;
			readonly quads: Quad[];
		}

		export type BlankNode<ValueString extends string=string> = ValueString extends Iri
			? never
			: LabeledBlankNode<ValueString> | AnonymousBlankNode | EphemeralBlankNode;

		export type Node<ValueString extends string=string> = NamedNode<ValueString> | BlankNode<ValueString>;

		export type Literal<ValueString extends string=string, LanguageString extends never | string=string, DatatypeString extends never | Iri=Iri> = SimpleLiteral<ValueString>
			| DatatypeString extends never
				? (LanguageString extends never
					? never
					: LanguagedLiteral<ValueString, LanguageString>)
				: (DatatypedLiteral<ValueString, DatatypeString>
					| LanguageString extends never
						? never
						: LanguagedLiteral<ValueString, LanguageString>
					);

		export type NumericLiteral<ValueString extends string=string> = IntegerLiteral<ValueString> | DoubleLiteral<ValueString> | DecimalLiteral<ValueString>;

		export type Graph<ValueString extends string=string> = DefaultGraph
			| string extends ''
				? never
				: Node<ValueString>;

		export type Subject<ValueString extends string=string> = Node<ValueString>;

		export type Predicate<ValueString extends Iri=Iri> = NamedNode<ValueString>;

		export type Object<ValueString extends string=string, LanguageString extends Bcp47=Bcp47, DatatypeString extends Iri=Iri> = Node<ValueString> | Literal<ValueString, LanguageString, DatatypeString>;

		export type Datatype<DatatypeString extends Iri=Iri> = NamedNode<DatatypeString>;

		export type DatatypeXsdBoolean = Datatype<'${P_IRI_XSD}boolean'>;
		export type DatatypeXsdInteger = Datatype<'${P_IRI_XSD}integer'>;
		export type DatatypeXsdDouble = Datatype<'${P_IRI_XSD}double'>;
		export type DatatypeXsdDecimal = Datatype<'${P_IRI_XSD}decimal'>;
		export type DatatypeXsdDate = Datatype<'${P_IRI_XSD}date'>;
		export type DatatypeXsdDateTime = Datatype<'${P_IRI_XSD}dateTime'>;

		export type Data<ValueString extends string=string, LanguageString extends Bcp47=Bcp47, DatatypeString extends Iri=Iri> = 
			| Graph<ValueString> | Subject<ValueString> | Object<ValueString, LanguageString, DatatypeString>
			| (ValueString extends Iri? Predicate<ValueString>: never);

		export type Any = Data | Variable | Quad | RelativeIri;
	`.replace(/\n/g, '\n\t')+'\n';

	yield /* syntax: ts */ `}\n\n`;
}

@*{
	const cv_extras = (s_cv) => ({
		Json: /* syntax: ts */ `string`,
		Directive: /* syntax: ts */ `string`,
		QuadBundle: {
			'.extends': /* syntax: ts */ `Iterable<Quad>`,
			'[Symbol.iterator]': /* syntax: ts */ `() => Iterator<Quad>`,
			'toString()': /* syntax: ts */ `${s_cv}.Json`,
		},
	});

	const H_FORMS = {
		F1: {
			primitive: (si, g) => 'f1' in g? g.f1: /* syntax: ts */ `string`,
			extras: cv_extras('F1'),
		},
		C1: {
			primitive: (si, g) => {
				let a_types = [];
				if('f1' in g) a_types.push(`F1.${si}${paragenerics(si)}`);
				if('c1' in g) {
					if('string' === typeof g.c1) a_types.push(g.c1);
					else a_types = g.c1;
				}
				return a_types.length? a_types.join(' | '): /* syntax: ts */ `string`;
			},
			extras: cv_extras('C1'),
		},
		Verbose: {
			primitive: si => /* syntax: ts */ 'DefaultGraph' === si? `''`: `string`,
		},
		Terse: {
			primitive: si => /* syntax: ts */ 'DefaultGraph' === si? `''`: `string`,
		},
		Star: {
			primitive: si => /* syntax: ts */ `Terse.${si}`,
			compose: {
				Subject: sj => /* syntax: ts */ `${sj} | Quad`,
				Object: sj => /* syntax: ts */ `${sj} | Quad`,
			},
		},
		Isolated: {
			primitive: (si) => {
				switch(si) {
					case 'DefaultGraph': return {
						termType: /* syntax: ts */ `'DefaultGraph'`,
						value: /* syntax: ts */ `''`,
					};

					case 'Literal': return {
						termType: /* syntax: ts */ `'Literal'`,
						value: /* syntax: ts */ `ValueString`,
						language: /* syntax: ts */ `LanguageString`,
						datatype: /* syntax: ts */ `Datatype<DatatypeString>`,
					};

					case 'Quad': return {
						termType: /* syntax: ts */ `'Quad'`,
						value: /* syntax: ts */ `''`,
						subject: /* syntax: ts */ `Subject`,
						predicate: /* syntax: ts */ `Predicate`,
						object: /* syntax: ts */ `Object`,
						graph: /* syntax: ts */ `Graph`,
					};

					default: return {
						termType: /* syntax: ts */ `'${si}'`,
						value: generics_for(si, ['ValueString'])?.length? 'ValueString': /* syntax: ts */ `string`,
					};
				}
			},
		},
	};

	const H_PRIMITIVES = {
		...H_TERMS,
		NamedNode: H_TERM_NAMED_NODE,
		BlankNode: {
			generics: A_GENERICS_TERM_VALUE,
			c1: 'LabeledBlankNode<ValueString> | AnonymousBlankNode | EphemeralBlankNode',
		},
		DefaultGraph: H_TERM_DEFAULT_GRAPH,
		Literal: {
			generics: [
				...A_GENERICS_TERM_VALUE,
				/* syntax: ts */ `LanguageString extends Bcp47=Bcp47`,
				/* syntax: ts */ `DatatypeString extends Iri=Iri`,
			],
			c1: 'SimpleLiteral<ValueString> | LanguagedLiteral<ValueString, LanguageString> | DatatypedLiteral<ValueString, DatatypeString>',
		},
		Variable: H_TERM_VARIABLE,
		Quad: H_TERM_QUAD,
	};

	const H_COMPOSE_DEFAULT = {
		Node: /* syntax: ts */ `NamedNode<ValueString> | BlankNode<ValueString>`,
		Graph: /* syntax: ts */ `DefaultGraph | (ValueString extends ''? never: Node<ValueString>)`,
		Subject: /* syntax: ts */ `Node<ValueString>`,
		Predicate: /* syntax: ts */ `NamedNode<ValueString>`,
		Object: /* syntax: ts */ `Node<ValueString> | Literal<ValueString, LanguageString, DatatypeString>`,
		Datatype: /* syntax: ts */ `NamedNode<ValueString>`,
	};

	function map_typing(si_prim, z_typing) {
		const g_term = H_TERMS[si_prim];
		const g_prim = H_PRIMITIVES[si_prim];

		const sj_generics =parametric(g_term?.generics) || parametric(g_prim?.generics);

		if('string' === typeof z_typing) {
			return `\texport type ${si_prim}${sj_generics} = ${z_typing};\n`;
		}
		else {
			const s_extends = z_typing['.extends'];
			delete z_typing['.extends'];

			let s_interface = '';
			for(const [si_key, sj_type] of ode(z_typing)) {
				s_interface += `\t\t${si_key}: ${sj_type};\n`;
			}

			return `\texport interface ${si_prim}${sj_generics} ${s_extends? `extends ${s_extends}`: ''} {`
				+`\n${s_interface}\t}\n\n`;
		}
	}

	for(const [si_namespace, g_form] of ode(H_FORMS)) {
		let s_body = '';
		const h_compose = {
			...H_COMPOSE_DEFAULT,
		};

		if(g_form.compose) {
			for(const [s_role, f_map] of ode(g_form.compose)) {
				h_compose[s_role] = f_map(h_compose[s_role]);
			}
		}

		const a_data = [...Object.keys(h_compose)];
		const a_anies = ['Data', 'Variable', 'Quad'];

		const f_prim = g_form.primitive;

		for(const si_prim in H_PRIMITIVES) {
			s_body += map_typing(si_prim, f_prim(si_prim, H_PRIMITIVES[si_prim]));
		}

		const g_extras = g_form.extras;
		if(g_extras) {
			for(const [si_extra, z_typing] of ode(g_extras)) {
				s_body += map_typing(si_extra, z_typing);
				if('string' === typeof z_typing) {
					a_anies.push(si_extra);
				}
			}
		}

		for(const [si_role, sj_typing] of ode(h_compose)) {
			s_body += `\texport type ${si_role}${
				parametric((generics_from(sj_typing) || []).map(fit_generic))
			} = ${sj_typing};\n`;
		}

		s_body += /* syntax: ts */ `\texport type Data = ${a_data.join(' | ')};\n`;
		s_body += /* syntax: ts */ `\texport type Any = ${a_anies.join(' | ')};\n`;

		yield `
			export namespace ${si_namespace} {\n${s_body}}
		`.trim()+'\n\n';
	}
}

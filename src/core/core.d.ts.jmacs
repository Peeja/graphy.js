@import '../share/iris.jmacs';

import {
	RDFJS,
	Role,
	Iri,
	Terse,
	C1,
	Term,
	SubjectData,
	PredicateData,
	ObjectData,
	GraphData,
	PrefixMap,
	PrefixMapRelation,
	Qualifier,
	Descriptor,
	F1,
} from '@graphy/types';

export namespace DataFactory {
	/**
	 * Creates a new `DefaultGraph`.
	 */
	function defaultGraph(): Term.DefaultGraph;

	/**
	 * Creates a new `NamedNode`.
	 * @param iri - the IRI of this NamedNode
	 */
	function namedNode<ValueString extends Iri>(iri: ValueString): Term.NamedNode<ValueString>;

	/**
	 * Creates a new `BlankNode`.
	 * @param label - the optional label to give this BlankNode; otherwise, a Version 4 UUID is generated for the label
	 */
	function blankNode<ValueString extends string=string>(value?: ValueString): Term.BlankNode<ValueString>;

	/**
	 * Creates a new ephemeral instance of an anonymous `BlankNode`, which will serialize as a syntactic anonymous blank node.
	 */
	function ephemeralBlankNode(): Term.EphemeralBlankNode;

	/**
	 * Creates a new `Literal`.
	 * @param contents - the string contents of this Literal.
	 * @param languageOrDatatype - if passed a string, sets the language tag of this literal; otherwise, sets the datatype
	 */
	function literal<ValueString extends string, LanguageString extends Bcp47=Bcp47, DatatypeString extends string=string>(contents: ValueString, languageOrDatatype?: LanguageString | Role.Datatype<DatatypeString>): Term.Literal<ValueString, LangauageString, DatatypeString>;

	@.{
		H_TYPE_ROUTER_BOOLEAN_LITERAL = {
			[/* syntax: ts */ `'false'`]: [
				/* syntax: ts */ `false`,
				/* syntax: ts */ `0`,
				/* syntax: ts */ `0n`,
				/* syntax: ts */ `'0'`,
				/* syntax: ts */ `'F'`,
				/* syntax: ts */ `'f'`,
				/* syntax: ts */ `LiterallyFalse`,
			],
			[/* syntax: ts */ `'true'`]: [
				/* syntax: ts */ `true`,
				/* syntax: ts */ `1`,
				/* syntax: ts */ `1n`,
				/* syntax: ts */ `'1'`,
				/* syntax: ts */ `'T'`,
				/* syntax: ts */ `'t'`,
				/* syntax: ts */ `LiterallyTrue`,
			],
		};

		function *route_bolean_literal_types() {
			for(const sj_value_string in H_TYPE_ROUTER_BOOLEAN_LITERAL) {
				const a_tests = H_TYPE_ROUTER_BOOLEAN_LITERAL[sj_value_string];

				for(const sj_test of a_tests) {
					yield `ValueType extends ${sj_test}
						? Term.BooleanLiteral<${sj_value_string}>
					: `;
				}
			}
			yield 'never;';
		}
	}
	/**
	 * Creates a new `BooleanLiteral`, which will serialize as a syntactic boolean and has special getters.
	 * @param value - the value of this BooleanLiteral, one of: `true`, `false`, `1`, `0`, `1n`, `0n` or any `string` that matches `/^([Tt](rue)?|TRUE)$/` or `/^([Ff](alse)?|FALSE)$/`
	 */
	function booleanLiteral<ValueType extends @{Object.values(H_TYPE_ROUTER_BOOLEAN_LITERAL).flat().join(' | ')}>(value: ValueType): @*{yield* route_bolean_literal_types()}

	/**
	 * Creates a new `IntegerLiteral`, which will serialize as a syntactic integer and has special getters.
	 * @param value - the value of this IntegerLiteral, either as `number` or `string`
	 */
	function integerLiteral<ValueType extends number | bigint | string>(value: ValueType): ValueType extends string
		? Term.IntegerLiteral<ValueType>
		: Term.IntegerLiteral;

	/**
	 * Creates a new `DoubleLiteral`, which will serialize as a syntactic double and has special getters.
	 * @param value - the value of this DoubleLiteral, either as `number` or `string`
	 */
	function doubleLiteral<ValueType extends number | string>(value: ValueType): ValueType extends string
		? Term.DoubleLiteral<ValueType>
		: Term.DoubleLiteral;
	
	/**
	 * Creates a new `DecimalLiteral`, which will serialize as a syntactic decimal and has special getters.
	 * @param value - the value of this DecimalLiteral, either as `number`, `bigint` or `string`
	 */
	function decimalLiteral<ValueType extends number | bigint | string>(value: ValueType): ValueType extends string
		? Term.DecimalLiteral<ValueType>
		: Term.DecimalLiteral;
	
	/**
	 * Creates a new `NumericLiteral`, manifesting as one of: `IntegerLiteral`, `DoubleLiteral`, `DecimalLiteral`, `PositiveInfinityLiteral`, `NegativeInfinityLiteral`, or `NaNLiteral`, which will serialize as a syntactic numeric literal and has special getters.
	 * @param value - the value of this IntegerLiteral, either as `number`, `bigint` or `string`
	 */
	function numericLiteral<ValueType extends number | bigint | string>(value: ValueType): ValueType extends string
		? Term.NumericLiteral<ValueType>
		: Term.NumericLiteral;

	/**
	 * Creates a new `DatatypedLiteral` from a `Date` object, with date-level precision, using `xsd:date` for the datatype.
	 * @param date - the date object to create this DatatypedLiteral from
	 */
	function dateLiteral(date: Date): Term.DateLiteral;

	/**
	 * Creates a new `DatatypedLiteral` from a `Date` object, with millisecond precision, using `xsd:dateTime` for the datatype.
	 * @param date - the date object to create this DatatypedLiteral from
	 */
	function dateTimeLiteral(dateTime: Date): Term.DateTimeLiteral;

	type quad<
		w_qualifier extends Qualifier = [QuadTypeKey],
	> = FromQualifier<w_qualifier> extends infer a_descriptor
		? a_descriptor extends Descriptor
			? (subject: SubjectData<Descriptor.Access<a_descriptor, 'subject'>>,
				predicate: PredicateData<Descriptor.Access<a_descriptor, 'predicate'>>,
				object: ObjectData<Descriptor.Access<a_descriptor, 'object'>>,
				graph?: GraphData<Descriptor.Access<a_descriptor, 'graph'>>
			) => Term.Quad<a_descriptor>
			: never
		: never;

	/**
	 * Creates a new `Quad`.
	 * @param subject - the subject of this Quad
	 * @param predicate - the predicate of this Quad
	 * @param object - the object of this Quad
	 * @param graph - the optional graph of this Quad; otherwise, defaults to `DefaultGraph`
	 */
	const quad: quad;

	// function quad<
	// 	SubjectTermTypeString extends string=string,
	// 	SubjectValueString extends string=string,
	// 	PredicateValueString extends string=string,
	// 	ObjectTermTypeString extends string=string,
	// 	ObjectValueString extends string=string,
	// 	ObjectLanguageString extends string=string,
	// 	ObjectDatatypeString extends string=string,
	// 	GraphTermTypeString extends string=string,
	// 	GraphValueString extends string=string,
	// >(subject: Role.Subject<SubjectTermTypeString, SubjectValueString>,
	// 	predicate: Role.Predicate<PredicateValueString>,
	// 	object: Role.Object<ObjectTermTypeString, ObjectValueString, ObjectLanguageString, ObjectDatatypeString>,
	// 	graph?: Role.Graph<GraphTermTypeString, GraphValueString>
	// ): Term.Quad<
	// 	Term.Subject<SubjectTermTypeString, SubjectValueString>,
	// 	Term.Predicate<PredicateValueString>,
	// 	Term.Object<ObjectTermTypeString, ObjectValueString, ObjectLanguageString, ObjectDatatypeString>,
	// 	Term.Graph<GraphTermTypeString, GraphValueString>,
	// >;

	/**
	 * @deprecated Use `.quad()` instead
	 */
	function triple(): Term.Quad;

	/**
	 * Creates a new `Variable`.
	 * @param name - the name of this Variable
	 */
	function variable<ValueString extends string>(name: ValueString): Term.Variable<ValueString>;


	/**
	 * Returns `term` if it is already a graphy Term (including Quads), otherwise calls `fromRdfjsTerm` or `fromC1` depending on the argument's type.
	 * @param term - the Term to convert
	 * @param prefixes - prefix map to use for prefixed names / relative IRIs in c1 string
	 */
	function fromTermLike<TermType extends Term.Any=Term.Any>(term: RDFJS.Term | C1.Any, prefixes: PrefixMap): TermType;

	/**
	 * Returns `term` if it is already a graphy Term (including Quads), otherwise calls `fromRdfjsTerm`.
	 * @param term - the Term to convert
	 */
	function fromTerm<TermType extends Term.Any=Term.Any>(term: RDFJS.Term): TermType;

	/**
	 * Returns `quad` if it is already a graphy Quad, otherwise calls `fromRdfjsQuad`.
	 * @param term - the Quad to convert
	 */
	function fromQuad(src: RDFJS.Quad): Term.Quad;

	/**
	 * Convert an RDFJS compatible Term (including Quads) to a graphy Term.
	 * @param term - the Term to convert
	 */
	function fromRdfjsTerm<TermType extends Term.Any=Term.Any>(term: RDFJS.Term): TermType;

	/**
	 * Convert an RDFJS compatible Quad to a graphy Quad.
	 * @param quad - the Quad to convert
	 */
	function fromRdfjsQuad(src: RDFJS.Quad): Term.Quad;

	type C1Map<ValueString extends string=string, LanguageString extends string=string, DatatypeString extends string=string> = {
		_Never: never;
		DefaultGraph: C1.DefaultGraph;
		NamedNode: C1.NamedNode<ValueString>;
		RelativeIri: never;
		BlankNode: C1.BlankNode<ValueString>;
		LabeledBlankNode: C1.LabeledBlankNode<ValueString>;
		AnonymousBlankNode: C1.AnonymousBlankNode;
		EphemeralBlankNode: C1.EphemeralBlankNode;
		Literal: C1.Literal<ValueString, LangauageString, DatatypeString>;
		SimpleLiteral: C1.SimpleLiteral<ValueString>;
		LanguageLiteral: C1.LanguageLiteral<ValueString, LanguageString>;
		DatatypedLiteral: C1.DatatypedLiteral<ValueString, DatatypeString>;
	};

	type TermMap<ValueString extends string=string, LanguageString extends string=string, DatatypeString extends string=string> = {
		_Never: never;
		DefaultGraph: Term.DefaultGraph;
		NamedNode: Term.NamedNode<ValueString>;
		RelativeIri: Term.RelativeIri<ValueString>;
		BlankNode: Term.BlankNode<ValueString>;
		LabeledBlankNode: Term.LabeledBlankNode<ValueString>;
		AnonymousBlankNode: Term.AnonymousBlankNode;
		EphemeralBlankNode: Term.EphemeralBlankNode;
		Literal: Term.Literal<ValueString, LangauageString, DatatypeString>;
		SimpleLiteral: Term.SimpleLiteral<ValueString>;
		LanguageLiteral: Term.LanguageLiteral<ValueString, LanguageString>;
		DatatypedLiteral: Term.DatatypedLiteral<ValueString, DatatypeString>;
	};

	@*{
		const H_INFERENCE_MAP_P1 = {
			'*': {
				type: 'DefaultGraph',
			},
			'##${string}': {
				type: 'EphemeralBlankNode',
			},
			'#${infer ValueString}': {
				type: 'LabeledBlankNode',
				pass: ['ValueString'],
			},
			'>${infer ValueString}': {
				type: 'NamedNode',
				pass: ['ValueString'],
			},
			'@${infer LanguageString}"${infer ValueString}': {
				type: 'LanguagedLiteral',
				pass: ['ValueString', 'LanguageString'],
			},
			'"${infer ValueString}': {
				type: 'SimpleLiteral',
				pass: ['ValueString'],
			},
			'?${infer ValueString}': {
				type: 'Variable',
				pass: ['ValueString'],
			},
			// [`^>${P_IRI_XSD}boolean"\${false | true | 0 | 1 | 0n | 1n | '0' | '1' | 'F' | 'T'}`]: {
			// 	pass: 'BooleanLiteral',
			// 	pass: ['ValueString', 'any', 'any'],
			// },
			'^>${infer DatatypeValue}"${infer ValueString}': {
				type: 'DatatypedLiteral',
				pass: ['ValueString', 'any', 'DatatypeValue'],
			},
		};

		const H_INFERENCE_MAP_C1 = {
			...H_INFERENCE_MAP_P1,
			'^${infer DatatypePrefix}:${infer DatatypeLocal}"${infer ValueString}': {
				type: 'DatatypedLiteral',
				pass: ['ValueString', 'any', '`${string}${DatatypeLocal}`'],
			},
			'\\`[${string}]{${string}}': {
				type: '_Never',
			},
			'${infer Prefix}:${infer Local}': {
				type: 'NamedNode',
				pass: ['`${string}${Local}`'],
			},
		};

		function *build_term_inferences(s_type, h_map) {
			yield /* syntax: ts */ `type InferFrom${s_type}<${s_type}String extends ${s_type}.Any> = \n\t\t`;
			for(const [si_pattern, g_entry] of Object.entries(h_map)) {
				yield /* syntax: ts */ `${s_type}String extends \`${si_pattern}\`
							? ['${g_entry.type}', ${
								[
									...g_entry.pass || [],
									...Array(2).fill('any'),
								].slice(0, 2).join(', ')
							}]
						: `;
			}
			yield /* syntax: ts */ `never;`;
		}

		yield* build_term_inferences('P1', H_INFERENCE_MAP_P1)
		yield '\n\n';
		yield* build_term_inferences('C1', H_INFERENCE_MAP_C1);
	}

	export type TermFromC1<
		C1String extends C1.Any,
	> = InferFromC1<C1String> extends [infer ClassString, infer ValueString, infer LanguageOrDatatypeString]
		? (ClassString extends keyof TermMap
			? (ValueString extends string
				? (LanguageOrDatatypeString extends string
					? TermMap<ValueString, LanguageOrDatatypeString>[ClassString]
					: TermMap<ValueString>[ClassString]
				)
				: TermMap[ClassString]
			)
			: never
		)
		: never;

	export type TermFromP1<
		P1String extends P1.Any,
	> = InferFromP1<P1String> extends [infer ClassString, infer ValueString, infer LanguageOrDatatypeString]
		? (ClassString extends keyof TermMap
			? (ValueString extends string
				? (LanguageOrDatatypeString extends string
					? TermMap<ValueString, LanguageOrDatatypeString>[ClassString]
					: TermMap<ValueString>[ClassString]
				)
				: TermMap[ClassString]
			)
			: never
		)
		: never;


	/**
	 * Construct a graphy Term from a c1 string
	 * @param {C1.Any} term - the c1 string of a Term
	 * @param  {PrefixMap} prefixes - prefix map to use for prefixed names / relative IRIs
	 * @return {Term.NamedNode} - an RDFJS-compatible graphy Term object
	 */
	function fromC1<C1String extends C1.Any=C1.Any>(term: C1String, prefixes?: PrefixMap): TermFromC1<C1String>;

	/**
	 * Construct a graphy NamedNode from a c1 string
	 * @param {P1.Any} term - the p1 string of a NamedNode
	 * @param  {PrefixMap} prefixes - prefix map to use for prefixed names / relative IRIs
	 * @return {Term.NamedNode} - an RDFJS-compatible graphy NamedNode object
	 */
	function fromP1<P1String extends P1.Any=P1.Any>(term: P1String, prefixes?: PrefixMap): TermFromP1<P1String>;
	
	function comment(): C1.Directive;
	function newlines(): C1.Directive;

	function concise(iri: Iri, prefixes?: PrefixMap): C1.NamedNode;
	function terse(iri: Iri, prefixes?: PrefixMap): Terse.NamedNode;


	function c1CompactData<C1Type extends C1.Data=C1.Data>(term: C1Type, prefixes: PrefixMap): C1Type;
	function c1ExpandData<C1Type extends C1.Data=C1.Data>(term: C1Type, prefixes: PrefixMap): C1Type;

	function graphFromC1(graph: C1.Graph, prefixes: PrefixMap): Term.Graph;
	function subjectFromC1(subject: C1.Subject, prefixes: PrefixMap): Term.Subject;
	function predicateFromC1(subject: C1.Predicate, prefixes: PrefixMap): Term.Predicate;
	function objectFromC1(objectRole: C1.Object, prefixes: PrefixMap): Term.Object;

	function c1FromGraphRole(graph: StarRole.Graph, prefixes: PrefixMap): C1.Graph;
	function c1FromSubjectRole(subject: StarRole.Subject, prefixes: PrefixMap): C1.Subject;
	function c1FromPredicateRole(predicate: StarRole.Predicate, prefixes: PrefixMap): C1.Predicate;
	function c1FromObjectRole(object: StarRole.Object, prefixes: PrefixMap): C1.Object;

	// function c1Graphable(graph: graphy.ConciseGraphable, prefixes?: graphy.PrefixMap): graphy.Graphable;
	// function c1Node(node: graphy.ConciseNode, prefixes?: graphy.PrefixMap): graphy.Node;
	// function c1NamedNode(namedNode: graphy.ConciseNamedNode, prefixes?: graphy.PrefixMap): graphy.NamedNode;
	// function c1DataTerm(dataTerm: graphy.ConciseDataTerm): graphy.DataTerm;
	// function c1Literal(dataTerm: graphy.ConciseLiteral): graphy.GenericLiteral;

	function c3(triples: C4.Triples, prefixes?: PrefixMap, graph?: C1.Graph): C1.QuadBundle;
	function c4(quads: C4.Quads, prefixes?: PrefixMap): C1.QuadBundle;

	function relatePrefixMaps(prefixesA: PrefixMap, prefixesB: PrefixMap): PrefixMapRelation;
	function prefixMapsDiffer(prefixesA: PrefixMap, prefixesB: PrefixMap): boolean;
}

export default DataFactory;

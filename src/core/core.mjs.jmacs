@import '../share/iris.jmacs'
@import '../content/text.read.jmacs'

import crypto from 'crypto';

// create sha256 hash digest of an input string
const hash = s => crypto.createHash('sha256').update(s).digest('base64');


const R_INVALID_IRIREF = /([\x00-\x20<>"{}|^`\\]|%(?![0-9A-F][0-9A-F]))/g;
const F_REPLACE_INVALID_IRIREF = (s_, s_v) => {
	let s_code = s_v.codePointAt(0).toString(16)+'';
	return s_code.length > 4
		? '\\U'+s_code.padStart(8, '0')
		: '\\u'+s_code.padStart(4, '0');
};

export const clean_iri = p_iri_dirty => p_iri_dirty.replace(R_INVALID_IRIREF, F_REPLACE_INVALID_IRIREF);
export {
	clean_iri as cleanIri,
};

@>> MK_RANGE_PN_HIGH(b_extend=false)
	@// #x00B7
	@- b_extend
		@//@regex
		{-\u00b6
		\u00b8-\u00bf
	@//@
	@:
		@//@regex
		{-\u00bf
	@;

	@//@regex
	\u00d7\u00f7

	@//@
	@- !b_extend
		\u0300-\u306f
	@;

	@//@regex
	\u037e
	\u2000-\u200b

	@- b_extend
		\u200e-\u203e
		\u2041-\u206f
	@:
		\u200e-\u206f
	@;

	@//@regex
	\u2190-\u2bff
	\u2ff0-\u3000
	\ud800-\uf8ff
	\ufdd0-\ufddf
	\ufffe\uffff
@;

@>> MK_RT_AVOID_PNAME_LOCAL()
	@//@regex
	^
	(?:
		\\
		| [						@// * first character *
			\u0000-\/ 			@// 0-:
			;-@					@// A-Z
			[-^					@// _
			`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * middle characters *
				\\
				| [
					\u0000-,
					\/;-@
					[-^
					`
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
			.+					@// * at least one final character *
		)
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * final character *
				\\
				| [
					\u0000-, 	@// -
					.\/			@// 0-:
					;-@			@// A-Z
					[-^			@// _
					`			@// a-z
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
		)
	)
	$
@;

@>> MK_RT_AVOID_PNAME_NS()
	@//@regex
	^
	(?:
		[
			\u0000-@ 			@// A-Z
			[-`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			[
				\u0000-, 	@// -.
				\/			@// 0-9
				:-@			@// A-Z
				[-^			@// _
				`			@// a-z
				@{MK_RANGE_PN_HIGH(true)}
			]
			.*
		)
		| .+ \. 				@// * ends with a full stop character *
	)
	$
@;


// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_NS = /@{MK_RT_AVOID_PNAME_NS()}/;

// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_LOCAL = /@{MK_RT_AVOID_PNAME_LOCAL()}/;

// absolute iri tester
const RT_IRI_ABSOLUTE = /^[A-Za-z]/;

const RT_BOOLEAN_TRUE = /^([Tt](rue)?|TRUE)$/;
const RT_BOOLEAN_FALSE = /^([Ff](alse)?|FALSE)$/;

const S_UUID_V4 = 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
const R_UUID_V4 = /[xy]/g;

export const uuidv4 = () => {
	let dt_now = Date.now();
	if('undefined' !== typeof performance) dt_now += performance.now();
	return S_UUID_V4.replace(R_UUID_V4, (s) => {
		let x_r = (dt_now + (Math.random()*16)) % 16 | 0;
		dt_now = Math.floor(dt_now / 16);
		return ('x' === s? x_r: ((x_r & 0x3) | 0x8)).toString(16);
	});
};


// key to access cache on a prefix mapping
export const SI_PREFIX_CACHE = ' (cache)';

// key to access base
export const SI_PREFIX_BASE = ' (base)';

// escape characters for compiling regexes
const R_REGEX_ESCAPE = /[$^*()+[\\{}|.?]/g;

// valid locals of prefixed names
const SR_PN_LOCAL = '(@{(PN_LOCAL(true)+'').replace(/['\\]/g, '\\$&')})$';


// create a cache on a prefix mapping
export function cache_prefixes(h_prefixes, b_terse=false) {
	// regex cache string building
	let a_cache = [];

	// inverse mappings
	let h_inverse = {};

	// each prefix/iri pair
	for(let si_prefix in h_prefixes) {
		let p_iri = h_prefixes[si_prefix];

		// prefix would make an invalid namespace; skip
		if(b_terse && RT_AVOID_PNAME_NS.test(si_prefix)) continue;

		// save inverse mapping
		h_inverse[p_iri] = si_prefix;

		// push iri
		a_cache.push(p_iri.replace(R_REGEX_ESCAPE, '\\$&'));
	}

	// no prefixes; forgo cache
	if(!a_cache.length) return h_prefixes;

	// save cache object
	Object.defineProperty(h_prefixes, SI_PREFIX_CACHE, {
		enumerable: false,
		value: {
			_r_iris: new RegExp(`^(${a_cache.join('|')})${SR_PN_LOCAL}`, 'u'),
			_h_inverse: h_inverse,
		},
	});

	// freeze object
	return Object.freeze(h_prefixes);
}

export {
	cache_prefixes as cachePrefixes,
};


@$ B_OPTIMIZE_PREFIX_COMPRESSION = false;

@- B_OPTIMIZE_PREFIX_COMPRESSION
	const R_COMPRESS = /^(.*?)([^/#]*)$/;
@;

@> curie_prefix_cache()
	// ref cache
	let g_cache = h_prefixes[SI_PREFIX_CACHE];

	// cache exists
	if(g_cache) {
		@- B_OPTIMIZE_PREFIX_COMPRESSION
			// iri compression
			let m_compress = R_COMPRESS.exec(p_iri);
			if(m_compress) {
				let p_compress = m_compress[1];
				let h_inverse = g_cache._h_inverse;
				if(p_compress in h_inverse) {
					return h_inverse[p_compress]+':'+m_compress[2];
				}
			}
		@;

		// iri matching
		let m_iri = g_cache._r_iris.exec(p_iri);

		// prefix mapped; compress
		if(m_iri) {
			return g_cache._h_inverse[m_iri[1]]+':'+m_iri[2];
		}
	}
@;

// attempt to turn an iri into a terse prefixed name
export const terse = (p_iri, h_prefixes) => {
	@{curie_prefix_cache()}
	// base IRI exists 
	else if(SI_PREFIX_BASE in h_prefixes) {
		// ref base IRI
		const p_base = h_prefixes[SI_PREFIX_BASE];

		// named node can be turned into relative IRI
		if(p_iri.startsWith(p_base)) {
			return '<'+p_iri.slice(p_base.length)+'>';
		}
	}
	// cache does not exist
	else {
		// best prefix id
		let si_best_prefix = '';
		let s_best_suffix = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(let si_prefix in h_prefixes) {
			let p_prefix_iri = h_prefixes[si_prefix];

			// target iri starts with prefix iri and its longer than the current best
			if(0 === p_iri.indexOf(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri
				// namespace is okay to use
				&& !RT_AVOID_PNAME_NS.test(si_prefix)
			) {
				// compute suffix
				let s_suffix = p_iri.slice(p_prefix_iri.length);

				// suffix is okay to use
				if(!RT_AVOID_PNAME_LOCAL.test(s_suffix)) {
					s_best_suffix = s_suffix;

					// save prefix id as best
					si_best_prefix = si_prefix;

					// update best iri length
					nl_best_prefix_iri = p_prefix_iri.length;
				}
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			// use terse prefixed name
			return si_best_prefix+':'+s_best_suffix;
		}
	}

	// fallback
	return '<'+p_iri+'>';
};

// attempt to turn an iri into a concise prefixed name
export const concise = (p_iri, h_prefixes={}) => {
	@{curie_prefix_cache()}
	// cache does not exists
	else {
		// best prefix id
		let s_best_prefix_id = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(let s_prefix_id in h_prefixes) {
			let p_prefix_iri = h_prefixes[s_prefix_id];

			// target iri starts with prefix iri and its longer than the current best
			if(p_iri.startsWith(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri) {
				// save prefix id as best
				s_best_prefix_id = s_prefix_id;

				// update best iri length
				nl_best_prefix_iri = p_prefix_iri.length;
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			return s_best_prefix_id+':'+p_iri.slice(nl_best_prefix_iri);
		}
	}

	// no prefix found; default to full iri
	return '>'+p_iri;
};

const R_C1N_DECONSTRUCT = /^([^:]*):(.*)$/;

export function c1_to_nt(sc1_in, h_prefixes={}, b_verbose=false) {
	switch(sc1_in[0]) {
		// absolute iri
		case '>': return '<'+sc1_in.slice(1)+'>';

		// blank node
		case '_': {
			// anonymous or ephemeral hint
			if(sc1_in.length <= 2 || '#' === sc1_in[2]) {
				return (new EphemeralBlankNode())[b_verbose? 'verbose': 'terse']();
			}
			// labeled
			else {
				return sc1_in;
			}
		}

		// simple literal
		case '"': return JSON.stringify(sc1_in.slice(1));

		// languaged literal
		case '@': {
			let i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+sc1_in.slice(0, i_contents);
		}

		// datatyped literal
		case '^': {
			let i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+'^^'+c1_to_nt(sc1_in.slice(1, i_contents), h_prefixes, b_verbose);
		}

		// default graph
		case '*': return '';

		// directive / node explicit
		case '<':
		case '`': return c1(sc1_in).terse(h_prefixes);

		// otherwise
		default: {
			// rdf:type alis
			if('a' === sc1_in) return b_verbose? '<@{P_IRI_RDF}type>': 'a';

			// deconstruct prefixed name
			let [, si_prefix, s_suffix] = R_C1N_DECONSTRUCT.exec(sc1_in);

			// avoid illegal prefixed name parts
			if(b_verbose || RT_AVOID_PNAME_LOCAL.test(s_suffix) || RT_AVOID_PNAME_NS.test(si_prefix)) {
				return '<'+h_prefixes[si_prefix]+s_suffix+'>';
			}

			// good as-is
			return sc1_in;
		}
	}
}

export {
	c1_to_nt as c1ToNt,
};

@$ R_DECLARE = /^\s*class\s*([^\s]+)\s*(?:extends\s*([^\s]+)\s*)/;

@$ declare_properties = function*(h_properties={}, sj_target='gp_self') {
	for(const [si_property, sj_value] of Object.entries(h_properties || {})) {
		yield /* syntax: js */ `
			${sj_target}.${si_property} = ${sj_value};`;
	}
};

@def declare(s_declare, g_def)
	@.{
		const [, s_class, s_extends] = R_DECLARE.exec(s_declare);
		const sj_constructor = Object.hasOwnProperty.call(g_def, 'constructor')
			? g_def.constructor.toString().replace(/^constructor/, '')
			: /* syntax: js */ `() {}`;

		const g_methods = Object.getOwnPropertyDescriptors(g_def.methods? g_def.methods.prototype : {});
		delete g_methods.constructor;
	}
	function @{s_class}@{sj_constructor} {
		const gp_self = @{s_class}.prototype = Object.create(@{s_extends}.prototype);
		gp_self.constructor = @{s_class};
		@*{
			for(const [si_method, g_method] of Object.entries(g_methods)) {
				if('function' === typeof g_method.value) {
					yield /* syntax: js */ `
						gp_self.${si_method} = function ${s_class}$${g_method.value.toString()};
					`;
				}
				else if('function' === typeof g_method.get) {
					yield /* syntax: j */ `
						Object.defineProperty(gp_self, '${si_method}', {
							get${g_method.get.toString().replace(/^get [^\(]+/, '')},
						})
					`;
				}
			}
		} @*{yield* declare_properties(g_def.properties)}
	}
@;

class GenericTerm {
	valueOf() {
		return this.concise();
	}

	equals(z_other) {
		return z_other
			? this === z_other
				|| (z_other.termType === this.termType && z_other.value === this.value)
			: false;
	}

	hash() {
		return hash(this.concise());
	}

	replace(w_pattern, w_replace) {
		return new this.constructor(this.value.replace(w_pattern, w_replace));
	}

	replaceAll(w_pattern, w_replace) {
		return new this.constructor(this.value.replaceAll(w_pattern, w_replace));
	}
} {
	const gp_self = GenericTerm.prototype;
	@*{yield* declare_properties({
		isGraphyTerm: /* syntax: js */ `true`,
		toString: /* syntax: js */ `gp_self.valueOf`,
		isGraphyQuad:          /* syntax: js */ `false`,
		isAbleGraph:           /* syntax: js */ `false`,
		isAbleSubject:         /* syntax: js */ `false`,
		isAblePredicate:       /* syntax: js */ `false`,
		isAbleObject:          /* syntax: js */ `false`,
		isDefaultGraph:        /* syntax: js */ `false`,
		isNode:                /* syntax: js */ `false`,
		isNamedNode:           /* syntax: js */ `false`,
		isRelativeNamedNode:   /* syntax: js */ `false`,
		isRdfTypeAlias:        /* syntax: js */ `false`,
		isBlankNode:           /* syntax: js */ `false`,
		isAnonymousBlankNode:  /* syntax: js */ `false`,
		isEphemeralBlankNode:  /* syntax: js */ `false`,
		isLiteral:             /* syntax: js */ `false`,
		isLanguagedLiteral:    /* syntax: js */ `false`,
		isDatatypedLiteral:    /* syntax: js */ `false`,
		isSimpleLiteral:       /* syntax: js */ `false`,
		isNumericLiteral:      /* syntax: js */ `false`,
		isIntegerLiteral:      /* syntax: js */ `false`,
		isDoubleLiteral:       /* syntax: js */ `false`,
		isDecimalLiteral:      /* syntax: js */ `false`,
		isBooleanLiteral:      /* syntax: js */ `false`,
		isInfiniteLiteral:     /* syntax: js */ `false`,
		isNaNLiteral:          /* syntax: js */ `false`,
	})}
}

@{declare(/* syntax: js */ `class NamedNode extends GenericTerm`, {
	constructor(s_iri) {
		this.value = s_iri;
	},
	/* eslint-disable no-undef */
	methods: class {
		concise(h_prefixes={}) {
			return concise(this.value, h_prefixes);
		}

		terse(h_prefixes={}) {
			return terse(this.value, h_prefixes);
		}

		verbose() {
			return '<'+this.value+'>';
		}

		isolate() {
			return {
				termType: 'NamedNode',
				value: this.value,
			};
		}

		hash() {
			return hash('>'+this.value);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleGraph:           /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAblePredicate:       /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		isNode:                /* syntax: js */ `true`,
		isNamedNode:           /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'NamedNode'`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}

/**
 * A relative named node is a special kind of term takes on the base IRI of the prefix map given at the time it is
 */
@{declare(/* syntax: js */ `class RelativeNamedNode extends NamedNode`, {
	/* eslint-disable no-undef */
	methods: class {
		concise(h_prefixes={}) {
			if(h_prefixes[SI_PREFIX_BASE]) {
				return (new NamedNode(h_prefixes[SI_PREFIX_BASE]+this.value)).concise(h_prefixes);
			}
			else {
				throw new Error(`Cannot create concise string out of relative IRI: '${this.value}'`);
			}
		}

		terse(h_prefixes={}) {
			if(h_prefixes[SI_PREFIX_BASE]) {
				return (new NamedNode(h_prefixes[SI_PREFIX_BASE]+this.value)).terse(h_prefixes);
			}
			else {
				return '<'+this.value+'>';
			}
		}
	},
	/* eslint-enable no-undef */
	properties: {
		...Object.entries({
			verbose: 'create verbose string (absolute IRI)',
			isolate: 'create isolated term',
			hash: 'create hash digest',
			equals: 'invoke comparison',
		}).reduce((h_out, [si_method, s_info]) => ({
			...h_out,
			[si_method]: /* syntax: js */ `
				function RelativeNamedNode$${si_method}() {
					throw new Error(\`Cannot ${s_info} out of relative IRI: <\${this.value}>\`);
				}
			`,
		}), {}),
		isRelativeNamedNode: /* syntax: js */ `true`,
		star: /* syntax: js */ `gp_self.terse`,
	},
})}

const KT_RDF_TYPE = new NamedNode('@{P_IRI_RDF}type');
KT_RDF_TYPE.isRdfTypeAlias = true;  // for serialization
const KT_RDF_SUBJECT = new NamedNode('@{P_IRI_RDF}subject');
const KT_RDF_PREDICATE = new NamedNode('@{P_IRI_RDF}predicate');
const KT_RDF_OBJECT = new NamedNode('@{P_IRI_RDF}object');
const KT_RDF_STATEMENT = new NamedNode('@{P_IRI_RDF}Statement');

const KT_RDF_LANG_STRING = new NamedNode('@{P_IRI_RDF}langString');
const G_ISOLATE_RDF_LANG_STRING = KT_RDF_LANG_STRING.isolate();

const KT_RDF_FIRST = new NamedNode('@{P_IRI_RDF}first');
const KT_RDF_REST = new NamedNode('@{P_IRI_RDF}rest');
const KT_RDF_NIL = new NamedNode('@{P_IRI_RDF}nil');

const KT_XSD_DATE = new NamedNode('@{P_IRI_XSD}date');
const KT_XSD_DATETIME = new NamedNode('@{P_IRI_XSD}dateTime');
const KT_XSD_STRING = new NamedNode('@{P_IRI_XSD}string');

@{declare(/* syntax: js */ `class GenericLiteral extends GenericTerm`, {
	/* eslint-disable no-undef */
	methods: class {
		equals(z_other) {
			return z_other
				? this === z_other
					|| ('Literal' === z_other.termType && z_other.value === this.value
						&& this.datatype.equals(z_other.datatype) && z_other.language === this.language)
				: false;
		}

		verbose() {
			return JSON.stringify(this.value)
				+ (this.language
					? '@'+this.language
					: '^^'+this.datatype.verbose());
		}

		concise(h_prefixes={}) {
			if(this.language) {
				return '@'+this.language+'"'+this.value;
			}
			else {
				return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
			}
		}

		terse(h_prefixes={}) {
			// turn into terse
			let st_datatype = this.datatype.terse(h_prefixes);

			// stringify literal
			return JSON.stringify(this.value)
				+ (this.language
					? '@'+this.language
					: '^^'+st_datatype);
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: this.language,
				datatype: this.datatype.isolate(),
			};
		}

		hash() {
			if(this.language) {
				return hash('@'+this.language+'"'+this.value);
			}
			else {
				return hash('^>'+this.datatype.value+'"'+this.value);
			}
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleObject:          /* syntax: js */ `true`,
		isLiteral:             /* syntax: js */ `true`,
		isSimpleLiteral:       /* syntax: js */ `false`,
		termType:              /* syntax: js */ `'Literal'`,
		datatype:              /* syntax: js */ `KT_XSD_STRING`,
		language:              /* syntax: js */ `''`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}

@{declare(/* syntax: js */ `class LanguagedLiteral extends GenericLiteral`, {
	constructor(s_value, s_lang) {
		this.value = s_value;

		// remove optional '@' character from beginning
		this.language = ('@' === s_lang[0]? s_lang.slice(1): s_lang).toLowerCase();
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return JSON.stringify(this.value)+'@'+this.language;
		}

		concise() {
			return '@'+this.language+'"'+this.value;
		}

		terse() {
			// stringify literal
			return JSON.stringify(this.value)+'@'+this.language;
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: this.language,
				datatype: G_ISOLATE_RDF_LANG_STRING,
			};
		}

		replace(w_pattern, w_replace) {
			return new LanguagedLiteral(this.value.replace(w_pattern, w_replace), this.language);
		}

		replaceAll(w_pattern, w_replace) {
			return new LanguagedLiteral(this.value.replaceAll(w_pattern, w_replace), this.language);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isLanguagedLiteral:    /* syntax: js */ `true`,
		datatype:              /* syntax: js */ `KT_RDF_LANG_STRING`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}


@{declare(/* syntax: js */ `class DatatypedLiteral extends GenericLiteral`, {
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return JSON.stringify(this.value)+'^^'+this.datatype.verbose();
		}

		concise(h_prefixes={}) {
			return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
		}

		terse(h_prefixes={}) {
			// turn into terse
			let st_datatype = this.datatype.terse(h_prefixes);

			// stringify literal
			return JSON.stringify(this.value)+'^^'+st_datatype;
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: this.language,
				datatype: this.datatype.isolate(),
			};
		}

		hash() {
			return hash('^>'+this.datatype.value+'"'+this.value);
		}

		replace(w_pattern, w_replace) {
			return new ExplicitlyDatatypedLiteral(this.value.replace(w_pattern, w_replace), this.datatype);
		}

		replaceAll(w_pattern, w_replace) {
			return new ExplicitlyDatatypedLiteral(this.value.replaceAll(w_pattern, w_replace), this.datatype);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isDatatypedLiteral:    /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}

@{declare(/* syntax: js */ `class ExplicitlyDatatypedLiteral extends DatatypedLiteral`, {
	constructor(s_value, kt_datatype) {
		this.value = s_value;
		this.datatype = kt_datatype;
	},
})}

@{declare(/* syntax: js */ `class RawLiteral extends GenericTerm`, {
	constructor(s_value) {
		this.value = s_value;
	},
	/* eslint-disable no-undef */
	methods: class {
		get isSimpleLiteral() {
			return !this.language && !this.datatype.equals(KT_XSD_STRING);
		}

		get isLanguagedLiteral() {
			return !!this.language;
		}

		get isDatatypedLiteral() {
			return KT_XSD_STRING.equals(this.datatype);
		}

		equals(z_other) {
			return z_other
				? this === z_other
					|| ('Literal' === z_other.termType && z_other.value === this.value
						&& this.datatype.equals(z_other.datatype) && z_other.language === this.language)
				: false;
		}

		verbose() {
			return JSON.stringify(this.value)
				+ (this.language
					? '@'+this.language
					: '^^'+this.datatype.verbose());
		}

		concise(h_prefixes={}) {
			if(this.language) {
				return '@'+this.language+'"'+this.value;
			}
			else {
				return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
			}
		}

		terse(h_prefixes={}) {
			// turn into terse
			let st_datatype = this.datatype.terse(h_prefixes);

			// stringify literal
			return JSON.stringify(this.value)
				+ (this.language
					? '@'+this.language
					: '^^'+st_datatype);
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: this.language,
				datatype: this.datatype.isolate(),
			};
		}

		hash() {
			if(this.language) {
				return hash('@'+this.language+'"'+this.value);
			}
			else {
				return hash('^>'+this.datatype.value+'"'+this.value);
			}
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isLiteral:             /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Literal'`,
		datatype:              /* syntax: js */ `KT_XSD_STRING`,
		language:              /* syntax: js */ `''`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}

@{declare(/* syntax: js */ `class SimpleLiteral extends GenericLiteral`, {
	constructor(s_value) {
		this.value = s_value;
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return JSON.stringify(this.value);
		}

		concise() {
			return '"'+this.value;
		}

		terse() {
			return JSON.stringify(this.value);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isSimpleLiteral:       /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}


@> literal(s_type, g_config)
	@.let b_boolean = 'boolean' === s_type;
	@.let s_arg = (b_boolean? 'b': 'x')+'_value';
	@.let s_type_caps = s_type.toUpperCase();
	@.let s_type_proper = s_type_caps.slice(0, 1)+s_type.slice(1);
	const KT_XSD_@{s_type_caps} = new NamedNode('@{P_IRI_XSD}@{s_type}');
	class Literal_@{s_type_proper} extends DatatypedLiteral {
		@//@class
		static from(s_literal) {
			let kt = new Literal_@{s_type_proper}(+s_literal);
			kt.value = s_literal;
			return kt;
		}

		constructor(@{s_arg}) {
			super();
			this.value = @{s_arg}+'';
			@- b_boolean
				this.boolean = @{s_arg};
			@:
				this.number = @{s_arg};
			@;
		}

		concise(h_prefixes={}) {
			return '^'+KT_XSD_@{s_type_caps}.concise(h_prefixes)+'"'+this.value;
		}

		terse() {
			@{g_config.terse}
		}

		hash() {
			return hash('^>@{P_IRI_XSD}@{s_type}"'+this.value);
		}
	} {
		const gp_self = Literal_@{s_type_proper}.prototype;
		gp_self.datatype = KT_XSD_@{s_type_caps};
		@- b_boolean
			gp_self.isBooleanLiteral = true;
		@:
			gp_self.isNumericLiteral = true;
			gp_self.is@{s_type_proper}Literal = true;
		@;
		gp_self.star = gp_self.terse;
	}
@;


@.{
	let h_literals = {
		integer: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							throw new Error('XSD integer cannot encode NaN. Try using double');
						}

						throw new Error('XSD integer cannot encode +/-infinity. Try using double');
					}
					// not an integer
					else if(!Number.isInteger(${s_arg})) {
						throw new Error('Number is not an integer: '+${s_arg});
					}

					return new Literal_Integer(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:integer');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse or not an integer
					if(Number.isNaN(x_value) || !Number.isInteger(x_value)) {
						throw new Error('Invalid integer string: '+${s_arg});
					}

					return new Literal_Integer(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:integer');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:integer');
					}

					// invalid
					throw new Error('XSD integer expects a number type or integer string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value.includes('e')
					? \`"\${this.value}"^^<${P_IRI_XSD}integer>\`
					: this.value;
			`,
		},

		double: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							return new Literal_NaN();
						}

						return ${s_arg} > 0
							? new Literal_PositiveInfinity()
							: new Literal_NegativeInfinity();
					}

					return new Literal_Double(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:double');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse
					if(Number.isNaN(x_value)) {
						throw new Error('Invalid decimal string: '+${s_arg});
					}

					return new Literal_Double(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:double');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:double');
					}

					// invalid
					throw new Error('XSD double expects a number type or double string');
				}
			`,
			terse: /* syntax: js */ `
				return this.number.toExponential();
			`,
		},

		decimal: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							throw new Error('XSD decimal cannot encode NaN. Try using double');
						}

						throw new Error('XSD decimal cannot encode +/-infinity. Try using double');
					}

					return new Literal_Decimal(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:decimal');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse
					if(Number.isNaN(x_value)) {
						throw new Error('Invalid decimal string: '+${s_arg});
					}

					return new Literal_Decimal(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:decimal');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:decimal');
					}

					// invalid
					throw new Error('XSD decimal expects a number type or decimal string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value.includes('e')
					? \`"\${this.value}"^^<${P_IRI_XSD}decimal>\`
					: this.value+(this.value.includes('.')? '': '.0');
			`,
		},

		boolean: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// boolean
				if('boolean' === s_type) {
					return new Literal_Boolean(${s_arg});
				}
				// number
				else if('number' === s_type) {
					// 1
					if(1 === ${s_arg}) {
						return new Literal_Boolean(true);
					}
					// 0
					else if(0 === ${s_arg}) {
						return new Literal_Boolean(false);
					}

					// invalid
					throw new Error(\`Boolean value '${s_arg}' must be either a '1' or '0' if using numbers\`);
				}
				// string
				else if('string' === s_type) {
					// truthy value
					if(RT_BOOLEAN_TRUE.test(${s_arg})) {
						return new Literal_Boolean(true);
					}
					// falsy value
					else if(RT_BOOLEAN_FALSE.test(${s_arg})) {
						return new Literal_Boolean(false);
					}

					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:boolean');
					}

					// failed to parse
					throw new Error('Invalid boolean string: '+${s_arg});
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:boolean');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:boolean');
					}

					// invalid
					throw new Error('XSD boolean expects a boolean type or boolean string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value+'';
			`,
		},
	};
}

@*{
	for(let s_type in h_literals) {
		yield literal(s_type, h_literals[s_type])+'\n';
	}
}


class Literal_PositiveInfinity extends Literal_Double {
	constructor() {
		super(Infinity);
		this.value = 'INF';
	}

	terse(h_prefixes={}) {
		return '"INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = Literal_PositiveInfinity.prototype;
	gp_self.isInfiniteLiteral = true;
	gp_self.star = gp_self.terse;
}

class Literal_NegativeInfinity extends Literal_Double {
	constructor() {
		super(-Infinity);
		this.value = '-INF';
	}

	terse(h_prefixes={}) {
		return '"-INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = Literal_NegativeInfinity.prototype;
	gp_self.isInfiniteLiteral = true;
	gp_self.star = gp_self.terse;
}

class Literal_NaN extends Literal_Double {
	constructor() {
		super(NaN);
		this.value = 'NaN';
	}

	terse(h_prefixes={}) {
		return '"NaN"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = Literal_NaN.prototype;
	gp_self.isNaNLiteral = true;
	gp_self.star = gp_self.terse;
}


@{declare(/* syntax: js */ `class BlankNode extends GenericTerm`, {
	constructor(s_value, b_anonymous=false) {
		this.value = s_value;
		this.isAnonymousBlankNode = b_anonymous;
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return '_:'+this.value;
		}

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleGraph:           /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		isNode:                /* syntax: js */ `true`,
		isBlankNode:           /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'BlankNode'`,
		concise:               /* syntax: js */ `gp_self.terse = gp_self.star = gp_self.verbose`,
	},
})}


@{declare(/* syntax: js */ `class EphemeralBlankNode extends BlankNode`, {
	/* eslint-disable no-undef */
	methods: class {
		get value() {
			return '_'+uuidv4();
		}

		concise() {
			return '_:#'+this.value;
		}

		terse() {
			return '[]';
		}

		verbose() {
			return '_:'+this.value;
		}

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		}

		equals() {
			return false;
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAnonymousBlankNode:  /* syntax: js */ `true`,
		isEphemeralBlankNode:  /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}


@{declare(/* syntax: js */ `class Variable extends GenericTerm`, {
	constructor(s_label) {
		this.value = s_label;
	},
	/* eslint-disable no-undef */
	methods: class {
		concise() {
			return '?'+this.value;
		}

		terse() {
			throw new Error(`Cannot call .terse() on 'Variable' term type`);
		}

		star() {
			throw new Error(`Cannot call .star() on 'Variable' term type`);
		}

		verbose() {
			throw new Error(`Cannot call .verbose() on 'Variable' term type`);
		}

		isolate() {
			return {
				termType: 'Variable',
				value: this.value,
			};
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isVariable:            /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Variable'`,
	},
})}


@{declare(/* syntax: js */ `class DefaultGraph extends GenericTerm`, {
	/* eslint-disable no-undef */
	methods: class {
		concise() {
			return '*';
		}

		verbose() {
			return '';
		}

		isolate() {
			return {
				termType: 'DefaultGraph',
				value: '',
			};
		}
	},
	/* eslint-enable no-undef */
	properties: {
		hash: /* syntax: js */ `
			function DefaultGraph$hash() {
				return '${require('crypto').createHash('sha256').update('*').digest('base64')}';
			}
		`,
		isAbleGraph:           /* syntax: js */ `true`,
		isDefaultGraph:        /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'DefaultGraph'`,
		value:                 /* syntax: js */ `''`,
		terse:                 /* syntax: js */ `gp_self.star = gp_self.verbose`,
	},
})}


const KT_DEFAULT_GRAPH = new DefaultGraph();

@{declare(/* syntax: js */ `class Quad extends GenericTerm`, {
	/* eslint-disable no-undef */
	constructor(h_subject, h_predicate, h_object, h_graph=KT_DEFAULT_GRAPH) {
		this.subject = h_subject;
		this.predicate = h_predicate;
		this.object = h_object;
		this.graph = h_graph;
	},
	methods: class {
		equals(z_other) {
			return z_other
				? this === z_other
					|| (this.object.equals(z_other.object)
						&& this.subject.equals(z_other.subject)
						&& this.predicate.equals(z_other.predicate)
						&& this.graph.equals(z_other.graph))
				: false;
		}

		valueOf() {
			return this.verbose();
		}

		gspo() {
			return [
				this.graph,
				this.subject,
				this.predicate,
				this.object,
			];
		}

		spog() {
			return [
				this.subject,
				this.predicate,
				this.object,
				this.graph,
			];
		}

		concise(h_prefixes={}) {
			return this.graph.concise(h_prefixes)
				+'\t'+this.subject.concise(h_prefixes)
				+'\r'+this.predicate.concise(h_prefixes)
				+'\n'+this.object.concise(h_prefixes);
		}

		terse(h_prefixes={}) {
			let b_default_graph = this.graph.isDefaultGraph;

			// prep output string
			let s_out = '';

			// ref subject
			let kt_subject = this.subject;

			// prep subject string
			let st1_subject = '';

			// subject is a quad; reify
			if(kt_subject.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_subject.reify();

				s_out += kq_0.terse(h_prefixes)+'\n'+kq_1.verbose(h_prefixes)+'\n'+kq_2.verbose(h_prefixes)+'\n'+kq_3.verbose(h_prefixes)+'\n';

				st1_subject = kt_reified.terse(h_prefixes);
			}
			// subejct is a term
			else {
				st1_subject = kt_subject.terse(h_prefixes);
			}

			// prep object string
			let st1_object = '';

			// ref object
			let kt_object = this.object;

			// object is a quad; reify
			if(kt_object.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_object.reify();

				s_out += kq_0.terse(h_prefixes)+'\n'+kq_1.terse(h_prefixes)+'\n'+kq_2.terse(h_prefixes)+'\n'+kq_3.terse(h_prefixes)+'\n';

				st1_object = kt_reified.terse(h_prefixes);
			}
			// object is a term
			else {
				st1_object = kt_object.terse(h_prefixes);
			}

			// serialize quad
			return (b_default_graph? '': this.graph.terse(h_prefixes)+' { ')
				+s_out+st1_subject
				+' '+this.predicate.terse(h_prefixes)
				+' '+st1_object+' .'
				+(b_default_graph? '': ' }');
		}

		verbose() {
			// prep output string
			let s_out = '';

			// ref subject
			let kt_subject = this.subject;

			// prep subject string
			let sv1_subject = '';

			// subject is a quad; reify
			if(kt_subject.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_subject.reify();

				s_out += kq_0.verbose()+'\n'+kq_1.verbose()+'\n'+kq_2.verbose()+'\n'+kq_3.verbose()+'\n';
				
				sv1_subject = kt_reified.verbose();
			}
			// subejct is a term
			else {
				sv1_subject = kt_subject.verbose();
			}

			// ref object
			let kt_object = this.object;

			// prep object string
			let sv1_object = '';

			// object is a quad; reify
			if(kt_object.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_object.reify();

				s_out += kq_0.verbose()+'\n'+kq_1.verbose()+'\n'+kq_2.verbose()+'\n'+kq_3.verbose()+'\n';

				sv1_object = kt_reified.verbose();
			}
			// object is a term
			else {
				sv1_object = kt_object.verbose();
			}

			// serialize quad
			return s_out+sv1_subject
				+' '+this.predicate.verbose()
				+' '+sv1_object
				+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.';
		}

		star(h_prefixes={}) {
			return '<< '
				+this.subject.star(h_prefixes)
				+' '+this.predicate.star(h_prefixes)
				+' '+this.object.star(h_prefixes)
				+(this.graph.isDefaultGraph? '': ' '+this.graph.star(h_prefixes))
				+' >>';
		}

		isolate() {
			return {
				termType: 'Quad',
				value: '',
				subject: this.subject.isolate(),
				predicate: this.predicate.isolate(),
				object: this.object.isolate(),
				graph: this.graph.isolate(),
			};
		}

		reify(s_label='') {
			let kt_reify = new BlankNode(s_label || '_'+uuidv4());

			// non-default graph
			if(!this.graph.isDefaultGraph) {
				console.warn(`WARNING: reify'ing quad with a non-default graph component will result in information loss ${this+''}`);
			}

			return {
				node: kt_reify,
				quads: [
					new Quad(kt_reify, KT_RDF_TYPE, KT_RDF_STATEMENT),
					new Quad(kt_reify, KT_RDF_SUBJECT, this.subject),
					new Quad(kt_reify, KT_RDF_PREDICATE, this.predicate),
					new Quad(kt_reify, KT_RDF_OBJECT, this.object),
				],
			};
		}

		replace(w_pattern, w_replace) {
			return new Quad(
				this.subject.replace(w_pattern, w_replace),
				this.predicate.replace(w_pattern, w_replace),
				this.object.replace(w_pattern, w_replace),
				this.graph.replace(w_pattern, w_replace)
			);
		}

		replaceAll(w_pattern, w_replace) {
			return new Quad(
				this.subject.replaceAll(w_pattern, w_replace),
				this.predicate.replaceAll(w_pattern, w_replace),
				this.object.replaceAll(w_pattern, w_replace),
				this.graph.replaceAll(w_pattern, w_replace)
			);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isGraphyQuad:          /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Quad'`,
		value:                 /* syntax: js */ `''`,
	},
})}


class NakedQuad extends Quad {
	terse(h_prefixes={}) {
		let b_default_graph = this.graph.isDefaultGraph;
		return (b_default_graph? '': this.graph.terse(h_prefixes)+' { ')
			+' '+this.subject.terse(h_prefixes)
			+' '+this.predicate.terse(h_prefixes)
			+' '+this.object.terse(h_prefixes)+' .'
			+(b_default_graph? '': ' }');
	}

	verbose() {
		return this.subject.verbose()
			+' '+this.predicate.verbose()
			+' '+this.object.verbose()
			+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.';
	}
}


const XC_EXTRA_A  = 0b01;
const XC_EXTRA_B  = 0b10;

const A_RELATIONS = [
	'equal',
	'superset',
	'subset',
	'overlap',
];

export function relatePrefixMaps(h_a, h_b) {
	const a_keys_a = Object.keys(h_a);
	const a_keys_b = Object.keys(h_b);

	let xc_extra_a = XC_EXTRA_A;
	let xc_extra_b = XC_EXTRA_B;
	if(a_keys_a.length < a_keys_b.length) {
		const h_swap = h_a;
		h_a = h_b;
		h_b = h_swap;
		xc_extra_a = xc_extra_b;
		xc_extra_b = xc_extra_a;
	}

	const a_conflicts = [];
	let b_overlap = false;
	let xm_relation = 0;

	// each key in 'a'
	for(const si_a in h_a) {
		// key is also in 'b'
		if(si_a in h_b) {
			// value is same in 'b'
			if(h_a[si_a] === h_b[si_a]) {
				b_overlap = true;
			}
			// value is different
			else {
				a_conflicts.push(si_a);
			}
		}
		// key is not in 'b'
		else {
			xm_relation |= xc_extra_a;
		}
	}

	// each key in 'b'
	for(const si_a in h_a) {
		// key is not in 'a'
		if(!(si_a in h_a)) {
			xm_relation |= xc_extra_b;
		}
	}

	return {
		relation: b_overlap? A_RELATIONS[xm_relation]: 'disjoint',
		conflicts: a_conflicts,
	};
}


const g_raw = {
	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},

	blankNode(s_label, b_anonymous) {
		return new BlankNode(s_label, b_anonymous);
	},

	literal(s_value) {
		return new RawLiteral(s_value);
	},

	defaultGraph() {
		return new DefaultGraph();
	},

	quad(kt_subject, kt_predicate, kt_object, kt_graph) {
		return new Quad(kt_subject, kt_predicate, kt_object, kt_graph || KT_DEFAULT_GRAPH);
	},
	@*{
		for(let s_type in h_literals) {
			let s_class = /* syntax: js */ `Literal_${s_type[0].toUpperCase()+s_type.slice(1)}`;
			yield /* syntax: js */ `
				${s_type}(w) {
					${'boolean' === s_type
						? /* syntax: js */ `return new ${s_class}(w)`
						: /* syntax: js */ `return ${s_class}.from(w);`}
				},
			`;
		}
	}
};

export {
	g_raw as raw,
};

export const g_unfiltered = {
	...g_raw,

	literal(s_value, z_datatype_or_lang) {
		if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
			return new SimpleLiteral(s_value);
		}
		else if('string' === typeof z_datatype_or_lang) {
			return new LanguagedLiteral(s_value, z_datatype_or_lang);
		}
		else if(KT_XSD_STRING.equals(z_datatype_or_lang)) {
			return new SimpleLiteral(s_value);
		}
		else {
			return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
		}
	},

	simpleLiteral(s_value) {
		return new SimpleLiteral(s_value);
	},

	languagedLiteral(s_value, s_language) {
		return new LanguagedLiteral(s_value, s_language);
	},

	datatypedLiteral(s_value, kt_datatype) {
		if(KT_XSD_STRING.equals(kt_datatype)) {
			return new SimpleLiteral(s_value);
		}
		else {
			return new ExplicitlyDatatypedLiteral(s_value, kt_datatype);
		}
	},
};

export {
	g_unfiltered as unfiltered,
};


function C3Proxy$_toString() {
	return '|'+JSON.stringify([...this()].map(w => w.concise()));
}

function c1_expand_prefixed_named_node(sc1_term, h_prefixes) {
	// deconstruct prefixed name
	let [, si_prefix, s_suffix] = R_C1N_DECONSTRUCT.exec(sc1_term);

	// return expanded form
	return '>'+h_prefixes[si_prefix]+s_suffix;
}

export const $_GRAPHY_ID = Symbol('graphy id');

export function adopt(dc_factory) {
	// already exact factory
	if($_GRAPHY_ID in dc_factory) return dc_factory;

	// prep to extend
	const dc_extend = Object.create(dc_factory);
	let b_use_extend = false;

	@*{
		const H_DATA_CONSTRUCTORS = {
			xsd: {
				boolean: /* syntax: js */ `b_value => dc_factory.literal(b_value, kt_xsd_boolean)`,
				double: /* syntax: js */ `s_value => dc_factory.double(s_value, kt_xsd_double)`,
				decimal: /* syntax: js */ `s_value => dc_factory.decimal(s_value, kt_xsd_decimal)`,
				integer: /* syntax: js */ `s_value => dc_factory.integer(s_value, kt_xsd_integer)`,
			},
			literal: {
				simpleLiteral: /* syntax: js */ `s_value => dc_factory.literal(s_value)`,
				languagedLiteral: /* syntax: js */ `(s_value, s_lang) => dc_factory.literal(s_value, s_lang)`,
				datatypedLiteral: /* syntax: js */ `(s_value, kt_datatype) => dc_factory.literal(s_value, kt_datatype)`,
			},
		};

		for(const [s_type, h_values] of Object.entries(H_DATA_CONSTRUCTORS)) {
			for(const [si_value, sj_constructor] of Object.entries(h_values)) {
				yield /* syntax: js */ `
					if('function' !== typeof dc_factory.${si_value}) {
						${'xsd' === s_type
							? /* syntax: js */ `const kt_xsd_${si_value} = dc_factory.namedNode('${P_IRI_XSD}${si_value}');`
							: ''}
						dc_extend.${si_value} = ${sj_constructor};
						b_use_extend = true;
					}
				`;
			}
		}
	}

	// extended or not
	return b_use_extend? dc_extend: dc_factory
}



export function number(x) {
	// not finite or not a number
	if('number' === typeof x && (!Number.isFinite(x) || Number.isNaN(x))) {
		return double(x);
	}
	// integer or bigint
	else if(Number.isInteger(x) || 'bigint' === typeof x) {  // eslint-disable-line valid-typeof
		return integer(x);
	}
	// non-integer
	else {
		return decimal(x);
	}
}

export function date(dt) {
	return literal(dt.toISOString().replace(/T.+$/, 'Z'), KT_XSD_DATE);
}

export function dateTime(dt) {
	return literal(dt.toISOString(), KT_XSD_DATETIME);
}

export function namedNode(pr_iri) {
	// clean iri
	pr_iri = clean_iri(pr_iri);

	// absolute iri
	if(RT_IRI_ABSOLUTE.test(pr_iri)) {
		return new NamedNode(pr_iri);
	}
	// relative iri
	else {
		return new RelativeNamedNode(pr_iri);
	}
}

export function ephemeral() {
	return new EphemeralBlankNode();
}

// @deprecated
export function anonymous() {
	return new EphemeralBlankNode();
}

export function blankNode(z_label) {
	// no label given, generate a UUID
	if(!z_label) {
		// eslint-disable-next-line no-undef
		return new BlankNode('_'+uuidv4(), true);
	}
	// label given
	else if('string' === typeof z_label) {
		return new BlankNode(z_label);
	}

	throw new TypeError(`blankNode(label) expects 'label' parameter to be falsy or a string; instead found: ${z_label}`);
}

export function literal(s_value, z_datatype_or_lang) {
	if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
		return new SimpleLiteral(s_value);
	}
	else if('string' === typeof z_datatype_or_lang) {
		return new LanguagedLiteral(s_value, z_datatype_or_lang);
	}
	else {
		return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
	}
}

@*{
	for(let s_type in h_literals) {
		let g_config = h_literals[s_type];
		yield /* syntax: js */ `export function ${s_type}(w_value) {
			${g_config.construct('w_value')}
		}\n`;
	}
}

export function defaultGraph() {
	return new DefaultGraph();
}

export function variable(s_label) {
	return new Variable(s_label);
}

// warn
export function triple(h_subject, h_predicate, h_object) {
	let e_stack = new Error('It is strongly encouraged to use .quad() instead of .triple()');
	console.warn(e_stack.stack.replace(/^(\s*)Error:/, '$1Warning:'));
	return new Quad(h_subject, h_predicate, h_object);
}

export function quad(h_subject, h_predicate, h_object, h_graph) {
	return new Quad(h_subject, h_predicate, h_object, h_graph || KT_DEFAULT_GRAPH);
}

export function term(z_term, w_prefixes) {
	// concise term
	if('string' === typeof z_term) {
		return c1(z_term, w_prefixes);
	}
	// rdfjs term
	else {
		return fromRdfjsTerm(z_term);
	}
}

/**
 * construct a namedNode from a concise term string
 * @param  {c1_string} sp1_term - a representation of the predicate to create
 * @param  {Object} h_prefixes - mappings for prefixes
 * @return {Term} - an RDFJS-compatible term object
 */
export function p1(sp1_node, h_prefixes={}) {
	// find prefix delimiter
	let i_delim = sp1_node.indexOf('_');

	// no delimter; invalid concise-term string for node
	if(-1 === i_delim) throw new Error(`A relative or prefixed node must include a ':' or '_' character. \nInvalid concise-term string for node: '${sp1_node}'`);

	// prefix id
	let s_prefix_id = sp1_node.slice(0, i_delim);

	// suffix
	let s_suffix = sp1_node.slice(i_delim+1);

	// find prefix in hash
	if(s_prefix_id in h_prefixes) {
		return g_raw.namedNode(h_prefixes[s_prefix_id]+s_suffix);
	}
	// prefix not exists
	else {
		throw new Error(`Prefix not defined: '${s_prefix_id}'`);
	}
}

/**
 * construct a term object from a concise term string
 * @param  {c1_string} sc1_term - a representation of the term object to create
 * @param  {Object} h_prefixes - mappings for prefixes
 * @return {Term} - an RDFJS-compatible term object
 */
export function c1(sc1_term, h_prefixes={}) {
	// deduce term type
	switch(sc1_term[0]) {
		// datatyped literal
		case '^': {
			// find literal's contents delimiter
			let i_contents = sc1_term.indexOf('"');

			// no delimiter
			if(-1 === i_contents) {
				throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
			}

			// extract datatype
			let s_datatype = sc1_term.slice(1, i_contents);

			// make term
			return literal(sc1_term.slice(i_contents+1), c1_node_explicit(s_datatype, h_prefixes));
		}

		// languaged literal
		case '@': {
			// find literal's contents delimiter
			let i_contents = sc1_term.indexOf('"');

			// no delimiter
			if(-1 === i_contents) {
				throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
			}

			// extract language
			let s_language = sc1_term.slice(1, i_contents);

			// make term
			return literal(sc1_term.slice(i_contents+1), s_language);
		}

		// simple literal
		case '"': {
			// make term
			return literal(sc1_term.slice(1));
		}

		// prefixed name
		default: return c1_node(sc1_term, h_prefixes);
	}
}

// construct a term object from a concise term string for nodes
export function c1_node(sc1_node, h_prefixes={}) {
	// rdf:type shortcut
	if('a' === sc1_node) return KT_RDF_TYPE;

	// default graph
	if('*' === sc1_node) return defaultGraph();

	// blank node?
	if('_' === sc1_node[0]) {
		// prefixed name
		if(':' !== sc1_node[1]) return p1(sc1_node, h_prefixes);

		// anonymous
		if(2 === sc1_node.length) return blankNode();

		// ephemeral hint
		if('#' === sc1_node[2]) return ephemeral();

		// create blank node
		return blankNode(sc1_node.slice(2));
	}

	// other
	return c1_node_explicit(sc1_node, h_prefixes);
}

// construct a named node
export function c1_named_node(sc1_node, h_prefixes={}) {
	// rdf:type shortcut
	if('a' === sc1_node) return KT_RDF_TYPE;

	// other
	return c1_node_explicit(sc1_node, h_prefixes);
}

// construct a term object from a concise term string for nodes (no shortcuts)
export function c1_node_explicit(sc1_node, h_prefixes={}) {
	// deduce term type
	switch(sc1_node[0]) {
		// iri
		case '>': return g_raw.namedNode(sc1_node.slice(1));

		// prefixed name
		case '_': {
			// blank nodes not allowed
			if(':' === sc1_node[1]) throw new Error(`BlankNode is not allowed here: ${sc1_node}`);

			// prefixed name
			return p1(sc1_node, h_prefixes);
		}

		// invalid concise-term string
		case '<': throw new Error(`Whoops! It looks like this concise-term string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.\nInvalid concise-term string '${sc1_node}'`);
		case '`': throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.\nInvalid concise-term string '${sc1_node}'`);

		// prefixed name
		default: return c1_prefixed_node(sc1_node, h_prefixes);
	}
}

// construct a term object from a concise term string for prefixed nodes
export function c1_prefixed_node(sc1_node, h_prefixes={}) {
	// find prefix delimiter
	let i_colon = sc1_node.indexOf(':');

	// no delimter; try prefixed name
	if(-1 === i_colon) return p1(sc1_node, h_prefixes);

	// prefix id
	let s_prefix_id = sc1_node.slice(0, i_colon);

	// suffix
	let s_suffix = sc1_node.slice(i_colon+1);

	// find prefix in hash
	if(s_prefix_id in h_prefixes) {
		return g_raw.namedNode(h_prefixes[s_prefix_id]+s_suffix);
	}
	// prefix not exists
	else {
		throw new Error(`Prefix not defined: '${s_prefix_id}'`);
	}
}

export function* quads(hc4_quads, h_prefixes={}) {
	for(let sc1_graph in hc4_quads) {
		yield* triples(hc4_quads[sc1_graph], h_prefixes, sc1_graph);
	}
}

export function c4(hc4_quads, h_prefixes={}) {
	return {
		[Symbol.iterator]: function *() {
			for(let sc1_graph in hc4_quads) {
				yield* triples(hc4_quads[sc1_graph], h_prefixes, sc1_graph);
			}
		},

		toString: () => JSON.stringify({
			type: 'c4',
			value: hc4_quads,
		}),
	};
}

export function* triples(hc3_triples, h_prefixes={}, sc1_graph='*') {
	let k_graph = c1(sc1_graph, h_prefixes);
	for(let sc1_subject in hc3_triples) {
		let k_subject = c1(sc1_subject, h_prefixes);
		let hc2_pairs = hc3_triples[sc1_subject];

		yield* pairs(k_graph, k_subject, hc2_pairs, h_prefixes);
	}
}

export function c3(hc3_triples, h_prefixes={}, sc1_graph='*') {
	return {
		[Symbol.iterator]: function *() {
			let k_graph = c1(sc1_graph, h_prefixes);
			for(let sc1_subject in hc3_triples) {
				let k_subject = c1(sc1_subject, h_prefixes);
				let hc2_pairs = hc3_triples[sc1_subject];

				yield* pairs(k_graph, k_subject, hc2_pairs, h_prefixes);
			}
		},

		toString: () => JSON.stringify({
			type: 'c3',
			value: hc3_triples,
		}),
	};
}

export function* pairs(k_graph, k_subject, hc2_pairs, h_prefixes={}) {
	for(let sc1_predicate in hc2_pairs) {
		let k_predicate = c1_named_node(sc1_predicate, h_prefixes);
		let z_objects = hc2_pairs[sc1_predicate];

		yield* objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes);
	}
}

export function * collection(k_graph, k_subject, a_objects, h_prefixes={}) {
	// first item
	yield* objects(k_graph, k_subject, KT_RDF_FIRST, a_objects[0], h_prefixes);

	// rest of items
	let a_rest = a_objects.slice(1);

	// no more
	if(!a_rest.length) {
		yield new Quad(k_subject, KT_RDF_REST, KT_RDF_NIL, k_graph);
	}
	// more remain
	else {
		// auto blank node
		let k_hop = blankNode();

		// incoming triple
		yield new Quad(k_subject, KT_RDF_REST, k_hop, k_graph);

		// outgoing triples
		yield* collection(k_graph, k_hop, a_rest, h_prefixes);
	}
}

export function * objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes, b_nested=false) {
	// value type
	let s_type = typeof z_objects;
	switch(s_type) {
		// c1-string
		case 'string': {
			yield new Quad(k_subject, k_predicate, c1(z_objects, h_prefixes), k_graph);
			break;
		}

		// number
		case 'number': {
			yield new Quad(k_subject, k_predicate, number(z_objects), k_graph);
			break;
		}

		// object
		case 'object': {
			// array
			if(Array.isArray(z_objects)) {
				// RDF collection
				if(b_nested) {
					// auto blank node
					let k_hop = blankNode();

					// incoming triple
					yield new Quad(k_subject, k_predicate, k_hop, k_graph);

					// outgoing triple
					yield* collection(k_graph, k_hop, z_objects, h_prefixes);
				}
				// list of objects
				else {
					for(let z_item of z_objects) {
						yield* objects(k_graph, k_subject, k_predicate, z_item, h_prefixes, true);
					}
				}
			}
			// simple object
			else {
				// auto blank node
				let k_hop = blankNode();

				// incoming triple
				yield new Quad(k_subject, k_predicate, k_hop, k_graph);

				// outgoing triples
				yield* pairs(k_graph, k_hop, z_objects, h_prefixes);
			}
			break;
		}

		// other
		default: {
			throw new Error(`invalid object type: ${typeof z_objects}`);
		}
	}
}

export function fromTerm(z_term) {
	if(z_term.isGraphyTerm) return z_term;

	return fromRdfjsTerm(z_term);
}

export function fromQuad(g_quad) {
	if(g_quad.isGraphyQuad) return g_quad;

	return fromRdfjsQuad(g_quad);
}

export function fromRdfjsTerm(g_term) {
	switch(g_term.termType) {
		case 'NamedNode': return namedNode(g_term.value);
		case 'Literal': return literal(g_term.value, g_term.language
			? g_term.language
			: (g_term.datatype
				? namedNode(g_term.datatype.value)
				: null));
		case 'DefaultGraph': return new DefaultGraph();
		case 'BlankNode': return new BlankNode(g_term.value);
		case 'Variable': return new Variable(g_term.value);
		case 'Quad': return fromRdfjsQuad(g_term);
		default: {
			throw new TypeError(`invalid termType: ${g_term.termType}`);
		}
	}
}

export function fromRdfjsQuad(g_quad) {
	return new Quad(
		fromRdfjsTerm(g_quad.subject),
		fromRdfjsTerm(g_quad.predicate),
		fromRdfjsTerm(g_quad.object),
		g_quad.graph? fromRdfjsTerm(g_quad.graph): KT_DEFAULT_GRAPH,
	);
}

export function fromSparqlResult(g_term) {
	switch(g_term.type) {
		case 'uri': {
			return new NamedNode(g_term.value);
		}

		case 'literal':
		case 'typed-literal': {
			if('xml:lang' in g_term) {
				return new LanguagedLiteral(g_term.value, g_term['xml:lang']);
			}
			else if('datatype' in g_term && '@{P_IRI_XSD}string' !== g_term.datatype) {
				return new ExplicitlyDatatypedLiteral(g_term.value, new NamedNode(g_term.datatype));
			}
			else {
				return new SimpleLiteral(g_term.value);
			}
		}

		case 'bnode': {
			return new BlankNode(g_term.value);
		}

		default: {
			throw new Error(`unexpected SPARQL Result JSON Format Term type: ${g_term.type}`);
		}
	}
}

export function c1ExpandData(sc1_term, h_prefixes) {
	switch(sc1_term[0]) {
		case '"':
		case '@':
		case '>':
		case '_':
		case '*': {
			return sc1_term;
		}

		case '^': {
			const i_contents = sc1_term.indexOf('"');
			const sc1_datatype = sc1_term.slice(1, i_contents);
			return '^'+c1_expand_prefixed_named_node(sc1_datatype)+sc1_term.slice(i_contents);
		}

		default: {
			return c1_expand_prefixed_named_node(sc1_term);
		}
	}
}

export function c1FromGraphRole() {

}

export function c1FromSubjectRole(yt_subject, h_prefixes={}) {
	return 'NamedNode' === yt_subject.termType
		? concise(yt_subject.value, h_prefixes)
		: '_:'+yt_subject.value;
}

export const toBoolean = s_boolean => Literal_Boolean.from(s_boolean);
export const toInteger = s_integer => Literal_Integer.from(s_integer);
export const toDecimal = s_decimal => Literal_Decimal.from(s_decimal);
export const toDouble = s_double => Literal_Double.from(s_double);


/**
 * @param  {Object} gc_comment - 
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write a comment to the document (only works with supporting serializers)
 */
export function comment(gc_comment={}) {
	return `\`[${uuidv4()}]${JSON.stringify({...gc_comment, type:'comment'})}`;
}

/**
 * @param  {integer} [line_count=1] - number of newlines to insert
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
 */
export function newlines() {
	// if(!Number.isInteger(n_line_count)) throw new TypeError('graphy/core.data.factory#newlines() expects `line_count` argument to be an integer');
	return `\`[${uuidv4()}]{"type":"newlines"}`;
}

/**
 * @param {string} s_key - key that identifies which aspect to configure. e.g., 'lists'
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
 */
export function config(s_key) {
	if('string' !== typeof s_key) throw new TypeError(`Expected 'key' argument to be a string, instead found ${typeof s_key}`);
	return `\`[${uuidv4()}]{"type":"config","value":${JSON.stringify(s_key)}}`;
}

export function prefixMapsDiffer(h_a, h_b) {
	// each key in 'a'
	for(const si_a in h_a) {
		// key is also in 'b'
		if(si_a in h_b) {
			// value is different in 'b'
			if(h_a[si_a] !== h_b[si_a]) {
				return true;
			}
		}
		// key is not in 'b'
		else {
			return true;
		}
	}

	// each key in 'b'
	for(const si_a in h_a) {
		// key is not in 'a'
		if(!(si_a in h_a)) {
			return true;
		}
	}
}


export const DataFactory = {

	concise,

	adopt,

	raw: g_raw,
	unfiltered: g_unfiltered,

	number,

	date,

	dateTime,

	namedNode,

	ephemeral,

	blankNode,

	literal,

	@*{
		for(let s_type in h_literals) {
			let g_config = h_literals[s_type];
			yield /* syntax: js */ `${s_type},\n`;
		}
	}

	defaultGraph,

	variable,

	// warn
	triple,

	quad,

	term,
	p1,
	c1,
	c1_node,
	c1_named_node,
	c1_node_explicit,
	c1_prefixed_node,
	c1_to_nt,

	quads,
	c4,
	triples,
	c3,
	pairs,

	collection,

	objects,

	fromTerm,

	fromQuad,

	fromRdfjsTerm,

	fromRdfjsQuad,

	fromSparqlResult,

	c1ExpandData,

	c1FromGraphRole,

	c1FromSubjectRole,

	toBoolean,
	toInteger,
	toDecimal,
	toDouble,

	comment,
	newlines,
	config,

	relatePrefixMaps,

	prefixMapsDiffer,

	uuidv4,

	cache_prefixes,
	cachePrefixes: cache_prefixes,
	terse,

	clean_iri,
	cleanIri: clean_iri,

	SI_PREFIX_CACHE,
	SI_PREFIX_BASE,
};


export default DataFactory;


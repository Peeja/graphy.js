@import '../share/iris.jmacs'
@import '../content/text.read.jmacs'

import crypto from 'crypto';
import perf_hooks from 'perf_hooks';
const {performance} = perf_hooks;

// create sha256 hash digest of an input string
const hash = s => crypto.createHash('sha256').update(s).digest('base64');

// clean IRIs by simply replacing invalid IRI characters with unicode escape sequences
const R_INVALID_IRIREF = /([\x00-\x20"<>\\^`{|}\x7f]|%(?![0-9A-F][0-9A-F]))/g;
const F_REPLACE_INVALID_IRIREF = (s_, s_v) => '\\u'+s_v.charCodeAt(0).toString(16).padStart(4, 0);
export const cleanIri = p_iri_dirty => p_iri_dirty.replace(R_INVALID_IRIREF, F_REPLACE_INVALID_IRIREF);

@>> MK_RANGE_PN_HIGH(b_extend=false)
	@// #x00B7
	@- b_extend
		@//@regex
		{-\u00b6
		\u00b8-\u00bf
	@//@
	@:
		@//@regex
		{-\u00bf
	@;

	@//@regex
	\u00d7\u00f7

	@//@
	@- !b_extend
		\u0300-\u306f
	@;

	@//@regex
	\u037e
	\u2000-\u200b

	@- b_extend
		\u200e-\u203e
		\u2041-\u206f
	@:
		\u200e-\u206f
	@;

	@//@regex
	\u2190-\u2bff
	\u2ff0-\u3000
	\ud800-\uf8ff
	\ufdd0-\ufddf
	\ufffe\uffff
@;

@>> MK_RT_AVOID_PNAME_LOCAL()
	@//@regex
	^
	(?:
		\\
		| [						@// * first character *
			\u0000-\/ 			@// 0-:
			;-@					@// A-Z
			[-^					@// _
			`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * middle characters *
				\\
				| [
					\u0000-,
					\/;-@
					[-^
					`
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
			.+					@// * at least one final character *
		)
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * final character *
				\\
				| [
					\u0000-, 	@// -
					.\/			@// 0-:
					;-@			@// A-Z
					[-^			@// _
					`			@// a-z
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
		)
	)
	$
@;

@>> MK_RT_AVOID_PNAME_NS()
	@//@regex
	^
	(?:
		[
			\u0000-@ 			@// A-Z
			[-`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			[
				\u0000-, 	@// -.
				\/			@// 0-9
				:-@			@// A-Z
				[-^			@// _
				`			@// a-z
				@{MK_RANGE_PN_HIGH(true)}
			]
			.*
		)
		| .+ \. 				@// * ends with a full stop character *
	)
	$
@;


// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_NS = /@{MK_RT_AVOID_PNAME_NS()}/;

// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_LOCAL = /@{MK_RT_AVOID_PNAME_LOCAL()}/;

// absolute iri tester
const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9+.-]*:/;

const RT_BOOLEAN_TRUE = /^(true|1)$/;
const RT_BOOLEAN_FALSE = /^(false|0)$/;

const S_UUID_V4 = 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
const R_UUID_V4 = /[xy]/g;

export const uuidv4 = () => {
	let dt_now = Date.now()+performance.now();
	return S_UUID_V4.replace(R_UUID_V4, (s) => {
		const x_r = (dt_now + (Math.random()*16)) % 16 | 0;
		dt_now = Math.floor(dt_now / 16);
		return ('x' === s? x_r: ((x_r & 0x3) | 0x8)).toString(16);
	});
};


// normalize a decimal string
const normalize_decimal = (s) => {
	// flag if negative sign used
	const b_neg = '-' === s[0];

	// replacements
	s = s.replace(/^[-+]?0*/, '')  // sign and leading zeroes
		.replace(/(\.(?:\d*[1-9])?)0+$/g, '$1')  // trailing zeroes
		.replace(/^(\.|$)/, '0$1')  // decimal-preceeding zero
		.replace(/\.$/, '');  // trailing decimal

	// re-introduce negative sign for non-zero numbers
	return b_neg && '0' !== s? '-'+s: s;
};


// keys to access special properties on a prefix mapping; these are strings instead
//   of Symbols so that keys are reproducible
export const SI_PREFIX_CACHE = '.cache';
export const SI_PREFIX_BASE = '.base';

// escape characters for compiling regexes
const R_REGEX_ESCAPE = /[$^*()+[\\{}|.?]/g;

// valid locals of prefixed names
const SR_PN_LOCAL = '(@{(PN_LOCAL(true)+'').replace(/['\\]/g, '\\$&')})$';


// create a cache on a prefix mapping
export function cachePrefixes(h_prefixes, b_terse=false) {
	// regex cache string building
	const a_cache = [];

	// inverse mappings
	const h_inverse = {};

	// each prefix/iri pair
	for(const si_prefix in h_prefixes) {
		const p_iri = h_prefixes[si_prefix];

		// prefix would make an invalid namespace; skip
		if(b_terse && RT_AVOID_PNAME_NS.test(si_prefix)) continue;

		// save inverse mapping
		h_inverse[p_iri] = si_prefix;

		// push iri
		a_cache.push(p_iri.replace(R_REGEX_ESCAPE, '\\$&'));
	}

	// prefixes exist; create cache
	if(a_cache.length) {
		// reverse sort IRIs so that longest prefix gets chosen
		a_cache.sort().reverse();

		// save cache object
		Object.defineProperty(h_prefixes, SI_PREFIX_CACHE, {
			enumerable: false,
			value: {
				_r_iris: new RegExp(`^(${a_cache.join('|')})${SR_PN_LOCAL}`, 'u'),
				_h_inverse: h_inverse,
			},
		});
	}

	// freeze object
	return Object.freeze(h_prefixes);
}

// set base IRI on a prefix mapping
export function setBaseIri(h_prefixes, p_base) {
	if(!RT_IRI_ABSOLUTE.test(p_base)) {
		throw new Error(`Base IRI must be an absolute IRI; received <${p_base}>`);
	}

	Object.defineProperty(h_prefixes, SI_PREFIX_BASE, {
		enumerable: false,
		value: p_base,
	});

	return h_prefixes;
}


@$ B_OPTIMIZE_PREFIX_COMPRESSION = false;

@- B_OPTIMIZE_PREFIX_COMPRESSION
	const R_COMPRESS = /^(.*?)([^/#]*)$/;
@;

@> curie_prefix_cache()
	// ref cache
	const g_cache = h_prefixes[SI_PREFIX_CACHE];

	// cache exists
	if(g_cache) {
		@- B_OPTIMIZE_PREFIX_COMPRESSION
			// iri compression
			const m_compress = R_COMPRESS.exec(p_iri);
			if(m_compress) {
				const p_compress = m_compress[1];
				const h_inverse = g_cache._h_inverse;
				if(p_compress in h_inverse) {
					return h_inverse[p_compress]+':'+m_compress[2];
				}
			}
		@;

		// iri matching
		const m_iri = g_cache._r_iris.exec(p_iri);

		// prefix mapped; compress
		if(m_iri) {
			return g_cache._h_inverse[m_iri[1]]+':'+m_iri[2];
		}
	}
@;

// attempt to turn an iri into a terse prefixed name
export const terse = (p_iri, h_prefixes) => {
	@{curie_prefix_cache()}
	// cache does not exist
	else {
		// best prefix id
		let si_best_prefix = '';
		let s_best_suffix = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(const si_prefix in h_prefixes) {
			const p_prefix_iri = h_prefixes[si_prefix];

			// target iri starts with prefix iri and its longer than the current best
			if(0 === p_iri.indexOf(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri
				// namespace is okay to use
				&& !RT_AVOID_PNAME_NS.test(si_prefix)
			) {
				// compute suffix
				const s_suffix = p_iri.slice(p_prefix_iri.length);

				// suffix is okay to use
				if(!RT_AVOID_PNAME_LOCAL.test(s_suffix)) {
					s_best_suffix = s_suffix;

					// save prefix id as best
					si_best_prefix = si_prefix;

					// update best iri length
					nl_best_prefix_iri = p_prefix_iri.length;
				}
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			// use terse prefixed name
			return si_best_prefix+':'+s_best_suffix;
		}
	}

	// base IRI exists 
	if(SI_PREFIX_BASE in h_prefixes) {
		// ref base IRI
		const p_base = h_prefixes[SI_PREFIX_BASE];

		// named node can be turned into relative IRI
		if(p_iri.startsWith(p_base)) {
			return '<'+p_iri.slice(p_base.length)+'>';
		}
	}

	// fallback
	return '<'+p_iri+'>';
};

// attempt to turn an iri into a concise prefixed name
export const concise = (p_iri, h_prefixes={}) => {
	@{curie_prefix_cache()}
	// cache does not exists
	else {
		// best prefix id
		let s_best_prefix_id = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(const s_prefix_id in h_prefixes) {
			const p_prefix_iri = h_prefixes[s_prefix_id];

			// target iri starts with prefix iri and its longer than the current best
			if(p_iri.startsWith(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri) {
				// save prefix id as best
				s_best_prefix_id = s_prefix_id;

				// update best iri length
				nl_best_prefix_iri = p_prefix_iri.length;
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			return s_best_prefix_id+':'+p_iri.slice(nl_best_prefix_iri);
		}
	}

	// no prefix found; default to full iri
	return '>'+p_iri;
};

const R_C1N_DECONSTRUCT = /^([^:]*):(.*)$/;
const R_C1U_DECONSTRUCT = /^([^_]*)_(.*)$/;

function c1NodeToN3(sc1_node, h_prefixes, b_verbose) {
	// match prefixed name
	let m_pname = R_C1N_DECONSTRUCT.exec(sc1_node);

	// colon used
	let b_underscore = false;

	// no colon, try underscore
	if(!m_pname) {
		m_pname = R_C1U_DECONSTRUCT.exec(sc1_node);
		b_underscore = true;
	}

	// still no match
	if(!m_pname) throw new Error(`Invalid C1 string: '${sc1_node}'`);

	// deconstruct prefixed name
	const [, si_prefix, s_suffix] = m_pname;

	// avoid illegal prefixed name parts
	if(b_verbose || b_underscore || RT_AVOID_PNAME_LOCAL.test(s_suffix) || RT_AVOID_PNAME_NS.test(si_prefix)) {
		return '<'+h_prefixes[si_prefix]+s_suffix+'>';
	}

	// good as-is
	return sc1_node;
}

export function c1ToN3(sc1_in, h_prefixes=null, b_verbose=false) {
	const b_terse = h_prefixes && !b_verbose;

	switch(sc1_in[0]) {
		// absolute iri
		case '>': {
			if(b_terse) {
				return terse(sc1_in.slice(1), h_prefixes);
			}
			else {
				return '<'+sc1_in.slice(1)+'>';
			}
		}

		// blank node?
		case '_': {
			// anonymous or ephemeral hint
			if(sc1_in.length <= 2 || '#' === sc1_in[2]) {
				return (new EphemeralBlankNode())[b_terse? 'terse': 'verbose']();
			}
			// actually prefixed named
			else if(':' !== sc1_in[1]) {
				return c1NodeToN3(sc1_in, h_prefixes, !b_terse);
			}
			// labeled
			else {
				return sc1_in;
			}
		}

		// simple literal
		case '"': return JSON.stringify(sc1_in.slice(1));

		// languaged literal
		case '@': {
			const i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+sc1_in.slice(0, i_contents);
		}

		// datatyped literal
		case '^': {
			const i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+'^^'+c1ToN3(sc1_in.slice(1, i_contents), h_prefixes, b_verbose);
		}

		// default graph
		case '*': return '';

		// directive / node explicit
		case '<':
		case '`': return c1(sc1_in).terse(h_prefixes);

		// otherwise
		default: {
			// rdf:type alis
			if('a' === sc1_in) return b_terse? 'a': '<@{P_IRI_RDF}type>';

			// all other nodes
			return c1NodeToN3(sc1_in, h_prefixes, !b_terse);
		}
	}
}

@$ R_DECLARE = /^\s*class\s*([^\s]+)\s*(?:extends\s*([^\s]+)\s*)/;

@$ declare_properties = function*(h_properties={}, sj_target='gp_self') {
	for(const [si_property, sj_value] of Object.entries(h_properties || {})) {
		yield /* syntax: js */ `
			${sj_target}.${si_property} = ${sj_value};`;
	}
};

@$ declare = function*(s_declare, g_def) {
	const [, s_class, s_extends] = R_DECLARE.exec(s_declare);

	// defer defines
	const h_defer_defines = g_def.descriptors || {};
	let sj_spread = null;
	if('@spread' in h_defer_defines) {
		sj_spread = h_defer_defines['@spread'];
		delete h_defer_defines['@spread'];
	}

	// has constructor, use function
	let b_function = false;
	if(Object.hasOwnProperty.call(g_def, 'constructor')) {
		b_function = true;

		const sj_constructor = g_def.constructor.toString().replace(/^constructor/, '');
			// : /* syntax: js */ `() {}`;
		
		yield /* syntax: js */ `function ${s_class}${sj_constructor} {
			const gp_self = ${s_class}.prototype = Object.create(${s_extends}.prototype);
			gp_self.constructor = ${s_class};
		`;

		// method definitions
		const g_methods = Object.getOwnPropertyDescriptors(g_def.methods? g_def.methods.prototype : {});
		delete g_methods.constructor;

		// methods
		for(const [si_method, g_method] of Object.entries(g_methods)) {
			if('function' === typeof g_method.value) {
				yield /* syntax: js */ `
					gp_self.${si_method} = function ${s_class}$${g_method.value.toString()};
				`;
			}
			else if('function' === typeof g_method.get) {
				h_defer_defines[si_method] = /* syntax: js */ `
					get${g_method.get.toString().replace(/^get [^\(]+/, '')},
				`;
			}
		}
	}
	// echo class
	else {
		yield /* syntax: js */ `${s_declare} ${(g_def.methods+'').replace(/^\s*class\s*/, '')} {
			const gp_self = ${s_class}.prototype;
		`;
	}

	const a_deferred = Object.keys(h_defer_defines);
	if(a_deferred.length > 1 || sj_spread) {
		yield /* syntax: js */ `Object.defineProperties(gp_self, {\n`;
		if(sj_spread) yield sj_spread;
		for(const [si_prop, sj_define] of Object.entries(h_defer_defines)) {
			yield /* syntax: js */ `${si_prop}: {${sj_define}},\n`;
		}
		yield /* syntax: js.method */ `});\n`;
	}
	else if(1 === a_deferred.length) {
		const si_prop = a_deferred[0];
		yield /* syntax: j */ `Object.defineProperty(gp_self, '${si_prop}', {${h_defer_defines[si_prop]}});\n`;
	}

	yield* declare_properties(g_def.properties)

	yield /* syntax: js.method */ `\n}`;
};

class GenericTerm {
	valueOf() {
		return this.concise();
	}

	equals(z_other) {
		return z_other
			? this === z_other
				|| (z_other.termType === this.termType && z_other.value === this.value)
			: false;
	}

	hash() {
		return hash(this.concise());
	}

	clone() {
		return new this.constructor(this.value);
	}

	replaceValue(w_search, w_replace) {
		return new this.constructor(this.value.replace(w_search, w_replace));
	}
} {
	const gp_self = GenericTerm.prototype;
	@*{yield* declare_properties({
		isGraphyTerm: /* syntax: js */ `true`,
		toString: /* syntax: js */ `gp_self.valueOf`,
		isGraphyQuad:          /* syntax: js */ `false`,
		isAbleGraph:           /* syntax: js */ `false`,
		isAbleSubject:         /* syntax: js */ `false`,
		isAblePredicate:       /* syntax: js */ `false`,
		isAbleObject:          /* syntax: js */ `false`,
		isAbleDatatype:        /* syntax: js */ `false`,
		isDefaultGraph:        /* syntax: js */ `false`,
		isNode:                /* syntax: js */ `false`,
		isNamedNode:           /* syntax: js */ `false`,
		isAbsoluteIri:         /* syntax: js */ `false`,
		isRelativeIri:         /* syntax: js */ `false`,
		isRdfTypeAlias:        /* syntax: js */ `false`,
		isBlankNode:           /* syntax: js */ `false`,
		isAnonymousBlankNode:  /* syntax: js */ `false`,
		isEphemeralBlankNode:  /* syntax: js */ `false`,
		isLiteral:             /* syntax: js */ `false`,
		isLanguagedLiteral:    /* syntax: js */ `false`,
		isDatatypedLiteral:    /* syntax: js */ `false`,
		isSimpleLiteral:       /* syntax: js */ `false`,
		isNumericLiteral:      /* syntax: js */ `false`,
		isIntegerLiteral:      /* syntax: js */ `false`,
		isDoubleLiteral:       /* syntax: js */ `false`,
		isDecimalLiteral:      /* syntax: js */ `false`,
		isBooleanLiteral:      /* syntax: js */ `false`,
		isInfiniteLiteral:     /* syntax: js */ `false`,
		isNaNLiteral:          /* syntax: js */ `false`,
		replaceText:           /* syntax: js */ `gp_self.replaceIri = gp_self.clone`,
	})}
}

@*{yield* declare(/* syntax: js */ `class NamedNode extends GenericTerm`, {
	constructor(s_iri) {
		this.value = s_iri;
	},
	/* eslint-disable no-undef */
	methods: class {
		concise(h_prefixes={}) {
			return concise(this.value, h_prefixes);
		}

		terse(h_prefixes={}) {
			return terse(this.value, h_prefixes);
		}

		verbose() {
			return '<'+this.value+'>';
		}

		isolate() {
			return {
				termType: 'NamedNode',
				value: this.value,
			};
		}

		hash() {
			return hash('>'+this.value);
		}

		replaceIri(w_search, w_replace) {
			return namedNode(this.value.replace(w_search, w_replace));
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleGraph:           /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAblePredicate:       /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		isAbleDatatype:        /* syntax: js */ `true`,
		isNode:                /* syntax: js */ `true`,
		isNamedNode:           /* syntax: js */ `true`,
		isAbsoluteIri:         /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'NamedNode'`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}

/**
 * A relative named node is a special kind of term takes on the base IRI of the prefix map given at the time it is
 */
@*{yield* declare(/* syntax: js */ `class RelativeIri extends NamedNode`, {
	/* eslint-disable no-undef */
	methods: class {
		concise(h_prefixes={}) {
			if(h_prefixes[SI_PREFIX_BASE]) {
				return (new NamedNode(h_prefixes[SI_PREFIX_BASE]+this.value)).concise(h_prefixes);
			}
			else {
				throw new Error(`Cannot create concise string out of relative IRI: '${this.value}' since prefix map argument has no base IRI`);
			}
		}

		terse(h_prefixes={}) {
			if(h_prefixes[SI_PREFIX_BASE]) {
				return (new NamedNode(h_prefixes[SI_PREFIX_BASE]+this.value)).terse(h_prefixes);
			}
			else {
				return '<'+this.value+'>';
			}
		}

		resolve(z_base) {
			if('string' === typeof z_base) {
				return new NamedNode(z_base+this.value);
			}
			else if(z_base[SI_PREFIX_BASE]) {
				return new NamedNode(z_base[SI_PREFIX_BASE]+this.value);
			}
			else {
				throw new Error(`Cannot resolve relative IRI against argument that is neither a string nor has a base IRI set within prefix map: ${z_base}`);
			}
		}
	}, /* eslint-enable no-undef */
	properties: {
		...Object.entries({
			verbose: 'create verbose string (absolute IRI)',
			hash: 'create hash digest',
		}).reduce((h_out, [si_method, s_info]) => ({
			...h_out,
			[si_method]: /* syntax: js */ `
				function RelativeIri$${si_method}() {
					throw new Error(\`Cannot ${s_info} out of relative IRI: <\${this.value}>\`);
				}
			`.trim(),
		}), {}),
		isAbsoluteIri:         /* syntax: js */ `false`,
		isRelativeIri:         /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
		replaceIri:            /* syntax: js */ `gp_self.clone`,
	},
})}

const KT_RDF_TYPE = new NamedNode('@{P_IRI_RDF}type');
KT_RDF_TYPE.isRdfTypeAlias = true;  // for serialization
const KT_RDF_SUBJECT = new NamedNode('@{P_IRI_RDF}subject');
const KT_RDF_PREDICATE = new NamedNode('@{P_IRI_RDF}predicate');
const KT_RDF_OBJECT = new NamedNode('@{P_IRI_RDF}object');
const KT_RDF_STATEMENT = new NamedNode('@{P_IRI_RDF}Statement');

const KT_RDF_LANG_STRING = new NamedNode('@{P_IRI_RDF}langString');
const G_ISOLATE_RDF_LANG_STRING = KT_RDF_LANG_STRING.isolate();

const KT_RDF_FIRST = new NamedNode('@{P_IRI_RDF}first');
const KT_RDF_REST = new NamedNode('@{P_IRI_RDF}rest');
const KT_RDF_NIL = new NamedNode('@{P_IRI_RDF}nil');

const KT_XSD_DATE = new NamedNode('@{P_IRI_XSD}date');
const KT_XSD_DATETIME = new NamedNode('@{P_IRI_XSD}dateTime');
const KT_XSD_STRING = new NamedNode('@{P_IRI_XSD}string');
const G_ISOLATE_XSD_STRING = KT_XSD_STRING.isolate();

@*{yield* declare(/* syntax: js */ `class GenericLiteral extends GenericTerm`, {
	/* eslint-disable no-undef */
	methods: class {
		equals(z_other) {
			return z_other
				? this === z_other
					|| ('Literal' === z_other.termType && z_other.value === this.value
						&& this.datatype.equals(z_other.datatype) && z_other.language === this.language)
				: false;
		}

		clone() {
			if(this.language) {
				return new LanguagedLiteral(this.value, this.language);
			}
			else if(KT_XSD_STRING.equals(this.datatype)) {
				return new SimpleLiteral(this.value);
			}
			else {
				return new ExplicitlyDatatypedLiteral(this.value, this.datatype.clone());
			}
		}

		replaceIri(w_search, w_replace) {
			// refuse to change IRI if it has a language
			if(this.language) {
				return new LanguagedLiteral(this.value, this.language);
			}
			// has changeable datatype
			else {
				const kt_datatype = this.datatype.replaceIri(w_search, w_replace);

				// simple literal
				if(KT_XSD_STRING.equals(kt_datatype)) {
					return new SimpleLiteral(this.value);
				}
				// explicitly datatyped
				else {
					return new ExplicitlyDatatypedLiteral(this.value, kt_datatype);
				}
			}
		}

		replaceText(w_search, w_replace) {
			const s_value = this.value.replace(w_search, w_replace);

			// languaged
			if(this.language) {
				return new LanguagedLiteral(s_value, this.language);
			}
			// simple literal
			else if(KT_XSD_STRING.equals(this.datatype)) {
				return new SimpleLiteral(s_value);
			}
			// datatyped
			else {
				return new ExplicitlyDatatypedLiteral(s_value, this.datatype);
			}
		}

		replaceValue(w_search, w_replace) {
			const s_value = this.value.replace(w_search, w_replace);

			// languaged
			if(this.language) {
				return new LanguagedLiteral(s_value, this.language);
			}
			// changeable datatype
			else {
				const kt_datatype = this.datatype.replaceValue(w_search, w_replace);

				// simple literal
				if(KT_XSD_STRING.equals(kt_datatype)) {
					return new SimpleLiteral(s_value);
				}
				// datatyped
				else {
					return new ExplicitlyDatatypedLiteral(s_value, kt_datatype);
				}
			}
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleObject:          /* syntax: js */ `true`,
		isLiteral:             /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Literal'`,
		datatype:              /* syntax: js */ `KT_XSD_STRING`,
		language:              /* syntax: js */ `''`,
		star:                  /* syntax: js */ `gp_self.terse`,
		boolean:               /* syntax: js */ `NaN`,
		number:                /* syntax: js */ `NaN`,
		bigint:                /* syntax: js */ `NaN`,
	},
})}

@*{yield* declare(/* syntax: js */ `class LanguagedLiteral extends GenericLiteral`, {
	constructor(s_value, s_lang) {
		this.value = s_value;

		// remove optional '@' character from beginning
		this.language = ('@' === s_lang[0]? s_lang.slice(1): s_lang).toLowerCase();
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return JSON.stringify(this.value)+'@'+this.language;
		}

		concise() {
			return '@'+this.language+'"'+this.value;
		}

		terse() {
			// stringify literal
			return JSON.stringify(this.value)+'@'+this.language;
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: this.language,
				datatype: G_ISOLATE_RDF_LANG_STRING,
			};
		}

		hash() {
			return hash('@'+this.language+'"'+this.value);
		}

		clone() {
			return new LanguagedLiteral(this.value, this.language);
		}

		replaceText(w_search, w_replace) {
			return new LanguagedLiteral(this.value.replace(w_search, w_replace), this.language);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isLanguagedLiteral:    /* syntax: js */ `true`,
		datatype:              /* syntax: js */ `KT_RDF_LANG_STRING`,
		star:                  /* syntax: js */ `gp_self.terse`,
		replaceIri:            /* syntax: js */ `gp_self.clone`,
		replaceValue:          /* syntax: js */ `gp_self.replaceText`,
	},
})}


class DatatypedLiteral extends GenericLiteral {
	verbose() {
		return JSON.stringify(this.value)+'^^'+this.datatype.verbose();
	}

	concise(h_prefixes={}) {
		return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
	}

	terse(h_prefixes={}) {
		// turn into terse
		const st_datatype = this.datatype.terse(h_prefixes);

		// stringify literal
		return JSON.stringify(this.value)+'^^'+st_datatype;
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: this.datatype.isolate(),
		};
	}

	hash() {
		return hash('^>'+this.datatype.value+'"'+this.value);
	}

	replaceIri(w_search, w_replace) {
		const kt_datatype = this.datatype.replaceIri(w_search, w_replace);

		// changed to simple literal
		if(KT_XSD_STRING.equals(kt_datatype)) {
			return new SimpleLiteral(this.value);
		}
		// still explicitly datatyped
		else {
			return new ExplicitlyDatatypedLiteral(this.value, kt_datatype);
		}
	}

	replaceText(w_search, w_replace) {
		return new ExplicitlyDatatypedLiteral(this.value.replace(w_search, w_replace), this.datatype);
	}

	replaceValue(w_search, w_replace) {
		const s_value = this.value.replace(w_search, w_replace);
		const kt_datatype = this.datatype.replaceValue(w_search, w_replace);

		// changed to simple literal
		if(KT_XSD_STRING.equals(kt_datatype)) {
			return new SimpleLiteral(s_value);
		}
		// still explicitly datatyped
		else {
			return new ExplicitlyDatatypedLiteral(s_value, kt_datatype);
		}
	}
} {
	const gp_self = DatatypedLiteral.prototype;
	@*{yield* declare_properties({
		isDatatypedLiteral:    /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
	})}
}


const RT_ANY_INTEGER = /^[-+]?[0-9]+$/;
const RT_SAFE_INTEGER = /^[-+]?[0-9]{1,15}$/;
const RT_RISKY_INTEGER = /^[-+]?[0-9]{16}$/;
const RT_DOUBLE = /^[+-]?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)(?:\.?[eE][+-]?[0-9]+)?$/;
const RT_DECIMAL = /^[+-]?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)$/;
const XG_MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
const XG_MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);

const H_VAGUE_LITERAL_DESCRIPTORS = {
	isBooleanLiteral: {
		get() {
			return KT_XSD_BOOLEAN.equals(this.datatype);
		},
	},

	isIntegerLiteral: {
		get() {
			return KT_XSD_INTEGER.equals(this.datatype);
		},
	},
	
	isDoubleLiteral: {
		get() {
			return KT_XSD_DOUBLE.equals(this.datatype);
		},
	},
	
	isDecimalLiteral: {
		get() {
			return KT_XSD_DECIMAL.equals(this.datatype);
		},
	},

	isDateLiteral: {
		get() {
			return KT_XSD_DATE.equals(this.datatype);
		},
	},

	isDateTimeLiteral: {
		get() {
			return KT_XSD_DATETIME.equals(this.datatype);
		},
	},

	boolean: {
		get() {
			if(!this.isBooleanLiteral) return NaN;
			const s_value = this.value;
			if('false' === s_value || '0' === s_value) return false;
			if('true' === s_value || '1' === s_value) return true;
			return NaN;
		},
	},

	isNumericLiteral: {
		get() {
			return this.isIntegerLiteral || this.isDoubleLiteral || this.isDecimalLiteral;
		},
	},

	isNumberPrecise: {
		get() {
			// numeric literal
			if(this.isNumericLiteral) {
				// decimal literal
				if(this.isDecimalLiteral) {
					// ref number value
					const x_value = this.number;

					// normalize decimal string
					const s_valid = normalize_decimal(this.value);

					// precision kept
					if((x_value+'') === s_valid) {
						return true;
					}

					// precision lost
					return false;
				}
				// no precision
				else if(this.isNaNLiteral || this.isInfiniteLiteral) {
					return false;
				}
				// other
				else {
					return true;
				}
			}
			// boolean
			else if(this.isBooleanLiteral) {
				return true;
			}
			// date or date time
			else if(this.isDateLiteral || this.isDateTimeLiteral) {
				return true;
			}
		},
	},

	isInfiniteLiteral: {
		get() {
			return this.isDoubleLiteral && ('INF' === this.value || '-INF' === this.value);
		},
	},

	isNaNLiteral: {
		get() {
			return this.isDoubleLiteral && ('NaN' === this.value);
		},
	},

	number: {
		get() {
			const s_value = this.value;

			// integer
			if(this.isIntegerLiteral) {
				// totally safe
				if(RT_SAFE_INTEGER.test(s_value)) return +s_value;

				// risky...
				if(RT_RISKY_INTEGER.test(s_value)) {
					const xg_value = BigInt(s_value);

					// ...but safe
					if(xg_value <= XG_MAX_SAFE_INTEGER && xg_value >= XG_MIN_SAFE_INTEGER) {
						return +s_value;
					}
				}
			}
			// double
			else if(this.isDoubleLiteral) {
				if(RT_DOUBLE.test(s_value)) return +s_value;
				if('INF' === s_value) return Infinity;
				if('-INF' === s_value) return -Infinity;
			}
			// decimal
			else if(this.isDecimalLiteral) {
				if(RT_DECIMAL.test(s_value)) return +s_value;
			}
			// boolean
			else if(this.isBooleanLiteral) {
				if('false' === s_value || '0' === s_value) return 0;
				if('true' === s_value || '1' === s_value) return 1;
			}
			// date/datetime
			else if(this.isDateLiteral || this.isDateTimeLiteral) {
				const n_timestamp = (new Date(this.value)).getTime();
				if(!Number.isNaN(n_timestamp)) {
					return n_timestamp;
				}
			}

			return NaN;
		},
	},

	bigint: {
		get() {
			const s_value = this.value;

			// integer
			if(this.isIntegerLiteral) {
				if(RT_ANY_INTEGER.test(s_value)) return BigInt(s_value);
			}
			// boolean
			else if(this.isBooleanLiteral) {
				if('false' === s_value || '0' === s_value) return BigInt(0);
				if('true' === s_value || '1' === s_value) return BigInt(1);
			}
			// date/datetime
			else if(this.isDateLiteral || this.isDateTimeLiteral) {
				const n_timestamp = (new Date(this.value)).getTime();
				if(!Number.isNaN(n_timestamp)) {
					return BigInt(n_timestamp);
				}
			}

			return NaN;
		},
	},

	date: {
		get() {
			if(this.isDateLiteral || this.isDateTimeLiteral) {
				const dt_date = new Date(this.value);
				if(!Number.isNaN(dt_date.getTime())) {
					return dt_date;
				}
			}
		},
	},
};


@*{yield* declare(/* syntax: js */ `class ExplicitlyDatatypedLiteral extends DatatypedLiteral`, {
	constructor(s_value, kt_datatype) {
		this.value = s_value;
		this.datatype = kt_datatype;
	},
	descriptors: {
		'@spread': /* syntax: js.object-literal */ `...H_VAGUE_LITERAL_DESCRIPTORS,\n`,
	},
	/* eslint-disable no-undef */
	methods: class {
		clone() {
			return new ExplicitlyDatatypedLiteral(this.value, this.datatype.clone());
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isSimpleLiteral:       /* syntax: js */ `false`,
		isLanguagedLiteral:    /* syntax: js */ `false`,
		isDatatypedLiteral:    /* syntax: js */ `true`,
	},
})}

@*{yield* declare(/* syntax: js */ `class SimpleLiteral extends GenericLiteral`, {
	constructor(s_value) {
		this.value = s_value;
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return JSON.stringify(this.value);
		}

		concise() {
			return '"'+this.value;
		}

		terse() {
			return JSON.stringify(this.value);
		}

		isolate() {
			return {
				termType: 'Literal',
				value: this.value,
				language: '',
				datatype: G_ISOLATE_XSD_STRING,
			};
		}

		hash() {
			return hash('"'+this.value);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isSimpleLiteral:       /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
	},
})}


@> literal(s_type, g_config)
	@.{
		const b_boolean = 'boolean' === s_type;
		const b_integer = 'integer' === s_type;
		const b_double = 'double' === s_type;
		const b_decimal = 'decimal' === s_type;
		let sj_arg;
		switch(s_type) {
			case 'boolean': sj_arg = 'b_value'; break;
			case 'integer': sj_arg = 'xg_value'; break;
			case 'double': sj_arg = 'x_value'; break;
			case 'decimal': sj_arg = 's_value'; break;
			default: {
				throw new Error(`unhandled literal type: '${s_type}'`);
			}
		}
		const s_type_caps = s_type.toUpperCase();
		const s_type_proper = s_type_caps.slice(0, 1)+s_type.slice(1);
	}
	const KT_XSD_@{s_type_caps} = new NamedNode('@{P_IRI_XSD}@{s_type}');
	class @{s_type_proper}Literal extends DatatypedLiteral {
		@//@class
		static fromString(s_literal) {
			@- b_decimal
				// invalid
				if(!RT_DECIMAL.test(s_literal)) {
					throw new Error('Invalid XSD decimal string: '+s_literal);
				}

				return new DecimalLiteral(s_literal);
			@:
				@- b_boolean
					// prep return value
					let kt_literal;

					// truthy value
					if(RT_BOOLEAN_TRUE.test(s_literal)) {
						kt_literal = new BooleanLiteral(true);
					}
					// falsy value
					else if(RT_BOOLEAN_FALSE.test(s_literal)) {
						kt_literal = new BooleanLiteral(false);
					}
					// failed to parse
					else {
						throw new Error('Invalid XSD boolean string: '+s_literal);
					}
				@+ b_integer
					// not a numeric integer
					if(!RT_ANY_INTEGER.test(s_literal)) {
						throw new Error('Invalid XSD integer string: '+s_literal);
					}

					// good
					const kt_literal = new IntegerLiteral(BigInt(s_literal));
				@+ b_double
					// not a numeric double
					if(!RT_DOUBLE.test(s_literal)) {
						// actually, recognized string
						if('NaN' === s_literal) return new NaNLiteral();
						if('INF' === s_literal) return new PositiveInfinityLiteral();
						if('-INF' === s_literal) return new NegativeInfinityLiteral();

						// error
						throw new Error('Invalid XSD double string: '+s_literal);
					}

					// good
					const kt_literal = new DoubleLiteral(+s_literal);
				@;

				// use exact string
				kt_literal.value = s_literal;
				return kt_literal;
			@;
		}

		static fromNumber(x_value) {
			@- b_integer
				// not a finite number
				if(!Number.isFinite(x_value)) {
					// NaN
					if(Number.isNaN(x_value)) {
						throw new Error('XSD integer cannot encode NaN. Try using double');
					}

					throw new Error('XSD integer cannot encode +/-infinity. Try using double');
				}
				// not an integer
				else if(!Number.isInteger(x_value)) {
					throw new Error('Number is not an integer: '+x_value);
				}

				return new IntegerLiteral(BigInt(x_value));
			@+ b_double
				// not a finite number
				if(!Number.isFinite(x_value)) {
					// NaN
					if(Number.isNaN(x_value)) {
						return new NaNLiteral();
					}

					return x_value > 0
						? new PositiveInfinityLiteral()
						: new NegativeInfinityLiteral();
				}

				// good
				return new DoubleLiteral(x_value);
			@+ b_decimal
				// not a finite number
				if(!Number.isFinite(x_value)) {
					// NaN
					if(Number.isNaN(x_value)) {
						throw new Error('XSD decimal cannot encode NaN. Try using double');
					}

					throw new Error('XSD decimal cannot encode +/-infinity. Try using double');
				}

				const s_value = x_value+'';
				if(RT_DOUBLE_E.test(s_value)) {
					throw new Error(`Cannot serialize number to XSD decimal without loss of precision: ${s_value}`);
				}

				return new DecimalLiteral(s_value);
			@+ b_boolean
				// 1
				if(1 === x_value) {
					return new BooleanLiteral(true);
				}
				// 0
				else if(0 === x_value) {
					return new BooleanLiteral(false);
				}

				// invalid
				throw new Error(`Boolean value '${x_value}' must be either a '1' or '0' if using numbers`);
			@;
		}

		static fromTrustedString(s_literal) {
			@- b_boolean
				// truthy value
				if('true' === s_literal) {
					return new BooleanLiteral(true);
				}
				// falsy value
				else {
					return new BooleanLiteral(false);
				}
			@+ b_decimal
				return new DecimalLiteral(s_literal);
			@:
				let kt_literal;
				@- b_integer
					kt_literal = new IntegerLiteral(BigInt(s_literal));
				@+ b_double
					// recognized string
					if('NaN' === s_literal) return new NaNLiteral();
					if('INF' === s_literal) return new PositiveInfinityLiteral();
					if('-INF' === s_literal) return new NegativeInfinityLiteral();

					kt_literal = new DoubleLiteral(+s_literal);
				@;

				kt_literal.value = s_literal;
				return kt_literal;
			@;
		}

		constructor(@{sj_arg}) {
			super();
			this.value = @{sj_arg}+'';
			@- b_boolean
				this.boolean = @{sj_arg};
			@+ b_integer
				const xg_set = @{sj_arg};

				// within safe integer range
				if(xg_set <= XG_MAX_SAFE_INTEGER && xg_set >= XG_MIN_SAFE_INTEGER) {
					this.number = Number(xg_set);
				}
				// outside safe range
				else {
					this.number = NaN;
				}

				this.bigint = @{sj_arg};
			@+ b_decimal

				// store as double
				this.number = +@{sj_arg};
			@:
				this.number = @{sj_arg};
			@;
		}

		@- b_boolean
			get number() {
				return this.boolean? 1: 0;
			}

			get bigint() {
				return this.boolean? 1n: 0n;
			}
		@;

		@- b_decimal
			get isNumberPrecise() {
				// ref number value
				const x_value = this.number;

				// normalize leading zeroes and leading decimal point
				const s_valid = normalize_decimal(this.value);

				// precision kept
				if((x_value+'') === s_valid) {
					return true;
				}

				// precision lost
				return false;
			}
		@;

		concise(h_prefixes={}) {
			return '^'+KT_XSD_@{s_type_caps}.concise(h_prefixes)+'"'+this.value;
		}

		terse() {
			@{g_config.terse}
		}

		hash() {
			return hash('^>@{P_IRI_XSD}@{s_type}"'+this.value);
		}

		clone() {
			return @{s_type_proper}Literal.fromString(this.value);
		}
	} {
		const gp_self = @{s_type_proper}Literal.prototype;
		gp_self.datatype = KT_XSD_@{s_type_caps};
		@- b_boolean
			gp_self.isBooleanLiteral = true;
		@:
			gp_self.isNumericLiteral = true;
			gp_self.is@{s_type_proper}Literal = true;
		@;
		@- !b_decimal
			gp_self.isNumberPrecise = true;
		@;
		gp_self.star = gp_self.terse;
	}
@;

const RT_DOUBLE_E = /e[-+]?\d+$/;

@.{
	const h_literals = {
		integer: {
			construct: s_arg => /* syntax: js */ `
				const s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					return IntegerLiteral.fromNumber(${s_arg});
				}
				// string
				else if('string' === s_type) {
					return IntegerLiteral.fromString(${s_arg});
				}
				// bigint
				else if('bigint' === s_type) {
					return new IntegerLiteral(${s_arg});
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as XSD integer');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as XSD integer');
					}

					// invalid
					throw new Error('XSD integer expects a number type or integer string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value;
			`,
		},

		double: {
			construct: s_arg => /* syntax: js */ `
				const s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					return DoubleLiteral.fromNumber(${s_arg});
				}
				// string
				else if('string' === s_type) {
					return DoubleLiteral.fromString(${s_arg});
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as XSD double');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as XSD double');
					}

					// invalid
					throw new Error('XSD double expects a number type or double string');
				}
			`,
			terse: /* syntax: js */ `
				return this.number.toExponential();
			`,
		},

		decimal: {
			construct: s_arg => /* syntax: js */ `
				const s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					return DecimalLiteral.fromNumber(${s_arg});
				}
				// string
				else if('string' === s_type) {
					return DecimalLiteral.fromString(${s_arg});
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as XSD decimal');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as XSD decimal');
					}

					// invalid
					throw new Error('XSD decimal expects a number type or decimal string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value+(this.value.includes('.')? '': '.0');
			`,
		},

		boolean: {
			construct: s_arg => /* syntax: js */ `
				const s_type = typeof ${s_arg};

				// boolean
				if('boolean' === s_type) {
					return new BooleanLiteral(${s_arg});
				}
				// number
				else if('number' === s_type) {
					return BooleanLiteral.fromNumber(${s_arg});
				}
				// string
				else if('string' === s_type) {
					return BooleanLiteral.fromString(${s_arg});
				}
				// bigint
				else if('bigint' === s_type) {
					// 1
					if(1n === ${s_arg}) {
						return new BooleanLiteral(true);
					}
					// 0
					else if(0n === ${s_arg}) {
						return new BooleanLiteral(false);
					}

					// invalid
					throw new Error(\`Boolean value '${s_arg}' must be either a '1n' or '0n' if using bigint\`);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:boolean');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:boolean');
					}

					// invalid
					throw new Error('XSD boolean expects a boolean type or boolean string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value+'';
			`,
		},
	};
}

@*{
	for(const s_type in h_literals) {
		yield literal(s_type, h_literals[s_type])+'\n';
	}
}


class PositiveInfinityLiteral extends DoubleLiteral {
	constructor() {
		super(Infinity);
		this.value = 'INF';
	}

	terse(h_prefixes={}) {
		return '"INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = PositiveInfinityLiteral.prototype;
	gp_self.isInfiniteLiteral = true;
	gp_self.isNumberPrecise = false;
	gp_self.star = gp_self.terse;
}

class NegativeInfinityLiteral extends DoubleLiteral {
	constructor() {
		super(-Infinity);
		this.value = '-INF';
	}

	terse(h_prefixes={}) {
		return '"-INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = NegativeInfinityLiteral.prototype;
	gp_self.isInfiniteLiteral = true;
	gp_self.isNumberPrecise = false;
	gp_self.star = gp_self.terse;
}

class NaNLiteral extends DoubleLiteral {
	constructor() {
		super(NaN);
		this.value = 'NaN';
	}

	terse(h_prefixes={}) {
		return '"NaN"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} {
	const gp_self = NaNLiteral.prototype;
	gp_self.isNaNLiteral = true;
	gp_self.isNumberPrecise = false;
	gp_self.star = gp_self.terse;
}

@*{yield* declare(/* syntax: js */ `class DateLiteral extends DatatypedLiteral`, {
	constructor(s_value, dt_date) {
		this.value = s_value;
		this.date = dt_date;
	},
	/* eslint-disable no-undef */
	methods: class {
		get number() {
			return this.date.getTime();
		}

		get bigint() {
			return BigInt(this.date.getTime());
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isDateLiteral:         /* syntax: js */ `true`,
		isNumberPrecise:       /* syntax: js */ `true`,
		datatype:              /* syntax: js */ `KT_XSD_DATE`,
	},
})}

@*{yield* declare(/* syntax: js */ `class DateTimeLiteral extends DatatypedLiteral`, {
	constructor(s_value, dt_date) {
		this.value = s_value;
		this.date = dt_date;
	},
	/* eslint-disable no-undef */
	methods: class {
		get number() {
			return this.date.getTime();
		}

		get bigint() {
			return BigInt(this.date.getTime());
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isDateTimeLiteral:     /* syntax: js */ `true`,
		isNumberPrecise:       /* syntax: js */ `true`,
		datatype:              /* syntax: js */ `KT_XSD_DATETIME`,
	},
})}


@*{yield* declare(/* syntax: js */ `class BlankNode extends GenericTerm`, {
	constructor(s_value, b_anonymous=false) {
		this.value = s_value;
		this.isAnonymousBlankNode = b_anonymous;
	},
	/* eslint-disable no-undef */
	methods: class {
		verbose() {
			return '_:'+this.value;
		}

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		}

		clone() {
			return new BlankNode(this.value, this.isAnonymousBlankNode);
		}

		replaceValue(w_search, w_replace) {
			return new BlankNode(this.value.replace(w_search, w_replace), this.isAnonymousBlankNode);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAbleGraph:           /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		isNode:                /* syntax: js */ `true`,
		isBlankNode:           /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'BlankNode'`,
		concise:               /* syntax: js */ `gp_self.terse = gp_self.star = gp_self.verbose`,
		replaceIri:            /* syntax: js */ `gp_self.replaceText = gp_self.clone`,
	},
})}


@*{yield* declare(/* syntax: js */ `class EphemeralBlankNode extends BlankNode`, {
	constructor() {},
	/* eslint-disable no-undef */
	methods: class {
		get value() {
			return '_'+uuidv4();
		}

		concise() {
			return '_:#'+this.value;
		}

		terse() {
			return '[]';
		}

		verbose() {
			return '_:'+this.value;
		}

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		}

		equals() {
			return false;
		}

		clone() {
			return new EphemeralBlankNode();
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isAnonymousBlankNode:  /* syntax: js */ `true`,
		isEphemeralBlankNode:  /* syntax: js */ `true`,
		star:                  /* syntax: js */ `gp_self.terse`,
		replaceValue:          /* syntax: js */ `gp_self.replaceIri = gp_self.replaceText = gp_self.clone`,
	},
})}


@*{yield* declare(/* syntax: js */ `class Variable extends GenericTerm`, {
	constructor(s_label) {
		this.value = s_label;
	},
	/* eslint-disable no-undef */
	methods: class {
		concise() {
			return '?'+this.value;
		}

		verbose() {
			throw new Error(`Cannot call .verbose() on 'Variable' term type`);
		}

		isolate() {
			return {
				termType: 'Variable',
				value: this.value,
			};
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isVariable:            /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Variable'`,
		terse:                 /* syntax: js */ `gp_self.star = gp_self.concise`,
	},
})}


@*{yield* declare(/* syntax: js */ `class DefaultGraph extends GenericTerm`, {
	/* eslint-disable no-undef */
	methods: class {
		concise() {
			return '*';
		}

		verbose() {
			return '';
		}

		isolate() {
			return {
				termType: 'DefaultGraph',
				value: '',
			};
		}

		clone() {
			return new DefaultGraph();
		}
	},
	/* eslint-enable no-undef */
	properties: {
		hash: /* syntax: js */ `
			function DefaultGraph$hash() {
				return '${require('crypto').createHash('sha256').update('*').digest('base64')}';
			}
		`.trim(),
		isAbleGraph:           /* syntax: js */ `true`,
		isDefaultGraph:        /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'DefaultGraph'`,
		value:                 /* syntax: js */ `''`,
		terse:                 /* syntax: js */ `gp_self.star = gp_self.verbose`,
		replaceIri:            /* syntax: js */ `gp_self.replaceText = gp_self.replaceValue = gp_self.clone`,
	},
})}


const KT_DEFAULT_GRAPH = new DefaultGraph();

@*{yield* declare(/* syntax: js */ `class Quad extends GenericTerm`, {
	/* eslint-disable no-undef */
	constructor(h_subject, h_predicate, h_object, h_graph=KT_DEFAULT_GRAPH) {
		this.subject = h_subject;
		this.predicate = h_predicate;
		this.object = h_object;
		this.graph = h_graph;
	},
	methods: class {
		equals(z_other) {
			return z_other
				? this === z_other
					|| (this.object.equals(z_other.object)
						&& this.subject.equals(z_other.subject)
						&& this.predicate.equals(z_other.predicate)
						&& this.graph.equals(z_other.graph))
				: false;
		}

		valueOf() {
			return this.verbose();
		}

		gspo() {
			return [
				this.graph,
				this.subject,
				this.predicate,
				this.object,
			];
		}

		spog() {
			return [
				this.subject,
				this.predicate,
				this.object,
				this.graph,
			];
		}

		concise(h_prefixes={}) {
			return this.graph.concise(h_prefixes)
				+'\t'+this.subject.concise(h_prefixes)
				+'\r'+this.predicate.concise(h_prefixes)
				+'\n'+this.object.concise(h_prefixes);
		}

		terse(h_prefixes={}) {
			let b_default_graph = this.graph.isDefaultGraph;

			// prep output string
			let s_out = '';

			// ref subject
			let kt_subject = this.subject;

			// prep subject string
			let st1_subject = '';

			// subject is a quad; reify
			if(kt_subject.isGraphyQuad) {
				st1_subject += `[ a ${KT_RDF_STATEMENT.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_SUBJECT.terse(h_prefixes)} ${kt_subject.subject.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_PREDICATE.terse(h_prefixes)} ${kt_subject.predicate.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_OBJECT.terse(h_prefixes)} ${kt_subject.object.terse(h_prefixes)} ;`
					+'\n\t]';
			}
			// subejct is a term
			else {
				st1_subject = kt_subject.terse(h_prefixes);
			}

			// prep object string
			let st1_object = '';

			// ref object
			let kt_object = this.object;

			// object is a quad; reify
			if(kt_object.isGraphyQuad) {
				st1_object += `[ a ${KT_RDF_STATEMENT.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_SUBJECT.terse(h_prefixes)} ${kt_object.subject.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_PREDICATE.terse(h_prefixes)} ${kt_object.predicate.terse(h_prefixes)} ;`
					+`\n\t${KT_RDF_OBJECT.terse(h_prefixes)} ${kt_object.object.terse(h_prefixes)} ;`
					+'\n\t]';
			}
			// object is a term
			else {
				st1_object = kt_object.terse(h_prefixes);
			}

			// serialize quad
			return (b_default_graph? '': this.graph.terse(h_prefixes)+' { ')
				+s_out+st1_subject
				+' '+this.predicate.terse(h_prefixes)
				+' '+st1_object+' .'
				+(b_default_graph? '': ' }');
		}

		verbose() {
			// prep output string
			let s_out = '';

			// ref subject
			let kt_subject = this.subject;

			// prep subject string
			let sv1_subject = '';

			// subject is a quad; reify
			if(kt_subject.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_subject.reify();

				s_out += kq_0.verbose()+'\n'+kq_1.verbose()+'\n'+kq_2.verbose()+'\n'+kq_3.verbose()+'\n';
				
				sv1_subject = kt_reified.verbose();
			}
			// subejct is a term
			else {
				sv1_subject = kt_subject.verbose();
			}

			// ref object
			let kt_object = this.object;

			// prep object string
			let sv1_object = '';

			// object is a quad; reify
			if(kt_object.isGraphyQuad) {
				const {
					node: kt_reified,
					quads: [kq_0, kq_1, kq_2, kq_3],
				} = kt_object.reify();

				s_out += kq_0.verbose()+'\n'+kq_1.verbose()+'\n'+kq_2.verbose()+'\n'+kq_3.verbose()+'\n';

				sv1_object = kt_reified.verbose();
			}
			// object is a term
			else {
				sv1_object = kt_object.verbose();
			}

			// serialize quad
			return s_out+sv1_subject
				+' '+this.predicate.verbose()
				+' '+sv1_object
				+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.';
		}

		star(h_prefixes={}) {
			return '<< '
				+this.subject.star(h_prefixes)
				+' '+this.predicate.star(h_prefixes)
				+' '+this.object.star(h_prefixes)
				+(this.graph.isDefaultGraph? '': ' '+this.graph.star(h_prefixes))
				+' >>';
		}

		isolate() {
			return {
				termType: 'Quad',
				value: '',
				subject: this.subject.isolate(),
				predicate: this.predicate.isolate(),
				object: this.object.isolate(),
				graph: this.graph.isolate(),
			};
		}

		reify(s_label='') {
			let kt_reify = new BlankNode(s_label || '_'+uuidv4());

			// non-default graph
			if(!this.graph.isDefaultGraph) {
				console.warn(`WARNING: reify'ing quad with a non-default graph component will result in information loss ${this+''}`);
			}

			return {
				node: kt_reify,
				quads: [
					new Quad(kt_reify, KT_RDF_TYPE, KT_RDF_STATEMENT),
					new Quad(kt_reify, KT_RDF_SUBJECT, this.subject),
					new Quad(kt_reify, KT_RDF_PREDICATE, this.predicate),
					new Quad(kt_reify, KT_RDF_OBJECT, this.object),
				],
			};
		}

		clone() {
			return new Quad(
				this.subject.clone(),
				this.predicate.clone(),
				this.object.clone(),
				this.graph.clone()
			);
		}

		replaceIri(w_search, w_replace) {
			return new Quad(
				this.subject.replaceIri(w_search, w_replace),
				this.predicate.replaceIri(w_search, w_replace),
				this.object.replaceIri(w_search, w_replace),
				this.graph.replaceIri(w_search, w_replace)
			);
		}

		replaceText(w_search, w_replace) {
			return new Quad(
				this.subject,
				this.predicate,
				this.object.replaceText(w_search, w_replace),
				this.graph
			);
		}

		replaceValue(w_search, w_replace) {
			return new Quad(
				this.subject.replaceValue(w_search, w_replace),
				this.predicate.replaceValue(w_search, w_replace),
				this.object.replaceValue(w_search, w_replace),
				this.graph.replaceValue(w_search, w_replace)
			);
		}
	},
	/* eslint-enable no-undef */
	properties: {
		isGraphyQuad:          /* syntax: js */ `true`,
		isAbleSubject:         /* syntax: js */ `true`,
		isAbleObject:          /* syntax: js */ `true`,
		termType:              /* syntax: js */ `'Quad'`,
		value:                 /* syntax: js */ `''`,
	},
})}


const XC_EXTRA_A  = 0b01;
const XC_EXTRA_B  = 0b10;

const A_RELATIONS = [
	'equal',
	'superset',
	'subset',
	'overlap',
];

export function relatePrefixMaps(h_a, h_b) {
	const a_keys_a = Object.keys(h_a);
	const a_keys_b = Object.keys(h_b);

	let xc_extra_a = XC_EXTRA_A;
	let xc_extra_b = XC_EXTRA_B;
	if(a_keys_a.length < a_keys_b.length) {
		const h_swap = h_a;
		h_a = h_b;
		h_b = h_swap;
		xc_extra_a = xc_extra_b;
		xc_extra_b = xc_extra_a;
	}

	const a_conflicts = [];
	let b_overlap = false;
	let xm_relation = 0;

	// each key in 'a'
	for(const si_a in h_a) {
		// key is also in 'b'
		if(si_a in h_b) {
			// value is same in 'b'
			if(h_a[si_a] === h_b[si_a]) {
				b_overlap = true;
			}
			// value is different
			else {
				a_conflicts.push(si_a);
			}
		}
		// key is not in 'b'
		else {
			xm_relation |= xc_extra_a;
		}
	}

	// each key in 'b'
	for(const si_a in h_b) {
		// key is not in 'a'
		if(!(si_a in h_a)) {
			xm_relation |= xc_extra_b;
		}
	}

	let s_relation = 'disjoint';
	if(b_overlap) {
		if(!xm_relation) {
			s_relation = a_conflicts.length? 'overlap': 'equal';
		}
		else {
			s_relation = A_RELATIONS[xm_relation];
		}
	}
	else if(!xm_relation) {
		s_relation = 'equal';
	}

	return {
		relation: s_relation,
		conflicts: a_conflicts,
	};
}


export function prefixMapsDiffer(h_a, h_b) {
	// each key in 'a'
	for(const si_a in h_a) {
		// key is also in 'b'
		if(si_a in h_b) {
			// value is different in 'b'
			if(h_a[si_a] !== h_b[si_a]) {
				return true;
			}
		}
		// key is not in 'b'
		else {
			return true;
		}
	}

	// each key in 'b'
	for(const si_a in h_b) {
		// key is not in 'a'
		if(!(si_a in h_a)) {
			return true;
		}
	}

	return false;
}


const g_raw = {
	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},

	blankNode(s_label, b_anonymous) {
		return new BlankNode(s_label, b_anonymous);
	},

	defaultGraph() {
		return new DefaultGraph();
	},

	quad(kt_subject, kt_predicate, kt_object, kt_graph) {
		return new Quad(kt_subject, kt_predicate, kt_object, kt_graph || KT_DEFAULT_GRAPH);
	},
};

@*{
	for(let s_type in h_literals) {
		const s_class = /* syntax: js */ `${s_type[0].toUpperCase()+s_type.slice(1)}Literal`;
		yield /* syntax: js */ `
			g_raw.${s_type}Literal = ${s_class}.fromTrustedString;
		`;
		//  {
		// 		${'boolean' === s_type || 'integer' === s_type
		// 			? /* syntax: js */ `return new ${s_class}(w)`
		// 			: /* syntax: js */ `return ${s_class}.fromTrustedString(w);`}
		// 	},
		// `;
	}
}

export {
	g_raw as raw,
};

export const g_unfiltered = {
	isGraphyDataFactoryCertified: true,

	...g_raw,

	literal(s_value, z_datatype_or_lang) {
		if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
			return new SimpleLiteral(s_value);
		}
		else if('string' === typeof z_datatype_or_lang) {
			return new LanguagedLiteral(s_value, z_datatype_or_lang);
		}
		else {
			return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
		}
	},

	simpleLiteral(s_value) {
		return new SimpleLiteral(s_value);
	},

	languagedLiteral(s_value, s_language) {
		return new LanguagedLiteral(s_value, s_language);
	},

	datatypedLiteral(s_value, kt_datatype) {
		if(KT_XSD_STRING.equals(kt_datatype)) {
			return new SimpleLiteral(s_value);
		}
		else {
			return new ExplicitlyDatatypedLiteral(s_value, kt_datatype);
		}
	},
};

export {
	g_unfiltered as unfiltered,
};


function C3Proxy$_toString() {
	return '|'+JSON.stringify([...this()].map(w => w.concise()));
}


export function adopt(dc_factory) {
	// already exact factory
	if(dc_factory.isGraphyDataFactoryCertified) return dc_factory;

	// prep to extend
	const dc_extend = Object.create(dc_factory);
	dc_extend.isGraphyDataFactoryCertified = true;

	@*{
		const H_DATA_CONSTRUCTORS = {
			xsd: {
				boolean: /* syntax: js */ `w => dc_factory.literal(w+'', kt_xsd_boolean)`,
				double: /* syntax: js */ `w => dc_factory.literal(w+'', kt_xsd_double)`,
				decimal: /* syntax: js */ `w => dc_factory.literal(w+'', kt_xsd_decimal)`,
				integer: /* syntax: js */ `w => dc_factory.literal(w+'', kt_xsd_integer)`,
			},
			literal: {
				simple: /* syntax: js */ `s_value => dc_factory.literal(s_value)`,
				languaged: /* syntax: js */ `(s_value, s_lang) => dc_factory.literal(s_value, s_lang)`,
				datatyped: /* syntax: js */ `(s_value, kt_datatype) => dc_factory.literal(s_value, kt_datatype)`,
			},
		};

		for(const [s_type, h_values] of Object.entries(H_DATA_CONSTRUCTORS)) {
			for(const [si_value, sj_constructor] of Object.entries(h_values)) {
				yield /* syntax: js */ `
					if('function' !== typeof dc_factory.${si_value}Literal) {
						${'xsd' === s_type
							? /* syntax: js */ `const kt_xsd_${si_value} = dc_factory.namedNode('${P_IRI_XSD}${si_value}');`
							: ''}
						dc_extend.${si_value}Literal = ${sj_constructor};
					}
				`;
			}
		}
	}

	// extended or not
	return dc_extend;
}



export function numberLiteral(z) {
	const s_type = typeof z;

	// number
	if('number' === s_type) {
		// integer
		if(Number.isInteger(z)) {
			return new IntegerLiteral(BigInt(z));
		}
		// double
		else {
			return doubleLiteral(z);
		}
	}
	// bigint
	else if('bigint' === s_type) {
		return new IntegerLiteral(z);
	}
	// string
	else if('string' === s_type) {
		// try integer
		try {
			return IntegerLiteral.fromString(z);
		}
		catch(e_bigint) {}

		// use decimal
		return DecimalLiteral.fromString(z);
	}
	// bad
	else {
		throw new TypeError(`Invalid argument type to number(): ${z}`);
	}
}

const RT_DATE = /^([0-9]{4})-([0-1][0-9])-[0-3][0-9]Z?$/;
export function dateLiteral(z_date=new Date()) {
	let s_date = '';
	let dt_date;

	if('string' === typeof z_date) {
		if(!RT_DATE.exec(z_date)) {
			throw new Error(`Invalid date string: ${z_date}`);
		}

		s_date = z_date;
		dt_date = new Date(z_date);
		if(Number.isNaN(dt_date.getTime())) {
			throw new Error(`Impossible date: ${s_date}`);
		}
	}
	else if(z_date instanceof Date) {
		dt_date = z_date;
		if(Number.isNaN(z_date.getTime())) {
			throw new TypeError(`Invalid date argument: ${z_date}`);
		}
		s_date = z_date.toISOString().replace(/T.+$/, 'Z');
	}
	else {
		throw new TypeError(`Invalid date argument: ${z_date}`);
	}

	return new DateLiteral(s_date, dt_date);
}

const RT_DATETIME = /^([0-9]{4})-([0-1][0-9])-([0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](Z)?)$/;
export function dateTimeLiteral(z_date=new Date()) {
	let s_date = '';
	let dt_date;

	if('string' === typeof z_date) {
		if(!RT_DATETIME.exec(z_date)) {
			throw new Error(`Invalid dateTime string: ${z_date}`);
		}

		s_date = z_date;
		dt_date = new Date(z_date);
		if(Number.isNaN(dt_date.getTime())) {
			throw new Error(`Impossible dateTime: ${s_date}`);
		}
	}
	else if(z_date instanceof Date) {
		dt_date = z_date;
		if(Number.isNaN(dt_date.getTime())) {
			throw new TypeError(`Invalid dateTime argument: ${z_date}`);
		}
		s_date = z_date.toISOString();
	}
	else {
		throw new TypeError(`Invalid dateTime argument: ${z_date}`);
	}

	return new DateTimeLiteral(s_date, dt_date);
}

export function namedNode(pr_iri) {
	// clean iri
	pr_iri = cleanIri(pr_iri);

	// absolute iri
	if(RT_IRI_ABSOLUTE.test(pr_iri)) {
		return new NamedNode(pr_iri);
	}
	// relative iri
	else {
		return new RelativeIri(pr_iri);
	}
}

export function ephemeralBlankNode() {
	return new EphemeralBlankNode();
}

// @deprecated
export function anonymousBlankNode() {
	return new EphemeralBlankNode();
}

export function blankNode(z_label) {
	// no label given, generate a UUID
	if(!z_label) {
		// eslint-disable-next-line no-undef
		return new BlankNode('_'+uuidv4(), true);
	}
	// label given
	else if('string' === typeof z_label) {
		return new BlankNode(z_label);
	}

	throw new TypeError(`blankNode(label) expects 'label' parameter to be falsy or a string; instead found: ${z_label}`);
}

export function literal(s_value, z_datatype_or_lang) {
	if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
		return new SimpleLiteral(s_value);
	}
	else if('string' === typeof z_datatype_or_lang) {
		return new LanguagedLiteral(s_value, z_datatype_or_lang);
	}
	else {
		return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
	}
}

@*{
	for(const s_type in h_literals) {
		const g_config = h_literals[s_type];
		yield /* syntax: js */ `export function ${s_type}Literal(w_value) {
			${g_config.construct('w_value')}
		}\n`;
	}
}

export function defaultGraph() {
	return new DefaultGraph();
}

export function variable(s_label) {
	return new Variable(s_label);
}

// warn
export function triple(h_subject, h_predicate, h_object) {
	const e_stack = new Error('It is strongly encouraged to use .quad() instead of .triple()');
	console.warn(e_stack.stack.replace(/^(\s*)Error:/, '$1Warning:'));
	return new Quad(h_subject, h_predicate, h_object);
}

export function quad(h_subject, h_predicate, h_object, h_graph) {
	return new Quad(h_subject, h_predicate, h_object, h_graph || KT_DEFAULT_GRAPH);
}

export function term(z_term, w_prefixes) {
	// concise term
	if('string' === typeof z_term) {
		return c1(z_term, w_prefixes);
	}
	// rdfjs term
	else {
		return fromRdfjsTerm(z_term);
	}
}

/**
 * construct a namedNode from a concise term string
 * @param  {c1_string} sp1_term - a representation of the predicate to create
 * @param  {Object} h_prefixes - mappings for prefixes
 * @return {Term} - an RDFJS-compatible term object
 */
export function p1(sp1_node, h_prefixes={}) {
	// find prefix delimiter
	const i_delim = sp1_node.indexOf('_');

	// no delimter; invalid concise-term string for node
	if(-1 === i_delim) throw new Error(`A relative or prefixed node must include a ':' or '_' character. \nInvalid concise-term string for node: '${sp1_node}'`);

	// prefix id
	const s_prefix_id = sp1_node.slice(0, i_delim);

	// suffix
	const s_suffix = sp1_node.slice(i_delim+1);

	// find prefix in hash
	if(s_prefix_id in h_prefixes) {
		return g_raw.namedNode(h_prefixes[s_prefix_id]+s_suffix);
	}
	// prefix not exists
	else {
		throw new Error(`Prefix not defined: '${s_prefix_id}'`);
	}
}

/**
 * construct a term object from a concise term string
 * @param  {c1_string} sc1_term - a representation of the term object to create
 * @param  {Object} h_prefixes - mappings for prefixes
 * @return {Term} - an RDFJS-compatible term object
 */
export function c1(sc1_term, h_prefixes={}) {
	// deduce term type
	switch(sc1_term[0]) {
		// datatyped literal
		case '^': {
			// find literal's contents delimiter
			const i_contents = sc1_term.indexOf('"');

			// no delimiter
			if(-1 === i_contents) {
				throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
			}

			// extract datatype
			const s_datatype = sc1_term.slice(1, i_contents);

			// make term
			return literal(sc1_term.slice(i_contents+1), c1NodeExplicit(s_datatype, h_prefixes));
		}

		// languaged literal
		case '@': {
			// find literal's contents delimiter
			const i_contents = sc1_term.indexOf('"');

			// no delimiter
			if(-1 === i_contents) {
				throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
			}

			// extract language
			const s_language = sc1_term.slice(1, i_contents);

			// make term
			return literal(sc1_term.slice(i_contents+1), s_language);
		}

		// simple literal
		case '"': {
			// make term
			return literal(sc1_term.slice(1));
		}

		// variable
		case '?': {
			return variable(sc1_term.slice(1));
		}

		// prefixed name
		default: return c1Node(sc1_term, h_prefixes);
	}
}

// construct a term object from a concise term string for nodes
export function c1Node(sc1_node, h_prefixes={}) {
	// rdf:type shortcut
	if('a' === sc1_node) return KT_RDF_TYPE;

	// default graph
	if('*' === sc1_node) return defaultGraph();

	// blank node?
	if('_' === sc1_node[0]) {
		// prefixed name
		if(':' !== sc1_node[1]) return p1(sc1_node, h_prefixes);

		// anonymous
		if(2 === sc1_node.length) return blankNode();

		// ephemeral hint
		if('#' === sc1_node[2]) return ephemeralBlankNode();

		// create blank node
		return blankNode(sc1_node.slice(2));
	}

	// other
	return c1NodeExplicit(sc1_node, h_prefixes);
}

// construct a named node
export function c1NamedNode(sc1_node, h_prefixes={}) {
	// rdf:type shortcut
	if('a' === sc1_node) return KT_RDF_TYPE;

	// other
	return c1NodeExplicit(sc1_node, h_prefixes);
}

// construct a term object from a concise term string for nodes (no shortcuts)
export function c1NodeExplicit(sc1_node, h_prefixes={}) {
	// deduce term type
	switch(sc1_node[0]) {
		// iri
		case '>': return g_raw.namedNode(sc1_node.slice(1));

		// prefixed name
		case '_': {
			// blank nodes not allowed
			if(':' === sc1_node[1]) throw new Error(`BlankNode is not allowed here: ${sc1_node}`);

			// prefixed name
			return p1(sc1_node, h_prefixes);
		}

		// invalid concise-term string
		case '<': throw new Error(`Whoops! It looks like this C1 string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.\nInvalid C1 string '${sc1_node}'`);
		case '`': throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.\nInvalid C1 string '${sc1_node}'`);

		// prefixed name
		default: return c1PrefixedNode(sc1_node, h_prefixes);
	}
}

// looks like an absolute IRI
const RT_IRI_ABSOLUTE_LOOK = /^[A-Za-z][A-Za-z0-9+.-]*:\/\//;

// construct a term object from a concise term string for prefixed nodes
export function c1PrefixedNode(sc1_node, h_prefixes={}) {
	// find prefix delimiter
	const i_colon = sc1_node.indexOf(':');

	// no delimter; try prefixed name
	if(-1 === i_colon) return p1(sc1_node, h_prefixes);

	// prefix id
	const s_prefix_id = sc1_node.slice(0, i_colon);

	// suffix
	const s_suffix = sc1_node.slice(i_colon+1);

	// find prefix in hash
	if(s_prefix_id in h_prefixes) {
		return g_raw.namedNode(h_prefixes[s_prefix_id]+s_suffix);
	}
	// prefix not exists
	else {
		// looks like an absolute IRI
		if(RT_IRI_ABSOLUTE_LOOK.test(sc1_node)) {
			throw new Error(`It looks like this C1 string is an absolute IRI, did you forget to prepend the '>' character\nInvalid C1 string '${sc1_node}'`);
		}

		// probably not an IRI
		throw new Error(`Prefix not defined: '${s_prefix_id}'`);
	}
}

export function c4(hc4_quads, h_prefixes={}) {
	return {
		[Symbol.iterator]: function *() {
			for(const sc1_graph in hc4_quads) {
				yield* triples(hc4_quads[sc1_graph], h_prefixes, sc1_graph);
			}
		},

		toString: () => JSON.stringify({
			type: 'c4',
			value: hc4_quads,
		}),
	};
}

function* triples(hc3_triples, h_prefixes={}, sc1_graph='*') {
	const k_graph = c1(sc1_graph, h_prefixes);
	for(const sc1_subject in hc3_triples) {
		const k_subject = c1(sc1_subject, h_prefixes);
		const hc2_pairs = hc3_triples[sc1_subject];

		yield* pairs(k_graph, k_subject, hc2_pairs, h_prefixes);
	}
}

export function c3(hc3_triples, h_prefixes={}, sc1_graph='*') {
	return {
		[Symbol.iterator]: function *() {
			const k_graph = c1(sc1_graph, h_prefixes);
			for(const sc1_subject in hc3_triples) {
				const k_subject = c1(sc1_subject, h_prefixes);
				const hc2_pairs = hc3_triples[sc1_subject];

				yield* pairs(k_graph, k_subject, hc2_pairs, h_prefixes);
			}
		},

		toString: () => JSON.stringify({
			type: 'c3',
			value: hc3_triples,
		}),
	};
}

function* pairs(k_graph, k_subject, hc2_pairs, h_prefixes={}) {
	for(const sc1_predicate in hc2_pairs) {
		const k_predicate = c1NamedNode(sc1_predicate, h_prefixes);
		const z_objects = hc2_pairs[sc1_predicate];

		yield* objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes);
	}
}

function* collection(k_graph, k_subject, a_objects, h_prefixes={}) {
	// first item
	yield* objects(k_graph, k_subject, KT_RDF_FIRST, a_objects[0], h_prefixes);

	// rest of items
	const a_rest = a_objects.slice(1);

	// no more
	if(!a_rest.length) {
		yield new Quad(k_subject, KT_RDF_REST, KT_RDF_NIL, k_graph);
	}
	// more remain
	else {
		// auto blank node
		const k_hop = blankNode();

		// incoming triple
		yield new Quad(k_subject, KT_RDF_REST, k_hop, k_graph);

		// outgoing triples
		yield* collection(k_graph, k_hop, a_rest, h_prefixes);
	}
}

function* objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes, b_nested=false) {
	// value type
	const s_type = typeof z_objects;
	switch(s_type) {
		// c1-string
		case 'string': {
			yield new Quad(k_subject, k_predicate, c1(z_objects, h_prefixes), k_graph);
			break;
		}

		// number
		case 'number': {
			yield new Quad(k_subject, k_predicate, numberLiteral(z_objects), k_graph);
			break;
		}

		// object
		case 'object': {
			// array
			if(Array.isArray(z_objects)) {
				// RDF collection
				if(b_nested) {
					// auto blank node
					const k_hop = blankNode();

					// incoming triple
					yield new Quad(k_subject, k_predicate, k_hop, k_graph);

					// outgoing triple
					yield* collection(k_graph, k_hop, z_objects, h_prefixes);
				}
				// list of objects
				else {
					for(const z_item of z_objects) {
						yield* objects(k_graph, k_subject, k_predicate, z_item, h_prefixes, true);
					}
				}
			}
			// simple object
			else {
				// auto blank node
				const k_hop = blankNode();

				// incoming triple
				yield new Quad(k_subject, k_predicate, k_hop, k_graph);

				// outgoing triples
				yield* pairs(k_graph, k_hop, z_objects, h_prefixes);
			}
			break;
		}

		// other
		default: {
			throw new Error(`Invalid object type: ${typeof z_objects}`);
		}
	}
}

export function fromTerm(z_term) {
	if(z_term.isGraphyTerm) return z_term;

	return fromRdfjsTerm(z_term);
}

export function fromQuad(g_quad) {
	if(g_quad.isGraphyQuad) return g_quad;

	return fromRdfjsQuad(g_quad);
}

export function fromRdfjsTerm(g_term) {
	switch(g_term.termType) {
		case 'NamedNode': return namedNode(g_term.value);
		case 'Literal': return literal(g_term.value, g_term.language
			? g_term.language
			: (g_term.datatype?.value && '@{P_IRI_XSD}string' !== g_term.datatype.value
				? namedNode(g_term.datatype.value)
				: null));
		case 'DefaultGraph': return new DefaultGraph();
		case 'BlankNode': return new BlankNode(g_term.value);
		case 'Variable': return new Variable(g_term.value);
		case 'Quad': return fromRdfjsQuad(g_term);
		default: {
			throw new TypeError(`invalid termType: ${g_term.termType}`);
		}
	}
}

export function fromRdfjsQuad(g_quad) {
	return new Quad(
		fromRdfjsTerm(g_quad.subject),
		fromRdfjsTerm(g_quad.predicate),
		fromRdfjsTerm(g_quad.object),
		g_quad.graph? fromRdfjsTerm(g_quad.graph): KT_DEFAULT_GRAPH,
	);
}

export function fromSparqlResult(g_term) {
	switch(g_term.type) {
		case 'uri': {
			return new NamedNode(g_term.value);
		}

		case 'literal':
		case 'typed-literal': {
			if('xml:lang' in g_term) {
				return new LanguagedLiteral(g_term.value, g_term['xml:lang']);
			}
			else if('datatype' in g_term && '@{P_IRI_XSD}string' !== g_term.datatype) {
				return new ExplicitlyDatatypedLiteral(g_term.value, new NamedNode(g_term.datatype));
			}
			else {
				return new SimpleLiteral(g_term.value);
			}
		}

		case 'bnode': {
			return new BlankNode(g_term.value);
		}

		default: {
			throw new Error(`unexpected SPARQL Result JSON Format Term type: ${g_term.type}`);
		}
	}
}

function c1ExpandPrefixedNamedNode(sc1_term, h_prefixes) {
	// deconstruct prefixed name
	let m_pname = R_C1N_DECONSTRUCT.exec(sc1_term);

	// no colon, try underscore
	if(!m_pname) m_pname = R_C1U_DECONSTRUCT.exec(sc1_term);

	// still no match
	if(!m_pname) throw new Error(`Invalid C1 string: '${sc1_term}'`);

	// deconstruct
	const [, si_prefix, s_suffix] = m_pname;

	// return expanded form
	return '>'+h_prefixes[si_prefix]+s_suffix;
}

export function c1ExpandData(sc1_term, h_prefixes) {
	switch(sc1_term[0]) {
		case '"':
		case '@':
		case '>':
		case '*': {
			return sc1_term;
		}

		case '_': {
			if(':' === sc1_term[1]) return sc1_term;
			return c1ExpandPrefixedNamedNode(sc1_term, h_prefixes);
		}

		case '^': {
			const i_contents = sc1_term.indexOf('"');
			const sc1_datatype = sc1_term.slice(1, i_contents);

			// already expanded
			if('>' === sc1_datatype[0]) return sc1_term;

			// expand prefixed named node
			return '^'+c1ExpandPrefixedNamedNode(sc1_datatype, h_prefixes)+sc1_term.slice(i_contents);
		}

		default: {
			return c1ExpandPrefixedNamedNode(sc1_term, h_prefixes);
		}
	}
}

export function c1FromGraphRole(yt_graph, h_prefixes={}) {
	switch(yt_graph.termType) {
		case 'NamedNode': return concise(yt_graph.value, h_prefixes);
		case 'DefaultGraph': return '*';
		case 'BlankNode': return '_:'+yt_graph.value;
		default: throw new Error(`Invalid termType for graph role term: '${yt_graph.termType}'`);
	}
}

export function c1FromSubjectRole(yt_subject, h_prefixes={}) {
	switch(yt_subject.termType) {
		case 'NamedNode': return concise(yt_subject.value, h_prefixes);
		case 'BlankNode': return '_:'+yt_subject.value;
		default: throw new Error(`Invalid termType for subject role term: '${yt_subject.termType}'`);
	}
}

function c1FromNamedNode(yt_node, h_prefixes={}) {
	if('NamedNode' !== yt_node.termType) {
		throw new Error(`Invalid termType for role, expected NamedNode but found: '${yt_node.termType}'`);
	}
	return concise(yt_node.value, h_prefixes);
}

export const c1FromPredicateRole = c1FromNamedNode;
export const c1FromDatatypeRole = c1FromNamedNode;

export function c1FromObjectRole(yt_object, h_prefixes={}) {
	switch(yt_object.termType) {
		case 'NamedNode': return concise(yt_object.value, h_prefixes);
		case 'BlankNode': return '_:'+yt_object.value;
		case 'Literal': {
			if(yt_object.language) {
				return '@'+yt_object.language+'"'+yt_object.value;
			}
			else if('@{P_IRI_XSD}string' !== yt_object.datatype.value) {
				return '^'+concise(yt_object.datatype.value, h_prefixes)+'"'+yt_object.value;
			}
			else {
				return '"'+yt_object.value;
			}
		}
		default: throw new Error(`Invalid termType for graph role term: '${yt_object.termType}'`);
	}
}

/**
 * @param  {Object} gc_comment - 
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write a comment to the document (only works with supporting serializers)
 */
export function comment(gc_comment={}) {
	return `\`[${uuidv4()}]${JSON.stringify({...gc_comment, type:'comment'})}`;
}

/**
 * @param  {integer} [n_lines=1] - number of newlines to insert
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
 */
export function newlines() {
	return `\`[${uuidv4()}]{"type":"newlines"}`;
}

/**
 * @param {string} s_key - key that identifies which aspect to configure. e.g., 'lists'
 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
 */
export function config(s_key) {
	if('string' !== typeof s_key) throw new TypeError(`Expected 'key' argument to be a string, instead found ${typeof s_key}`);
	return `\`[${uuidv4()}]{"type":"config","value":${JSON.stringify(s_key)}}`;
}

export const DataFactory = {
	SI_PREFIX_CACHE,
	SI_PREFIX_BASE,
	cachePrefixes,
	setBaseIri,

	uuidv4,
	cleanIri,

	terse,
	concise,

	adopt,
	raw: g_raw,
	unfiltered: g_unfiltered,

	defaultGraph,
	namedNode,
	blankNode,
	ephemeralBlankNode,
	literal,
	numberLiteral,
	@*{
		for(const s_type in h_literals) {
			const g_config = h_literals[s_type];
			yield /* syntax: js */ `${s_type}Literal,\n`;
		}
	}
	dateLiteral,
	dateTimeLiteral,
	variable,

	// warn
	triple,
	quad,

	term,
	p1,
	c1,
	c1ToN3,
	c1Node,
	c1NamedNode,
	c1NodeExplicit,
	c1PrefixedNode,

	c4,
	c3,

	collection,

	objects,

	fromTerm,
	fromQuad,
	fromRdfjsTerm,
	fromRdfjsQuad,
	fromSparqlResult,

	c1ExpandData,
	c1FromGraphRole,
	c1FromSubjectRole,
	c1FromPredicateRole,
	c1FromObjectRole,
	c1FromDatatypeRole,

	comment,
	newlines,
	config,

	relatePrefixMaps,
	prefixMapsDiffer,

	isGraphyDataFactory: true,
	isGraphyDataFactoryCertified: true,
	graphyVersion: '@{require('../../package.json').version}',
};


export default DataFactory;


@import '../share/iris.jmacs'

/* eslint-disable no-use-before-define */
import {
	DataFactory,
} from '@@graphy/core';

import type {
	RDFJS,
	Role,
	VRole,
	VStarRole,
	Term,
	C1,
	Dataset,
	PrefixMap,
} from '@@graphy/types';

import {
	$_KEYS,
	$_QUADS,
	$_OVERLAY,
	$_BURIED,
	IBasicQuadTree,
	GenericQuadTree,
} from './common';

import ProbsHash = IBasicQuadTree.ProbsHash;
import TriplesHash = IBasicQuadTree.TriplesHash;
import QuadsHash = IBasicQuadTree.QuadsHash;

import overlayTree = GenericQuadTree.overlayTree;
import overlay = GenericQuadTree.overlay;
import trace = GenericQuadTree.trace;

import {
	createHash,
} from 'crypto';

const hash = (s: string) => createHash('sha256').update(s).digest('hex');


const {
	concise,
	fromTerm,
	graphFromC1,
	subjectFromC1,
	predicateFromC1,
	objectFromC1,
	c1FromGraphRole,
	c1FromSubjectRole,
	c1FromPredicateRole,
	c1FromObjectRole,
	c1CompactData,
	c1ExpandData,
	prefixMapsDiffer,
} = DataFactory;

export interface Deliverable {
	new(...args: any[]): Dataset.SyncC1Dataset<BasicQuadTree>;
}

export interface BasicQuadTreeConstructor extends Deliverable {
	new(...args: any[]): BasicQuadTree;
}


export interface InternalGraphHandle extends IBasicQuadTree.GraphHandle {
	_sc1_graph: C1.Graph;
	_hc3_trips: TriplesHash;
}

export interface InternalGrubHandle extends GrubHandle {
	_kh_graph: InternalGraphHandle;
	_sc1_subject: C1.Subject;
	_hc2_probs: ProbsHash;
}

export interface InternalGraspHandle extends GraspHandle {
	_as_objects: InternalObjectSet;
}

export type InternalObjectSet = Set<C1.Object>;


export type Tree = QuadsHash | TriplesHash | ProbsHash;

export type AccumulatorHash = Record<string, any>;

export interface CrawlProbsHash {
	[sc1_object: string]: CrawlTriplesHash | ((as_objs: Set<C1.Object>) => AccumulatorHash | null | undefined);
}

export interface CrawlTriplesHash {
	[sc1_predicate: string]: CrawlProbsHash | ((hc2_probs: ProbsHash) => AccumulatorHash | null | undefined);
}

export interface CrawlQuadsHash {
	[sc1_subject: string]: CrawlTriplesHash | ((hc3_trips: TriplesHash) => AccumulatorHash | null | undefined);
}


// export const overlayTree = <HashType extends QuadsHash | TriplesHash | ProbsHash>(n_keys=0, n_quads=0) => ({
// 	[$_KEYS]: n_keys,
// 	[$_QUADS]: n_quads,
// 	// [$_OVERLAY]: 0,
// 	// [$_SUPPORTING]: [],
// }) as HashType;

// export const overlay = (hcw_src: any): Tree => {
// 	// create new tree
// 	const hcw_dst = Object.create(hcw_src);

// 	// src is now buried
// 	hcw_src[$_BURIED] = 1;

// 	// dst is an overlay
// 	hcw_dst[$_OVERLAY] = 1;

// 	return hcw_dst;
// };

// export const trace = (hcw_overlay: any): Tree => {
// 	// create dst tree
// 	const hcw_dst = {} as Tree;

// 	// check each key
// 	for(let sv1_key in hcw_overlay) {
// 		hcw_dst[sv1_key] = hcw_overlay[sv1_key];
// 	}

// 	// copy key count and quad count
// 	hcw_dst[$_KEYS] = hcw_overlay[$_KEYS];
// 	hcw_dst[$_QUADS] = hcw_overlay[$_QUADS];

// 	return hcw_dst;
// };



/**
 * @fileoverview
 * The following table indicates the names for various groupings of RDF term roles:
 * 
 *  ┌─────────┬───────────┬─────────────┬──────────┐
 *  │ <graph> ┊ <subject> ┊ <predicate> ┊ <object> │
 *  ├─────────┴───────────┼─────────────┴──────────┤
 *  │        grub         │           prob         │
 *  ├─────────────────────┴─────────────┬──────────┤
 *  │               grasp               │░░░░░░░░░░│
 *  ├─────────┬─────────────────────────┴──────────┤
 *  │░░░░░░░░░│         spred           │░░░░░░░░░░│
 *  ├─────────┼─────────────────────────┴──────────┤
 *  │░░░░░░░░░│               triple               │
 *  ├─────────┴────────────────────────────────────┤
 *  │                      quad                    │
 *  └──────────────────────────────────────────────┘
 * 
 */


class GraspHandle implements InternalGraspHandle {
	_k_builder: BasicQuadTreeBuilder;
	_kh_grub: GrubHandle;
	_sc1_predicate: C1.Predicate;
	_sc1_subject: C1.Subject;
	_as_objects: Set<C1.Object>; 

	constructor(kh_grub: GrubHandle, sc1_predicate: C1.Predicate, as_objects: Set<C1.Object>) {
		this._k_builder = kh_grub._k_builder;
		this._kh_grub = kh_grub;
		this._sc1_subject = kh_grub._sc1_subject;
		this._sc1_predicate = sc1_predicate;
		this._as_objects = as_objects;
	}

	addC1Object(sc1_object: C1.Object): boolean {
		// ref object store
		const as_objects = this._as_objects;

		// triple already exists
		if(as_objects.has(sc1_object)) return false;

		// insert into object set
		as_objects.add(sc1_object);

		// ref quads tree
		const hc4_quads = this._k_builder._hc4_quads;

		// update quads counter on quads tree
		hc4_quads[$_QUADS] += 1;

		// ref triples tree
		const hc3_trips = hc4_quads[this._kh_grub._kh_graph._sc1_graph];

		// update quads counter on triples tree
		hc3_trips[$_QUADS] += 1;

		// update quads counter on probs tree
		hc3_trips[this._sc1_subject][$_QUADS] += 1;

		// new triple added
		return true;
	}

	deleteC1Object(sc1_object: C1.Object): boolean {
		throw new Error(`BasicQuadTreeBuilder does not allow for deletion`);
	}
}


class GrubHandle implements InternalGrubHandle {
	_k_builder: BasicQuadTreeBuilder;
	_kh_graph: InternalGraphHandle;
	_sc1_subject: C1.Subject;
	_hc2_probs: ProbsHash;

	constructor(k_dataset: BasicQuadTreeBuilder, kh_graph: InternalGraphHandle, sc1_subject: C1.Subject, hc2_probs: ProbsHash) {
		this._k_builder = k_dataset;
		this._kh_graph = kh_graph;
		this._sc1_subject = sc1_subject;
		this._hc2_probs = hc2_probs;
	}

	openC1Predicate(sc1_predicate: C1.Predicate): Dataset.GraspHandle {
		// increment keys counter
		const hc2_probs = this._hc2_probs;

		// predicate exists; return tuple handle
		if(sc1_predicate in hc2_probs) {
			return new GraspHandle(this, sc1_predicate, hc2_probs[sc1_predicate]);
		}
		else {
			// increment keys counter
			hc2_probs[$_KEYS] += 1;

			// create predicate w/ empty objects set
			const as_objects = hc2_probs[sc1_predicate] = new Set();

			// return tuple handle
			return new GraspHandle(this, sc1_predicate, as_objects);
		}
	}
}

class StandaloneGraphHandle implements InternalGraphHandle {
	_k_builder: BasicQuadTreeBuilder;
	_sc1_graph: C1.Graph;
	_hc3_trips: TriplesHash;
	 
	constructor(k_dataset: BasicQuadTreeBuilder, sc1_graph: C1.Graph, hc3_trips: TriplesHash) {
		this._k_builder = k_dataset;
		this._sc1_graph = sc1_graph;
		this._hc3_trips = hc3_trips;
	}

	openC1Subject(sc1_subject: C1.Subject): Dataset.GrubHandle {
		// ref triples tree
		const hc3_trips = this._hc3_trips;

		// subject exists; return subject handle
		if(sc1_subject in hc3_trips) {
			return new GrubHandle(this._k_builder, this, sc1_subject, hc3_trips[sc1_subject]);
		}
		else {
			// increment keys counter
			hc3_trips[$_KEYS] += 1;

			// create subject w/ empty probs tree
			const hc2_probs = hc3_trips[sc1_subject] = overlayTree<ProbsHash>();

			// return subject handle
			return new GrubHandle(this._k_builder, this, sc1_subject, hc2_probs);
		}
	}
}

function graph_to_c1(yt_graph: Role.Graph, h_prefixes: PrefixMap): C1.Graph {
	// depending on graph term type
	switch(yt_graph.termType) {
		// default graph
		case 'DefaultGraph': {
			return '*';
		}

		// named node
		case 'NamedNode': {
			return concise(yt_graph.value, h_prefixes);
		}

		// blank node
		case 'BlankNode': {
			return <C1.BlankNode>('#'+yt_graph.value);
		}

		// other
		default: {
			throw new Error(`Cannot convert term type '${(yt_graph as Role.Graph).termType}' to C1.Graph string`);
		}
	}
}

function dataset_already_delivered(): never {
	throw new Error(`Cannot use builder after dataset has been delivered`);;
}

/**
 * Trig-Optimized, Semi-Indexed Dataset in Memory
 * YES: ????, g???, g??o, g?po, gs??, gsp?, gspo
 * SOME: gs?o
 * NOT: ???o, ??p?, ??po, ?s??, ?s?o, ?sp?, ?spo, g?p?
 */
export class BasicQuadTreeBuilder implements Dataset.GraphHandle, Dataset.SyncQuadTreeBuilder<Dataset.SyncC1Dataset<BasicQuadTree>> {
	_sc1_graph: C1.Graph = '*';
	_hc3_trips: TriplesHash;
	_hc4_quads: QuadsHash;

	static supportsStar = false;

	constructor(kd_init=BasicQuadTree.empty()) {
		this._hc4_quads = kd_init._hc4_quads as QuadsHash;
		this._hc3_trips = kd_init._hc3_trips as TriplesHash;
	}

	openC1Graph(sc1_graph: C1.Graph): Dataset.GraphHandle {
		// ref quads tree
		const hc4_quads = this._hc4_quads;

		// graph exists; return subject handle
		if(sc1_graph in hc4_quads) {
			return new StandaloneGraphHandle(this, sc1_graph, hc4_quads[sc1_graph]);
		}
		else {
			// increment keys counter
			hc4_quads[$_KEYS] += 1;

			// create graph w/ empty triples tree
			const hc3_trips = hc4_quads[sc1_graph] = overlayTree<TriplesHash>();

			// return subject handle
			return new StandaloneGraphHandle(this, sc1_graph, hc3_trips);
		}
	}

	openC1Subject(sc1_subject: C1.Node): Dataset.GrubHandle {
		// ref default graph triples tree
		const hc3_trips = this._hc3_trips;

		// subject exists; return subject handle
		if(sc1_subject in hc3_trips) {
			return new GrubHandle(this, this, sc1_subject, hc3_trips[sc1_subject]);
		}
		// subject not yet exists
		else {
			// increment keys counter
			hc3_trips[$_KEYS] += 1;

			// create subject w/ empty probs tree
			const hc2_probs = hc3_trips[sc1_subject] = overlayTree<ProbsHash>();

			// return subject handle
			return new GrubHandle(this, this, sc1_subject, hc2_probs);
		}
	}

	deliver(gc_dataset: Dataset.Config={}, dc_dataset: BasicQuadTreeConstructor=(BasicQuadTree as BasicQuadTreeConstructor)): BasicQuadTree {  // eslint-disable-line require-await
		// simplify garbage collection and prevent future modifications to dataset
		const hc4_quads = this._hc4_quads;
		this._hc4_quads = null as unknown as QuadsHash;
		this._hc3_trips = null as unknown as TriplesHash;
		this.openC1Subject = dataset_already_delivered;
		this.openC1Graph = dataset_already_delivered;


		// create dataset
		return new dc_dataset(hc4_quads, gc_dataset || {});
	}
}

@import './algo/normalizer.ts.jmacs';
@import './algo/union-same.ts.jmacs';


// type StaticSelf = Function & {
// 	builder: {new(): Dataset.QuadTreeBuilder};
// 	empty(h_prefixes: PrefixMap): BasicQuadTree;
// 	new(hc4_quads: QuadsHash, h_prefixes: PrefixMap): BasicQuadTree;
// };

// export interface QuadTree extends Dataset.SyncC1Dataset {

// 	expand(): QuadTree;
// }

// interface Constructor extends GenericQuadTree.Constructor<QuadTree, QuadTreeBuilder, GenericQuadTree.QuadsHash> {}

function empty_quads_hash(): QuadsHash {
	return {
		[$_KEYS]: 1,
		[$_QUADS]: 0,
		// [$_OVERLAY]: 0,
		// [$_BURIED]: [],
		['*']: {
			[$_KEYS]: 0,
			[$_QUADS]: 0,
			// [$_OVERLAY]: 0,
			// [$_BURIED]: [],
		},
	};
}


// export const BasicQuadTree: Constructor = class BasicQuadTree implements QuadTree {
export class BasicQuadTree extends GenericQuadTree<
	BasicQuadTree, IBasicQuadTree.QuadsHash, IBasicQuadTree.TriplesHash
> implements Dataset.SyncC1Dataset<BasicQuadTree> {
	/**
	 * Create new LinkedQuadTreeBuilder
	 */
	static builder(): BasicQuadTreeBuilder {
		return new BasicQuadTreeBuilder();
	}

	/**
	 * Create new empty dataset
	 */
	static empty(gc_dataset: Dataset.Config={}): BasicQuadTree {
		return new BasicQuadTree(empty_quads_hash(), gc_dataset || {});
	}

	/**
	 * Internal self builder for creating match results or appending
	 * @internal
	 */
	_k_builder: BasicQuadTreeBuilder;

	_f_normalize: <C1Type extends C1.Data>(sc1_term: C1Type, h_prefixes: PrefixMap) => C1Type;

	private _sc1_rdf_first: C1.NamedNode;
	private _sc1_rdf_rest: C1.NamedNode;
	private _sc1_rdf_nil: C1.NamedNode;

	/**
	 * Create new dataset
	 */
	constructor(hc4_quads=null as QuadsHash, gc_dataset: Dataset.Config={}) {
		super(hc4_quads || empty_quads_hash(), gc_dataset);
		this._k_builder = new BasicQuadTreeBuilder(this);

		// set normalizer
		const f_normalize = this._f_normalize = this._b_prefixed? c1CompactData: c1ExpandData;

		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// static c1 terms
		this._sc1_rdf_first = f_normalize<C1.NamedNode>('>@{P_IRI_RDF}first', h_prefixes);
		this._sc1_rdf_rest = f_normalize<C1.NamedNode>('>@{P_IRI_RDF}rest', h_prefixes);
		this._sc1_rdf_nil = f_normalize<C1.NamedNode>('>@{P_IRI_RDF}nil', h_prefixes);
	}


	/**
	 * For iterating through the dataset one quad at a time
	 */
	* [Symbol.iterator](): Generator<Term.Quad> {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref quads tree
		const hc4_quads = this._hc4_quads;

		// each graph
		for(const sc1_graph in hc4_quads) {
			// make graph node
			const kt_graph = graphFromC1(sc1_graph as C1.Graph, h_prefixes);

			// ref triples tree
			const hc3_trips = hc4_quads[sc1_graph];

			// each subject
			for(const sc1_subject in hc3_trips) {
				// make subject node
				const kt_subject = subjectFromC1(sc1_subject as C1.Subject, h_prefixes);

				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject] as ProbsHash;

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// make predicate node
					const kt_predicate = predicateFromC1(sc1_predicate as C1.Predicate, h_prefixes);

					// ref objects
					const as_objects = hc2_probs[sc1_predicate];

					// each object
					for(const sc1_object of as_objects) {
						// make object node
						const kt_object = objectFromC1(sc1_object, h_prefixes);

						// yield quad
						yield DataFactory.quad(kt_subject, kt_predicate, kt_object, kt_graph);
					}
				}
			}
		}
	}

	protected _all_distinct_predicates(): Set<C1.Predicate> {
		// ref quads tree
		const hc4_quads = this._hc4_quads;

		// count distinct predicates using set
		const as_predicates = new Set<C1.Predicate>();

		// each graph
		for(const sc1_graph in hc4_quads) {
			// ref triples tree
			const hc3_trips = hc4_quads[sc1_graph];

			// each subject
			for(const sc1_subject in hc3_trips) {
				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// each predicate; add to set
				for(const sc1_predicate in hc2_probs) {
					as_predicates.add(sc1_predicate as C1.Predicate);
				}
			}
		}

		// return set
		return as_predicates;
	}

	protected _all_distinct_objects(): Set<C1.Object> {
		// ref quads tree
		const hc4_quads = this._hc4_quads;

		// distinct objects set
		const as_objects = new Set<C1.Object>();

		// each graph
		for(const sc1_graph in hc4_quads) {
			// ref triples tree
			const hc3_trips = hc4_quads[sc1_graph];

			// each subject
			for(const sc1_subject in hc3_trips) {
				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject] as ProbsHash;

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// ref objects set
					const as_add = hc2_probs[sc1_predicate];

					// each object; add it to set
					for(const sc1_object of as_add) {
						as_objects.add(sc1_object);
					}
				}
			}
		}

		// return set
		return as_objects;
	}

	distinctPredicateCount(): number {
		// only default graph
		if(1 === this._hc4_quads[$_KEYS]) {
			const as_predicates = new Set();
			for(const sc1_predicate in this._hc3_trips) {
				as_predicates.add(sc1_predicate);
			}
			return as_predicates.size;
		}
		// multiple graphs
		else {
			return this._all_distinct_predicates().size;
		}
	}

	distinctObjectCount(): number {
		return this._all_distinct_objects().size;
	}


	distinctC1Predicates(): Set<C1.Predicate> {
		return this._all_distinct_predicates();
	}

	distinctC1Objects(): Set<C1.Object> {
		return this._all_distinct_objects();
	}


	* distinctPredicates(): Generator<Term.Predicate> {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// each predicate
		for(const sc1_predicate of this._all_distinct_predicates()) {
			yield predicateFromC1(sc1_predicate, h_prefixes);
		}
	}

	* distinctObjects(): Generator<Term.Object> {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// each object
		for(const sc1_object of this._all_distinct_objects()) {
			yield objectFromC1(sc1_object, h_prefixes);
		}
	}


	attachPrefixes(h_prefixes: PrefixMap) {
		this._h_prefixes = h_prefixes;
	}

	addC1Quad(sc1_subject: C1.Subject, sc1_predicate: C1.Predicate, sc1_object: C1.Object, sc1_graph?:  C1.Graph): boolean {
		const kh_handle: Dataset.GraphHandle = sc1_graph
			? this._k_builder.openC1Graph(sc1_graph)
			: this._k_builder as BasicQuadTreeBuilder;

		// use builder to efficiently add quad
		return kh_handle.openC1Subject(sc1_subject).openC1Predicate(sc1_predicate).addC1Object(sc1_object);
	}

	add(g_quad: RDFJS.Quad): this {
		const h_prefixes = this._h_prefixes;

		// use builder to efficiently add quad
		this._k_builder.openC1Graph(c1FromGraphRole(g_quad.graph, h_prefixes))
			.openC1Subject(c1FromSubjectRole(g_quad.subject, h_prefixes))
			.openC1Predicate(c1FromPredicateRole(g_quad.predicate, h_prefixes))
			.addC1Object(c1FromObjectRole(g_quad.object, h_prefixes));

		return this;
	}

	has(g_quad: RDFJS.Quad): boolean {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// fetch triples tree
		const hc3_trips = this._hc4_quads[c1FromGraphRole(g_quad.graph, h_prefixes)];

		// none
		if(!hc3_trips) return false;

		// create subject c1
		const sc1_subject = c1FromSubjectRole(g_quad.subject, h_prefixes);

		// fetch probs tree
		const hc2_probs = hc3_trips[concise(sc1_subject, h_prefixes)] as ProbsHash;

		// none
		if(!hc2_probs) return false;

		// fetch objects list
		const as_objects = hc2_probs[c1FromPredicateRole(g_quad.predicate, h_prefixes)];

		// none
		if(!as_objects) return false;

		// create object c1
		const sc1_object = c1FromObjectRole(g_quad.object, h_prefixes);

		// use native set .has()
		return as_objects.has(sc1_object);
	}

	delete(g_quad: RDFJS.Quad): this {
		const h_prefixes = this._h_prefixes;

		this._k_builder.openC1Graph(c1FromGraphRole(g_quad.graph, h_prefixes))
			.openC1Subject(c1FromSubjectRole(g_quad.subject, h_prefixes))
			.openC1Predicate(c1FromPredicateRole(g_quad.predicate, h_prefixes))
			.deleteC1Object(c1FromObjectRole(g_quad.object, h_prefixes));

		return this;
	}


	deleteMatches(yt_subject?: VStarRole.Subject, yt_predicate?: VStarRole.Predicate, yt_object?: VStarRole.Object, yt_graph?: VStarRole.Graph): this {
		const h_prefixes = this._h_prefixes;

		if(yt_subject && 'Quad' === yt_subject.termType) throw new Error('Quads not supported');
		if(yt_object && 'Quad' === yt_object.termType) throw new Error('Quads not supported');

		const sc1_subject = yt_subject && 'Variable' !== yt_subject.termType? c1FromSubjectRole(yt_subject, h_prefixes): null;
		const sc1_predicate = yt_predicate && 'Variable' !== yt_predicate.termType? c1FromPredicateRole(yt_predicate, h_prefixes): null;
		const sc1_object = yt_object && 'Variable' !== yt_object.termType? c1FromObjectRole(yt_object, h_prefixes): null;
		const sc1_graph = yt_graph && 'Variable' !== yt_graph.termType? c1FromGraphRole(yt_graph, h_prefixes): null;

		this._delete_matches_c1(sc1_subject, sc1_predicate, sc1_object, sc1_graph);

		return this;
	}

	deleteMatchesC1(sc1_subject?: null | C1.Subject, sc1_predicate?: null | C1.Predicate, sc1_object?: null | C1.Object, sc1_graph?: null | C1.Graph): this {
		const h_prefixes = this._h_prefixes;

		if(this._b_prefixed) {
			if(sc1_subject) sc1_subject = c1CompactData<C1.Subject>(sc1_subject, h_prefixes);
			if(sc1_predicate) sc1_predicate = c1CompactData<C1.Predicate>(sc1_predicate, h_prefixes);
			if(sc1_object) sc1_object = c1CompactData<C1.Object>(sc1_object, h_prefixes);
			if(sc1_graph) sc1_graph = c1CompactData<C1.Graph>(sc1_graph, h_prefixes);
		}
		else {
			if(sc1_subject) sc1_subject = c1ExpandData<C1.Subject>(sc1_subject, h_prefixes);
			if(sc1_predicate) sc1_predicate = c1ExpandData<C1.Predicate>(sc1_predicate, h_prefixes);
			if(sc1_object) sc1_object = c1ExpandData<C1.Object>(sc1_object, h_prefixes);
			if(sc1_graph) sc1_graph = c1ExpandData<C1.Graph>(sc1_graph, h_prefixes);
		}

		this._delete_matches_c1(
			sc1_subject || null,
			sc1_predicate || null,
			sc1_object || null,
			sc1_graph || null,
		);
		return this;
	}

	_delete_matches_c1(sc1_subject?: null | C1.Subject, sc1_predicate?: null | C1.Predicate, sc1_object?: null | C1.Object, sc1_graph?: null | C1.Graph): number {
		const hc4_quads = this._hc4_quads;

		// count number of quads deleted
		let c_deleted = 0;

		// graph specified
		if(sc1_graph) {
			// ref trips
			const hc3_trips = hc4_quads[sc1_graph];

			// graph does not exist
			if(!hc3_trips) return 0;

			// open graph handle
			const kh_graph = this._k_builder.openC1Graph(sc1_graph);

			// subject specified
			if(sc1_subject) {
				// ref probs
				const hc2_probs = hc3_trips[sc1_subject];

				// subject does not exist
				if(!hc2_probs) return 0;

				// open grub handle
				const kh_grub = kh_graph.openC1Subject(sc1_subject);

				// predicate specified
				if(sc1_predicate) {
					// ref objects
					const as_objects = hc2_probs[sc1_predicate];

					// predicate does not exist
					if(!as_objects) return 0;

					// open grasp handle
					const kh_grasp = kh_grub.openC1Predicate(sc1_predicate);

					// object specified
					if(sc1_object) {
						// object does not exist
						if(!as_objects.has(sc1_object)) return 0;

						// object exists; delete it
						kh_grasp.deleteC1Object(sc1_object);

						// single triple deleted
						return 1;
					}
					// delete all objects
					else {
						// TODO: implement
					}
				}
				// predicate wildcard
				else {
					// TODO: implement
				}
			}
			// subject wildcard
			else {
				// TODO: implement
			}
		}
		// graph wildcard
		else {
			// TODO: implement
		}

		return c_deleted;
	}

	sibling(): BasicQuadTree {
		return BasicQuadTree.empty(this._h_prefixes);
	}

	protected _offspring(hc4_out: QuadsHash): BasicQuadTree {
		return new BasicQuadTree(hc4_out, {
			prefixed: this._b_prefixed,
			prefixes: this._h_prefixes,
		});
	}


	match(yt_subject?: VStarRole.Subject, yt_predicate?: VStarRole.Predicate, yt_object?: VStarRole.Object, yt_graph?: VStarRole.Graph): BasicQuadTree {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		if(yt_subject && 'Quad' === yt_subject.termType) throw new Error('Quads not supported');
		if(yt_object && 'Quad' === yt_object.termType) throw new Error('Quads not supported');

		// match on expanded c1s
		return this._match_c1(
			yt_subject && 'Variable' !== yt_subject.termType? c1FromSubjectRole(yt_subject, h_prefixes): null,
			yt_predicate && 'Variable' !== yt_predicate.termType? c1FromPredicateRole(yt_predicate, h_prefixes): null,
			yt_object && 'Variable' !== yt_object.termType? c1FromObjectRole(yt_object, h_prefixes): null,
			yt_graph && 'Variable' !== yt_graph.termType? c1FromGraphRole(yt_graph, h_prefixes): null,
		);
	}

	matchC1(sc1_subject?: null | C1.Subject, sc1_predicate?: null | C1.Predicate, sc1_object?: null | C1.Object, sc1_graph?: C1.Graph| null): BasicQuadTree {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		if(this._b_prefixed) {
			if(sc1_subject) sc1_subject = c1CompactData<C1.Subject>(sc1_subject, h_prefixes);
			if(sc1_predicate) sc1_predicate = c1CompactData<C1.Predicate>(sc1_predicate, h_prefixes);
			if(sc1_object) sc1_object = c1CompactData<C1.Object>(sc1_object, h_prefixes);
			if(sc1_graph) sc1_graph = c1CompactData<C1.Graph>(sc1_graph, h_prefixes);
		}
		else {
			if(sc1_subject) sc1_subject = c1ExpandData<C1.Subject>(sc1_subject, h_prefixes);
			if(sc1_predicate) sc1_predicate = c1ExpandData<C1.Predicate>(sc1_predicate, h_prefixes);
			if(sc1_object) sc1_object = c1ExpandData<C1.Object>(sc1_object, h_prefixes);
			if(sc1_graph) sc1_graph = c1ExpandData<C1.Graph>(sc1_graph, h_prefixes);
		}

		// match on expanded c1s
		return this._match_c1(
			sc1_subject || null,
			sc1_predicate || null,
			sc1_object || null,
			sc1_graph || null,
		);
	}

	_match_c1(sc1_subject?: null | C1.Subject, sc1_predicate?: null | C1.Predicate, sc1_object?: null | C1.Object, sc1_graph?: C1.Graph| null): BasicQuadTree {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref c4 hash source
		const hc4_src = this._hc4_quads as QuadsHash;

		// +graph
		if(sc1_graph) {
			// no such graph; return new empty tree
			if(!(sc1_graph in hc4_src)) return BasicQuadTree.empty(h_prefixes);

			// ref triples tree
			const hc3_src = hc4_src[sc1_graph];

			// +grraph, +subject
			if(sc1_subject) {
				// no such subject; return new empty tree
				if(!(sc1_subject in hc3_src)) return BasicQuadTree.empty(h_prefixes);

				// ref probs tree
				const hc2_src = hc3_src[sc1_subject];

				// +graph, +subject, +predicate
				if(sc1_predicate) {
					// no such predicate; return new empty tree
					if(!(sc1_predicate in hc2_src)) return BasicQuadTree.empty(h_prefixes);

					// ref objects set
					const as_objects_src = hc2_src[sc1_predicate];

					// for both paths
					let n_quads_objects;
					let as_objects_dst: InternalObjectSet;

					// +graph, +subject, +predicate, +object
					if(sc1_object) {
						// no such object; return new empty tree
						if(!as_objects_src.has(sc1_object)) return BasicQuadTree.empty(h_prefixes);
						
						// create set
						as_objects_dst = new Set([sc1_object]);

						// sole quad
						n_quads_objects = 1;
					}
					// +graph, +subject, +predicate, -object
					else {
						// copy set
						as_objects_dst = new Set(as_objects_src);

						// quad count
						n_quads_objects = as_objects_src.size;
					}
					
					// path merge; create new tree
					return this._offspring({
						[$_KEYS]: 1,
						[$_QUADS]: n_quads_objects,
						// [$_OVERLAY]: 0,
						// [$_BURIED]: [],
						[sc1_graph]: {
							[$_KEYS]: 1,
							[$_QUADS]: n_quads_objects,
							// [$_OVERLAY]: 0,
							// [$_BURIED]: [],
							[sc1_subject]: {
								[$_KEYS]: 1,
								[$_QUADS]: n_quads_objects,
								// [$_OVERLAY]: 0,
								// [$_BURIED]: [],
								[sc1_predicate]: as_objects_dst,
							},
						},
					} as QuadsHash);
				}
				// +graph, +subject, -predicate, +object
				else if(sc1_object) {
					// prepare for loading into set multiple times
					const a_object_load = [sc1_object];

					// how many distinct probs are added
					let c_probs = 0;

					// dst probs tree
					const hc2_dst = overlayTree<ProbsHash>();

					// each probs
					for(const sc1_predicate_in in hc2_src) {
						// object exists under probs tree
						if(hc2_src[sc1_predicate_in].has(sc1_object)) {
							// create new objects set and save to dst probs tree
							hc2_dst[sc1_predicate_in] = new Set(a_object_load);

							// increment probs count
							c_probs += 1;
						}
					}

					// no quads; empty tree
					if(!c_probs) return BasicQuadTree.empty(h_prefixes);

					// save keys and quads count
					hc2_dst[$_KEYS] = c_probs;
					hc2_dst[$_QUADS] = c_probs;

					// create new tree
					return this._offspring({
						[$_KEYS]: 1,
						[$_QUADS]: c_probs,
						[sc1_graph]: {
							[$_KEYS]: 1,
							[$_QUADS]: c_probs,
							[sc1_subject]: hc2_dst,
						},
					} as QuadsHash);
				}
				// +graph, +subject -predicate, -object
				else {
					// quad count
					const n_quads_probs = hc2_src[$_QUADS];

					// create new tree
					return this._offspring({
						[$_KEYS]: 1,
						[$_QUADS]: n_quads_probs,
						[sc1_graph]: {
							[$_KEYS]: 1,
							[$_QUADS]: n_quads_probs,
							[sc1_subject]: overlay(hc2_src),
						},
					} as QuadsHash);
				}
			}
			// +graph, -subject, +predicate
			else if(sc1_predicate) {
				// how many subject-keys and quads are added
				let c_subjects = 0;
				let c_quads = 0;

				// init dst triples tree
				const hc3_dst = overlayTree<TriplesHash>();

				// +graph, -subject, +predicate, +object
				if(sc1_object) {
					// prepare for loading into set multiple times
					const a_object_load = [sc1_object];

					// each triples
					for(const sc1_subject_in in hc3_src) {
						// ref src probs tree
						const hc2_src = hc3_src[sc1_subject_in];

						// no such predicate; skip
						if(!(sc1_predicate in hc2_src)) continue;

						// ref src objects set
						const as_objects_src = hc2_src[sc1_predicate];

						// no such object; skip
						if(!as_objects_src.has(sc1_object)) continue;

						// create probs subtree
						hc3_dst[sc1_subject_in] = {
							[$_KEYS]: 1,
							[$_QUADS]: 1,
							[sc1_predicate]: new Set(a_object_load),
						} as ProbsHash;

						// increment quads count
						c_quads += 1;
					}

					// key count matches added quads count
					c_subjects = c_quads;
				}
				// +graph, -subject, +predicate, -object
				else {
					// each triples
					for(const sc1_subject_in in hc3_src) {
						// ref src probs tree
						const hc2_src = hc3_src[sc1_subject_in];

						// no such predicate; skip
						if(!(sc1_predicate in hc2_src)) continue;

						// create dst objects set
						const as_objects_dst = new Set(hc2_src[sc1_predicate]);

						// create probs subtree
						hc3_dst[sc1_subject_in] = {
							[$_KEYS]: 1,
							[$_QUADS]: as_objects_dst.size,
							[sc1_predicate]: as_objects_dst,
						} as ProbsHash;
						
						// increment quads & subject-keys count
						c_quads += as_objects_dst.size;
						c_subjects += 1;
					}
				}

				// no quads; empty tree
				if(!c_subjects) return BasicQuadTree.empty(h_prefixes);

				// save quads and subject-keys counts to dst triples tree
				hc3_dst[$_KEYS] = c_subjects;
				hc3_dst[$_QUADS] = c_quads;

				// create new tree
				return this._offspring({
					[$_KEYS]: 1,
					[$_QUADS]: c_quads,
					[sc1_graph]: hc3_dst,
				} as QuadsHash);
			}
			// +graph, -subject, -predicate, +object
			else if(sc1_object) {
				// prepare for loading into set multiple times
				const a_object_load = [sc1_object];

				// how many subject keys and quads are added
				let c_subjects = 0;
				let c_quads = 0;

				// init dst triples tree
				const hc3_dst = overlayTree<TriplesHash>();

				// each triples
				for(const sc1_subject_in in hc3_src) {
					// ref src probs tree
					const hc2_src = hc3_src[sc1_subject_in];

					// count distinct probs
					let c_probs = 0;

					// dst probs tree
					const hc2_dst = overlayTree<ProbsHash>();

					// each probs
					for(const sc1_predicate_in in hc2_src) {
						// ref src objects set
						let as_objects_src = hc2_src[sc1_predicate_in];

						// set has target object
						if(as_objects_src.has(sc1_object)) {
							// create object set
							hc2_dst[sc1_predicate_in] = new Set(a_object_load);

							// increment pair count
							c_probs += 1;
						}
					}

					// no probs; skip
					if(!c_probs) continue;

					// save quads and predicate-keys count
					hc2_dst[$_KEYS] = c_probs;
					hc2_dst[$_QUADS] = c_probs;

					// save probs tree tree
					hc3_dst[sc1_subject_in] = hc2_dst;

					// increment super quads count
					c_quads += c_probs;

					// increment subject-keys count
					c_subjects += 1;
				}

				// no quads; empty tree
				if(!c_subjects) return BasicQuadTree.empty(h_prefixes);

				// save quads and subject-keys count
				hc3_dst[$_KEYS] = c_subjects;
				hc3_dst[$_QUADS] = c_quads;

				// create dataset tree
				return this._offspring({
					[$_KEYS]: 1,
					[$_QUADS]: c_quads,
					[sc1_graph]: hc3_dst,
				} as QuadsHash);
			}
			// +graph, -subject, -predicate, -object
			else {
				// create dataset tree
				return this._offspring({
					[$_KEYS]: 1,
					[$_QUADS]: hc3_src[$_QUADS],
					[sc1_graph]: overlay(hc3_src),
				} as QuadsHash);
			}
		}
		// -graph
		else {
			// init dst quads hash
			const hc4_dst = overlayTree<QuadsHash>();

			// -graph, +subject
			if(sc1_subject) {
				// -graph, +subject, +predicate
				if(sc1_predicate) {
					// graph-keys and quads counts
					let c_graphs = 0;
					let c_quads = 0;

					// -graph, +subject, +predicate, +object
					if(sc1_object) {
						// prepare for loading into set multiple times
						const a_object_load = [sc1_object];

						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// no such subject; skip
							if(!(sc1_subject in hc3_src)) continue;

							// ref src probs tree
							const hc2_src = hc3_src[sc1_subject];

							// no such predicate; skip
							if(!(sc1_predicate in hc2_src)) continue;

							// ref src objects set
							const as_objects_src = hc2_src[sc1_predicate];

							// no such object; skip
							if(!as_objects_src.has(sc1_object)) continue;

							// create dst object set
							const as_objects_dst = new Set(a_object_load);

							// create dst triples tree
							hc4_dst[sc1_graph_in] = {
								[$_KEYS]: 1,
								[$_QUADS]: 1,
								[sc1_subject]: {
									[$_KEYS]: 1,
									[$_QUADS]: 1,
									[sc1_predicate]: as_objects_dst,
								},
							} as TriplesHash;

							// increment graph-keys & quads count
							c_quads += 1;
						}

						// graph-keys count matches quads count
						c_graphs = c_quads;
					}
					// -graph, +subject, +predicate, -object
					else {
						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// no such subject; skip
							if(!(sc1_subject in hc3_src)) continue;

							// ref src probs tree
							const hc2_src = hc3_src[sc1_subject];

							// no such predicate; skip
							if(!(sc1_predicate in hc2_src)) continue;

							// create dst objects set
							const as_objects_dst = new Set(hc2_src[sc1_predicate]);

							// how many objects are in set
							let n_objects = as_objects_dst.size;

							// create dst triples tree
							hc4_dst[sc1_graph_in] = {
								[$_KEYS]: 1,
								[$_QUADS]: n_objects,
								[sc1_subject]: {
									[$_KEYS]: 1,
									[$_QUADS]: n_objects,
									[sc1_predicate]: as_objects_dst,
								},
							} as TriplesHash;

							// increment graph-keys & quads count
							c_graphs += 1;
							c_quads += n_objects;
						}
					}

					// no quads; empty tree
					if(!c_graphs) return BasicQuadTree.empty(h_prefixes);

					// save quads and graph-keys counts
					hc4_dst[$_KEYS] = c_graphs;
					hc4_dst[$_QUADS] = c_quads;

					// create dataset tree
					return this._offspring(hc4_dst);
				}
				// -graph, +subject, -predicate
				else {
					// count graph-keys and quads
					let c_graphs = 0;
					let c_quads = 0;

					// -graph, +subject, -predicate, +object
					if(sc1_object) {
						// prepare for loading into set multiple times
						const a_object_load = [sc1_object];

						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// no such subject; skip
							if(!(sc1_subject in hc3_src)) continue;

							// ref src probs tree
							const hc2_src = hc3_src[sc1_subject];

							// count probs
							let c_probs = 0;

							// init dst probs tree
							const hc2_dst =  overlayTree<ProbsHash>();

							// each predicate
							for(const sc1_predicate_in in hc2_src) {
								// ref src objets set
								const as_objects_src = hc2_src[sc1_predicate_in];

								// no such object; skip
								if(!as_objects_src.has(sc1_object)) continue;

								// create dst objects set
								hc2_dst[sc1_predicate_in] = new Set(a_object_load);

								// increment probs count
								c_probs += 1;
							}

							// no probs tree to add; skip graph
							if(!c_probs) continue;

							// save predicate-keys and quads counts
							hc2_dst[$_KEYS] = c_probs;
							hc2_dst[$_QUADS] = c_probs;

							// save probs tree tree
							hc4_dst[sc1_graph_in] = {
								[$_KEYS]: 1,
								[$_QUADS]: c_probs,
								[sc1_subject]: hc2_dst,
							} as TriplesHash;

							// increment graph-keys and quads count
							c_graphs += 1;
							c_quads += c_probs;
						}
					}
					// -graph, +subject, -predicate, -object
					else {
						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// no such subject; skip
							if(!(sc1_subject in hc3_src)) continue;

							// ref src probs tree
							const hc2_src = hc3_src[sc1_subject];

							// quads under probs tree
							const n_quads = hc2_src[$_QUADS];

							// save thin copy of probs tree to dst quads hash
							hc4_dst[sc1_graph_in] = {
								[$_KEYS]: 1,
								[$_QUADS]: n_quads,
								[sc1_subject]: overlay(hc2_src),
							} as TriplesHash;

							// increment graph-keys and quads count
							c_graphs += 1;
							c_quads += n_quads;
						}
					}

					// no quads; empty tree
					if(!c_graphs) return BasicQuadTree.empty(h_prefixes);

					// save graph-keys and quads count
					hc4_dst[$_KEYS] = c_graphs;
					hc4_dst[$_QUADS] = c_quads;

					// save graph-keys and quads counts
					return this._offspring(hc4_dst);
				}
			}
			// -graph, -subject
			else {
				// -graph, -subject, +predicate
				if(sc1_predicate) {  // eslint-disable-line no-lonely-if
					// graph-keys and quads count
					let c_graphs = 0;
					let c_quads = 0;

					// -graph, -subject, +predicate, +object
					if(sc1_object) {
						// prepare for loading into set multiple times
						const a_object_load = [sc1_object];

						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// subjet-keys count
							let c_subjects = 0;

							// init dst triples tree
							const hc3_dst = overlayTree<TriplesHash>();

							// each subject
							for(const sc1_subject_in in hc3_src) {
								// ref src probs tree
								const hc2_src = hc3_src[sc1_subject_in];

								// no such predicate; skip
								if(!(sc1_predicate in hc2_src)) continue;

								// ref src objects set
								const as_objects_src = hc2_src[sc1_predicate];

								// no such object; skip
								if(!as_objects_src.has(sc1_object)) continue;

								// create dst triples tree
								hc3_dst[sc1_subject_in] = {
									[$_KEYS]: 1,
									[$_QUADS]: 1,
									[sc1_predicate]: new Set(a_object_load),
								} as ProbsHash;

								// increment subject-keys and quads count
								c_subjects += 1;
							}

							// no triples trees to add; skip graph
							if(!c_subjects) continue;

							// save subject-keys and quads count
							hc3_dst[$_KEYS] = c_subjects;
							hc3_dst[$_QUADS] = c_subjects;

							// save triples tree tree
							hc4_dst[sc1_graph_in] = hc3_dst;

							// increment graph-keys and quads count
							c_graphs += 1;
							c_quads += c_subjects;
						}

						// no quads; empty tree
						if(!c_graphs) return BasicQuadTree.empty(h_prefixes);

						// save graph-keys and quads count
						hc4_dst[$_KEYS] = c_graphs;
						hc4_dst[$_QUADS] = c_quads

						// create dataset tree
						return this._offspring(hc4_dst);
					}
					// -graph, -subject, +predicate, -object
					else {
						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// subjet-keys and quads count
							let c_subjects = 0;
							let c_triples = 0;

							// init dst triples tree
							const hc3_dst = overlayTree<TriplesHash>();

							// each subject
							for(const sc1_subject_in in hc3_src) {
								// ref src probs tree
								const hc2_src = hc3_src[sc1_subject_in];

								// no such predicate; skip
								if(!(sc1_predicate in hc2_src)) continue;

								// create dst objects set
								const as_objects_dst = new Set(hc2_src[sc1_predicate]);

								// objects count
								const n_objects = as_objects_dst.size;

								// create dst triples tree
								hc3_dst[sc1_subject_in] = {
									[$_KEYS]: 1,
									[$_QUADS]: n_objects,
									[sc1_predicate]: as_objects_dst,
								} as ProbsHash;

								// increment subject-keys and quads count
								c_subjects += 1;
								c_triples += n_objects;
							}

							// no triples trees to add; skip graph
							if(!c_subjects) continue;

							// save subject-keys and quads count
							hc3_dst[$_KEYS] = c_subjects;
							hc3_dst[$_QUADS] = c_triples;

							// save triples tree tree
							hc4_dst[sc1_graph_in] = hc3_dst;

							// increment graph-keys and quads count
							c_graphs += 1;
							c_quads += c_triples;
						}

						// no quads; empty tree
						if(!c_graphs) return BasicQuadTree.empty(h_prefixes);

						// save graph-keys and quads counts
						hc4_dst[$_KEYS] = c_graphs;
						hc4_dst[$_QUADS] = c_quads;

						// create dataset tree
						return this._offspring(hc4_dst);
					}
				}
				// -graph, -subject, -predicate
				else {
					// -graph, -subject, -predicate, +object
					if(sc1_object) {  // eslint-disable-line no-lonely-if
						// prepare for loading into set multiple times
						const a_object_load = [sc1_object];

						// graph-keys and quads count
						let c_graphs = 0;
						let c_quads = 0;

						// each graph
						for(const sc1_graph_in in hc4_src) {
							// ref src triples tree
							const hc3_src = hc4_src[sc1_graph_in];

							// subject-keys and quads count
							let c_subjects = 0;
							let c_triples = 0;

							// init dst triples tree
							const hc3_dst = overlayTree<TriplesHash>();

							// each subject
							for(const sc1_subject_in in hc3_src) {
								// ref src probs tree
								const hc2_src = hc3_src[sc1_subject_in];

								// predicate-keys count
								let c_predicates = 0;

								// init dst probs tree
								const hc2_dst = overlayTree<ProbsHash>();

								// each predicate
								for(const sc1_predicate_in in hc2_src) {
									// ref src objects set
									const as_objects_src = hc2_src[sc1_predicate_in];

									// no such object; skip
									if(!as_objects_src.has(sc1_object)) continue;

									// create dst probs tree
									hc2_dst[sc1_predicate_in] = new Set(a_object_load);

									// increment predicate-keys count
									c_predicates += 1;
								}

								// no quads
								if(!c_predicates) continue;

								// save predicate-keys and quads count
								hc2_dst[$_KEYS] = c_predicates;
								hc2_dst[$_QUADS] = c_predicates;

								// increment subject-keys and triples count
								c_subjects += 1;
								c_triples += c_predicates;

								// save to triples tree tree
								hc3_dst[sc1_subject_in] = hc2_dst;
							}

							// no quads
							if(!c_subjects) continue;

							// save subject-keys and quads count
							hc3_dst[$_KEYS] = c_subjects;
							hc3_dst[$_QUADS] = c_triples;

							// increment graph-keys and quads count
							c_graphs += 1;
							c_quads += c_triples;

							// save triples tree tree
							hc4_dst[sc1_graph_in] = hc3_dst;
						}

						// no quads; empty tree
						if(!c_graphs) return BasicQuadTree.empty(h_prefixes);

						// save subject-keys and quads count
						hc4_dst[$_KEYS] = c_graphs;
						hc4_dst[$_QUADS] = c_quads;

						// create dataset tree
						return this._offspring(hc4_dst);
					}
					// -graph, -subject, -predicate, -object
					else {
						// same quad tree (clone)
						return BasicQuadTree.empty(h_prefixes);
					}
				}
			}
		}
	}


	_crawl_trips(hc3_trips: TriplesHash, hc3_crawl: CrawlTriplesHash, h_accumulator: AccumulatorHash, sc1_subject: C1.Subject, sv1_subject: C1.Subject): void {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref normalizer
		const f_normalize = this._f_normalize;

		// ref probs
		const hc2_probs = hc3_trips[sv1_subject];

		// ref target
		const z_target_subject = hc3_crawl[sc1_subject];

		// target is function
		if('function' === typeof z_target_subject) {
			// invoke
			const h_merge = z_target_subject(hc2_probs);

			// merge
			if(h_merge) Object.assign(h_accumulator, h_merge);

			// next
			return;
		}

		// each predicate in crawl
		for(const sc1_predicate in z_target_subject) {
			// expand
			const sv1_predicate = f_normalize<C1.Predicate>(sc1_predicate as C1.Predicate, h_prefixes);

			// predicate not present; skip
			if(!(sv1_predicate in hc2_probs)) continue;

			// ref objects
			const as_objects = hc2_probs[sv1_predicate];

			// ref target
			const z_target_predicate = z_target_subject[sc1_predicate];

			// target is function
			if('function' === typeof z_target_predicate) {
				// invoke
				const h_merge = z_target_predicate(as_objects);

				// merge
				if(h_merge) Object.assign(h_accumulator, h_merge);

				// next
				continue;
			}

			// each object in crawl
			for(const sc1_object in z_target_predicate) {
				// expand
				const sv1_object = f_normalize<C1.Object>(sc1_object as C1.Object, h_prefixes);

				// object not present; skip
				if(!as_objects.has(sv1_object)) continue;

				// not in subject position
				if(!(sv1_object in hc3_trips)) continue;

				// recurse
				this._crawl_trips(hc3_trips, hc3_crawl, h_accumulator, sc1_object as C1.Subject, sv1_object as C1.Subject);
			}
		}
	}


	crawlTriples(hc3_crawl: CrawlTriplesHash): AccumulatorHash {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref normalizer
		const f_normalize = this._f_normalize;

		// accumulator hash
		const h_accumulator: AccumulatorHash = {};

		// triples in default graph
		const hc3_trips = this._hc3_trips;

		// each subject in crawl
		for(const sc1_subject in hc3_crawl) {
			// expand
			const sv1_subject = f_normalize<C1.Subject>(sc1_subject as C1.Subject, h_prefixes);

			// subject not present; skip
			if(!(sv1_subject in hc3_trips)) continue;

			// crawl trips
			this._crawl_trips(hc3_trips, hc3_crawl, h_accumulator, sc1_subject as C1.Subject, sv1_subject);
		}

		return h_accumulator;
	}


	crawl(hc4_crawl: CrawlQuadsHash): AccumulatorHash {
		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref normalizer
		const f_normalize = this._f_normalize;

		// accumulator hash
		const h_accumulator: AccumulatorHash = {};

		// ref quads
		const hc4_quads = this._hc4_quads;

		// each graph in crawl
		for(const sc1_graph in hc4_crawl) {
			// expand
			const sv1_graph = f_normalize<C1.Graph>(sc1_graph as C1.Graph, h_prefixes);

			// graph not present; skip
			if(!(sv1_graph in hc4_quads)) continue;

			// ref trips
			const hc3_trips = hc4_quads[sv1_graph];

			// ref target
			const z_target_graph = hc4_crawl[sc1_graph];

			// target is function
			if('function' === typeof z_target_graph) {
				// invoke
				const h_merge = z_target_graph(hc3_trips);

				// merge
				if(h_merge) Object.assign(h_accumulator, h_merge);

				// next
				continue;
			}

			// each subject in crawl
			for(const sc1_subject in z_target_graph) {
				// expand
				const sv1_subject = f_normalize<C1.Subject>(sc1_subject as C1.Subject, h_prefixes);

				// subject not present; skip
				if(!(sv1_subject in hc3_trips)) continue;

				// crawl trips
				this._crawl_trips(hc3_trips, z_target_graph, h_accumulator, sc1_subject as C1.Subject, sv1_subject);
			}
		}

		return h_accumulator;
	}


	/**
	 * Clone this dataset
	 */
	clone(h_prefixes_add?: PrefixMap): BasicQuadTree {
		// ref quads tree
		const hc4_quads = this._hc4_quads;

		// bury
		hc4_quads[$_BURIED] = 1;

		// make overlay
		const hc4_out = Object.create(hc4_quads);
		hc4_out[$_OVERLAY] = 1;

		// prep prefixes
		const h_prefixes = h_prefixes_add
			? {
				...this._h_prefixes,
				...h_prefixes_add,
			}
			: this._h_prefixes;

		// return new dataset
		return new BasicQuadTree(hc4_out, {
			prefixed: this._b_prefixed,
			prefixes: h_prefixes,
		});
	}



	/**
	 * Create a new dataset by prefixing all c1 strings
	 */
	prefixed(): BasicQuadTree {
		// already prefixed, just clone it
		if(this._b_prefixed) return this.clone();

		// TODO: implement
		throw new Error('not yet implemented');
	}


	/**
	 * Create a new dataset by expanding all c1 strings
	 */
	expanded(): BasicQuadTree {
		// already expanded, just clone it
		if(!this._b_prefixed) return this.clone();

		// ref prefixes
		const h_prefixes = this._h_prefixes;

		// ref quads
		const hc4_quads = this._hc4_quads as QuadsHash;

		// prep quads out
		const hc4_out = overlayTree<QuadsHash>();

		// each graph
		for(const sc1_graph in hc4_quads) {
			// ref trips tree
			const hc3_trips = hc4_quads[sc1_graph];

			// prep trips out
			const hc3_out = hc4_out[c1ExpandData(sc1_graph as C1.Graph, h_prefixes)] = overlayTree<TriplesHash>();

			// each subject
			for(const sc1_subject in hc3_trips) {
				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// prep probs out
				const hc2_out = hc3_out[c1ExpandData(sc1_subject as C1.Subject, h_prefixes)] = overlayTree<ProbsHash>();

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// ref objects set
					const as_objects = hc2_probs[sc1_predicate];

					// prep objects out
					const as_out = hc2_out[c1ExpandData(sc1_predicate as C1.Predicate, h_prefixes)] = new Set<C1.Object>();

					// each object
					for(const sc1_object of as_objects) {
						as_out.add(c1ExpandData(sc1_object as C1.Object, h_prefixes) as C1.Object);
					}
				}
			}
		}

		// return new dataset
		return new BasicQuadTree(hc4_out, {
			prefixed: this._b_prefixed,
			prefixes: h_prefixes,
		});
	}


	/**
	 * Perform the union of two datasets
	 */
	union(z_other: RDFJS.Dataset): BasicQuadTree {
		// other is graphy dataset
		if((z_other as any).isGraphyDataset) {
			// deduce dataset type
			switch((z_other as any).datasetType) {
				// same dataset type
				case (this as any).datasetStorageType: {
					const k_other = z_other as unknown as BasicQuadTree;

					// prefix maps differ; perform expanded union
					if(prefixMapsDiffer(this._h_prefixes, k_other._h_prefixes)) {
						return this.normalize().union((k_other as BasicQuadTree).normalize());
					}
					// prefix maps are identical
					else {
						return this._union_same(k_other);
					}
				}
				
				// fall-through
				default: {
					// empty
				}
			}
		}

		// resort to iterative merge
		{
			// clone this dataset
			const k_clone = this.clone((z_other as any)._h_prefixes || {});

			// each quad in other; add to clone
			for(const g_quad of z_other) {
				k_clone.add(g_quad);
			}

			// return clone
			return k_clone;
		}
	}


	protected _union_same(k_other: BasicQuadTree): BasicQuadTree {
		// ref quads
		let hc4_quads_a = this._hc4_quads;
		let hc4_quads_b = k_other._hc4_quads;

		// a has less keys than b; swap quads
		if(hc4_quads_a[$_KEYS] < hc4_quads_b[$_KEYS]) {
			[hc4_quads_a, hc4_quads_b] = [hc4_quads_b, hc4_quads_a];
		}

		@{union_same()}
		// const hc4_quads_u = union_same(hc4_quads_a, hc4_quads_b);

		// return new dataset
		return new BasicQuadTree(hc4_quads_u, {
			prefixed: this._b_prefixed,
			prefixes: {
				// copy prefixes
				...this._h_prefixes,
			},
		});
	}

	// *collection<TermType extends Term.Subject | Term.Object>(yt_head: Role.Subject, yt_graph?: Role.Graph): Generator<TermType> {
	// 	const di_items = this._collection_c1(c1FromSubjectRole(yt_head, this._h_prefixes), yt_graph? c1FromGraphRole(yt_graph, this._h_prefixes): '*');
	// 	const h_prefixes = this._h_prefixes;
	// 	for(const sc1_item of di_items) {
	// 		yield objectFromC1(sc1_item, h_prefixes);
	// 	}
	// }

	*collectionC1(sc1_head: C1.Subject, sc1_graph?: C1.Graph): Generator<C1.Object> {
		yield* this._collection_c1(this._f_normalize(sc1_head, this._h_prefixes), sc1_graph? this._f_normalize(sc1_graph, this._h_prefixes): '*');
	}

	// <TermType extends C1.Subject | C1.Object=C1.Subject | C1.Object>
	*_collection_c1(sc1_head: C1.Subject, sc1_graph: C1.Graph): Generator<C1.Object> {
		// rdf:first, rdf:rest and rdf:nil
		const sc1_rdf_first = this._sc1_rdf_first;
		const sc1_rdf_rest = this._sc1_rdf_rest;
		const sc1_rdf_nil = this._sc1_rdf_nil;

		// ref trips
		const hc3_trips = this._hc4_quads[sc1_graph];

		// loop
		for(;;) {
			// fetch probs
			const hc2_probs = hc3_trips[sc1_head];

			// not a subject
			if(!hc2_probs) {
				throw new Error(`No such subject '${sc1_head}'`);
			}

			// ref object set
			const as_objects_first = hc2_probs[sc1_rdf_first];

			// rdf:first <item>
			if(!as_objects_first) {
				throw new Error(`No such '${sc1_rdf_first}' predicate exists for subject '${sc1_head}'`);
			}

			// not exactly one item
			if(1 !== as_objects_first.size) {
				throw new Error(`Expected exactly one object to match {${sc1_head} ${sc1_rdf_first} ?object} but found ${as_objects_first.size}`);
			}

			// yield
			yield [...as_objects_first][0];

			// ref object set
			const as_objects_rest = hc2_probs[sc1_rdf_rest];

			// rdf:rest <item>
			if(!as_objects_rest) {
				throw new Error(`No such '${sc1_rdf_rest}' predicate exists for subject '${sc1_head}'`);
			}

			// not exactly one item
			if(1 !== as_objects_rest.size) {
				throw new Error(`Expected exactly one object to match {${sc1_head} ${sc1_rdf_first} ?object} but found ${as_objects_rest.size}`);
			}

			// ref rest
			const sc1_rest = [...as_objects_rest][0];

			// rdf:nil, end of list
			if(sc1_rdf_nil === sc1_rest) return;

			// continue
			sc1_head = sc1_rest as C1.Subject;
		}
	}


	contains(y_other: RDFJS.Dataset): boolean {
		throw new Error(`not yet implemented`);
	}

	disjoint(y_other: RDFJS.Dataset): boolean {
		throw new Error(`not yet implemented`);
	}

	_equals(k_other: BasicQuadTree): boolean {
		const hc4_quads_a = this._hc4_quads;
		const hc4_quads_b = k_other._hc4_quads;

		// each graph in a
		for(const sc1_graph in hc4_quads_a) {
			// ref trips
			const hc3_trips_a = hc4_quads_a[sc1_graph];
			const hc3_trips_b = hc4_quads_b[sc1_graph];

			// graph missing from b
			if(!hc3_trips_b) return false;

			// quad count mismatch
			if(hc3_trips_a[$_QUADS] !== hc3_trips_b[$_QUADS]) return false;

			// key count mismatch
			if(hc3_trips_a[$_KEYS] !== hc3_trips_b[$_KEYS]) return false;

			// each subject in a
			for(const sc1_subject in hc3_trips_a) {
				// ref probs
				const hc2_probs_a = hc3_trips_a[sc1_subject];
				const hc2_probs_b = hc3_trips_b[sc1_subject];

				// subject missing from b
				if(!hc2_probs_b) return false;

				// quad count mismatch
				if(hc2_probs_a[$_QUADS] !== hc2_probs_b[$_QUADS]) return false;

				// key count mismatch
				if(hc2_probs_a[$_KEYS] !== hc2_probs_b[$_KEYS]) return false;

				// each predicate in a
				for(const sc1_predicate in hc2_probs_a) {
					// ref objects
					const as_objects_a = hc2_probs_a[sc1_predicate];
					const as_objects_b = hc2_probs_b[sc1_predicate];

					// predicate missing from b
					if(!as_objects_b) return false;

					// set size mismatch
					if(as_objects_a.size !== as_objects_b.size) return false;

					// each object in a
					for(const sc1_object of as_objects_a) {
						// object missing from b
						if(!as_objects_b.has(sc1_object)) return false;
					}
				}
			}
		}

		// datasets match
		return true;
	}


	minus(y_other: RDFJS.Dataset): Dataset.SyncDataset {
		// TODO: in some cases, it will be faster to replace a tree in 'src' with an overlay of a tree from 'dst', and then delete keys from original tree
		throw new Error(`not yet implemented`);
	}

	difference(y_other: RDFJS.Dataset): BasicQuadTree {
		throw new Error('not yet implemented');
	}

	filter(f_iteratee: (g_quad: Term.Quad, kd_dataset: this) => boolean): BasicQuadTree {
		throw new Error('not yet implemented');
	}


	normalize(): BasicQuadTree {
		return (new Normalizer(this)).normalize();
	}

	import(ds_stream: RDFJS.Stream): Promise<this> {
		return new Promise((fk_resolve, fe_reject) => {
			const k_builder = this._k_builder;
			const h_prefixes = this._h_prefixes;

			let yt_graph_prev: null | Role.Graph = null;
			let kh_graph: null | Dataset.GraphHandle = null;
			let yt_subject_prev: null | Role.Subject = null;
			let kh_grub: null | Dataset.GrubHandle = null;
			let yt_predicate_prev: null | Role.Predicate = null;
			let kh_grasp: null | Dataset.GraspHandle = null;

			ds_stream
				.on('data', (g_quad: RDFJS.Quad) => {
					const {
						graph: yt_graph,
						subject: yt_subject,
						predicate: yt_predicate,
					} = g_quad as Role.Quad;

					if(yt_graph_prev !== yt_graph) {
						yt_graph_prev = yt_graph;
						kh_graph = k_builder.openC1Graph(c1FromGraphRole(yt_graph, h_prefixes));
						kh_grub = kh_graph.openC1Subject(c1FromSubjectRole(yt_subject, h_prefixes));
						kh_grasp = kh_grub.openC1Predicate(c1FromPredicateRole(yt_predicate, h_prefixes));
					}
					else if(yt_subject_prev !== yt_subject) {
						yt_subject_prev = yt_subject;
						kh_grub = (kh_graph as Dataset.GraphHandle).openC1Subject(c1FromSubjectRole(yt_subject, h_prefixes));
						kh_grasp = kh_grub.openC1Predicate(c1FromPredicateRole(yt_predicate, h_prefixes));
					}
					else if(yt_predicate_prev !== yt_predicate) {
						yt_predicate_prev = yt_predicate;
						kh_grasp = (kh_grub as Dataset.GrubHandle).openC1Predicate(c1FromPredicateRole(yt_predicate, h_prefixes));
					}

					(kh_grasp as GraspHandle).addC1Object(c1FromObjectRole(g_quad.object, h_prefixes));
				})
				.on('error', (e_read: Error) => {
					fe_reject(e_read);
				})
				.on('end', () => {
					fk_resolve(this);
				});
		});
	}

	intersection(y_other: RDFJS.Dataset): BasicQuadTree {
		throw new Error('not yet implemented');
	}
}

// BasicQuadTree.prototype.toCanonical = BasicQuadTree.prototype.normalize;
BasicQuadTree.prototype.canonicalize = BasicQuadTree.prototype.normalize;


// typings for fixed prototype properties
export interface BasicQuadTree {
	/**
	 * Indicates at runtime without that this class is compatible as a graphy dataset
	 */
	isGraphyDataset: true;

	/**
	 * Describes at runtime the canonical storage type interface for this datatset
	 */
	datasetStorageType: string;

	/**
	 * For typing static properties and methods
	 */
	constructor: GenericQuadTree.Static<BasicQuadTree, BasicQuadTreeBuilder, QuadsHash>;

	// toCanonical(): BasicQuadTree;

	canonicalize(): BasicQuadTree;
}

type BasicQuadTreeClass = GenericQuadTree.Static<BasicQuadTree, BasicQuadTreeBuilder, QuadsHash>;

const BasicQuadTree_Assertion: BasicQuadTreeClass = BasicQuadTree;


BasicQuadTree.prototype.isGraphyDataset = true;

BasicQuadTree.prototype.datasetStorageType = '@{`
	quads {
		[g: c1]: trips {
			[s: c1]: probs {
				[p: c1]: Set<o: c1>;
			};
		};
	};
`.replace(/\s+/g, '')}';




const F_SORT_CANONICALIZER_HASH = (g_a: HndqResult, g_b: HndqResult) => g_a.hash < g_b.hash? -1: (g_a.hash > g_b.hash? 1: 0);

// import {
// 	createHash,
// } from 'crypto';

// const hash = (s: string) => createHash('sha256').update(s).digest('hex');

// the fastest and most memory efficient implemntation of heap's method for javascript
// adapted from <https://stackoverflow.com/a/37580979/1641160>
function permute(a_list: any[], f_yield: (a: any[]) => void) {
	f_yield(a_list.slice());

	const nl_list = a_list.length;
	const a_counts = nl_list < 256
		? new Uint8Array(nl_list)
		: (nl_list < 65536
			? new Uint16Array(nl_list)
			: (new Array(nl_list)).fill(0));
	let i_pos = 1;
	let i_other = 0;
	let z_swap = a_list[0];

	while(i_pos < nl_list) {
		if(a_counts[i_pos] < i_pos) {
			i_other = (i_pos % 2) && a_counts[i_pos];
			z_swap = a_list[i_pos];
			a_list[i_pos] = a_list[i_other];
			a_list[i_other] = z_swap;
			a_counts[i_pos] += 1;
			i_pos = 1;
			f_yield(a_list.slice());
		}
		else {
			a_counts[i_pos++] = 0;
		}
	}
}



class Issuer {
	_s_prefix: string;
	_c_counter: number;
	_h_existing: {
		[s_label: string]: string;
	};

	constructor(s_prefix='_:c14n', c_counter=0, h_existing={}) {
		this._s_prefix = s_prefix;
		this._c_counter = c_counter;
		this._h_existing = h_existing;
	}

	issue(s_label: string): string {
		if(s_label in this._h_existing) return this._h_existing[s_label];

		return (this._h_existing[s_label] = this._s_prefix+(this._c_counter++));
	}

	clone(): Issuer {
		return new Issuer(this._s_prefix, this._c_counter, this._h_existing);
	}
}

interface BlankNodeBookmark {
	[sc1_blank: string]: {
		graph: number;
		subject: Array<C1.Graph>;
		object: Array<[C1.Graph, C1.Subject, C1.Predicate]>;
	};
}

interface BlankNodeHashes {
	[sc1_blank: string]: string;
}

interface BlankNodeAssociations {
	[sc1_blank: string]: Array<C1.BlankNode>;
}

interface HndqResult {
	hash: string;
	issuer: Issuer;
}

export class Normalizer {
	_kd_source: BasicQuadTree;
	_hc4_quads: QuadsHash;
	_k_issuer: Issuer;
	_h_blanks: BlankNodeBookmark;
	_h_hashes: BlankNodeHashes;

	constructor(kd_source: BasicQuadTree) {
		this._kd_source = kd_source;
		this._hc4_quads = kd_source._hc4_quads;
		this._k_issuer = new Issuer('_:r');
		this._h_blanks = null as unknown as BlankNodeBookmark;
		this._h_hashes = null as unknown as BlankNodeHashes;
	}

	// implementation of ยง4.4.2: Normalization Algorithm
	normalize(): BasicQuadTree {
		const {
			_k_issuer: k_issuer,
			_hc4_quads: hc4_quads,
		} = this;

		// (1)
		const h_blanks = this._h_blanks = {} as BlankNodeBookmark;

		// (3)
		const as_non_normal = new Set<C1.BlankNode>();

		// (2) each graph
		for(const sc1_graph in hc4_quads) {
			// graph is blank node
			if('#' === sc1_graph[0]) {
				// add it to set
				as_non_normal.add(sc1_graph as C1.BlankNode);

				// blank node is registered; update it
				if(sc1_graph in h_blanks) {
					h_blanks[sc1_graph].graph = 1;
				}
				// blank node is unregistered; register it
				else {
					h_blanks[sc1_graph] = {
						graph: 1,
						subject: [],
						object: [],
					};
				}
			}

			// ref trips tree
			const hc3_trips = hc4_quads[sc1_graph];

			// each subject
			for(const sc1_subject in hc3_trips) {
				// subject is blank node and different from graph
				if('#' === sc1_subject[0] && sc1_graph !== sc1_subject) {
					// add it to set
					as_non_normal.add(sc1_subject as C1.BlankNode);

					// blank node is registered; update it
					if(sc1_subject in h_blanks) {
						h_blanks[sc1_subject].subject.push(sc1_graph as C1.Graph);
					}
					// blank node is unregistered; register it
					else {
						h_blanks[sc1_subject] = {
							graph: 0,
							subject: [sc1_graph as C1.Graph],
							object: [],
						};
					}
				}

				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// ref objects set
					const as_objects = hc2_probs[sc1_predicate];

					// each object
					for(const sc1_object of as_objects) {
						// object is blank node and different from subject and graph
						if('#' === sc1_object[0] && sc1_subject !== sc1_object && sc1_graph !== sc1_object) {
							// add it to set
							as_non_normal.add(sc1_object as C1.BlankNode);

							// blank node is registered; update it
							if(sc1_object in h_blanks) {
								h_blanks[sc1_object].object.push([sc1_graph as C1.Graph, sc1_subject as C1.Subject, sc1_predicate as C1.Predicate]);
							}
							// blank node is unregistered; register it
							else {
								h_blanks[sc1_object] = {
									graph: 0,
									subject: [],
									object:[
										[sc1_graph as C1.Graph, sc1_subject as C1.Subject, sc1_predicate as C1.Predicate],
									],
								};
							}
						}
					}
				}
			}
		}

		// (1)
		const h_hashes = this._h_hashes = {} as BlankNodeHashes;
		let h_assoc = {} as BlankNodeAssociations;
		let a_keys: string[] = [];

		// first iteration
		// (5)
		{
			// (5.3) each blank node
			for(const sc1_blank of as_non_normal) {
				// (5.3.1) hash 1-degree blanks and storer
				const si_norm = h_hashes[sc1_blank] = this.hash_1dq(sc1_blank);

				// hash exists; add blank to assoc
				if(si_norm in h_assoc) {
					h_assoc[si_norm].push(sc1_blank);
				}
				// first encounter; create list
				else {
					h_assoc[si_norm] = [sc1_blank];
				}

				// add to keys
				a_keys.push(si_norm);
			}

			// (5.4) each blank node id in sorted keys (keys now sorted in fall-through)
			for(const si_norm of a_keys.sort()) {
				// ref associated blank nodes list
				const a_blanks = h_assoc[si_norm];

				// (5.4.1)
				if(a_blanks.length > 1) continue;

				// ref first item in list
				const sc1_blank_0 = a_blanks[0];

				// (5.4.2)
				k_issuer.issue(sc1_blank_0);

				// (5.4.3)
				as_non_normal.delete(sc1_blank_0);

				// (5.4.4) & (5.4.5)
				a_keys = [];
			}
		}

		// subsequent iterations
		// (4)
		let b_simple = false;

		// (5)
		do {
			// (5.1)
			b_simple = false;

			// (5.2) reset assoc
			h_assoc = {};
			a_keys = [];

			// (5.3) each blank node
			for(const sc1_blank of as_non_normal) {
				// ref hash
				const si_norm = h_hashes[sc1_blank];

				// (5.3.2) hash exists; add blank to assoc
				if(si_norm in h_assoc) {
					h_assoc[si_norm].push(sc1_blank);
				}
				// first encounter; create list
				else {
					h_assoc[si_norm] = [sc1_blank];
				}

				// add to keys
				a_keys.push(si_norm);
			}

			// (5.4) each blank node id in sorted keys (keys now sorted in fall-through)
			for(const si_norm of a_keys.sort()) {
				// ref associated blank nodes list
				const a_blanks = h_assoc[si_norm];

				// (5.4.1)
				if(a_blanks.length > 1) continue;

				// ref first item in list
				const sc1_blank_0 = a_blanks[0];

				// (5.4.2)
				k_issuer.issue(sc1_blank_0);

				// (5.4.3)
				as_non_normal.delete(sc1_blank_0);

				// (5.4.4) & (5.4.5)
				a_keys = [];

				// (5.4.5)
				b_simple = true;
			}
		} while(b_simple);

		// (6) keys are already sorted
		for(const si_blank of a_keys.sort()) {
			// (6.1)
			const a_paths = [];

			// (6.2)
			for(const sc1_blank of h_assoc[si_blank]) {
				// (6.2.1)
				if(sc1_blank in k_issuer._h_existing) continue;

				// (6.2.2)
				const k_issuer_tmp = new Issuer('_:g');

				// (6.2.3)
				k_issuer_tmp.issue(sc1_blank);

				// (6.2.4)
				a_paths.push(this.hash_ndq(sc1_blank, k_issuer_tmp));
			}

			// (6.3)
			for(const g_hash_result of a_paths.sort(F_SORT_CANONICALIZER_HASH)) {
				// (6.3.1)
				for(const sc1_existing in g_hash_result.issuer._h_existing) {
					k_issuer.issue(sc1_existing);
				}
			}
		}

		// build output
		const kb_out = this._kd_source.constructor.builder(Object.assign({}, this._kd_source._h_prefixes));

		// 
		const s_issuer_prefix = k_issuer._s_prefix;

		// (7) each graph
		for(let sc1_graph in hc4_quads) {
			// replace blank node identifier
			if('#' === sc1_graph[0] && !sc1_graph.startsWith(s_issuer_prefix)) {
				sc1_graph = k_issuer._h_existing[sc1_graph];
			}

			// open graph
			const kh_graph = kb_out.openC1Graph(sc1_graph as C1.Graph);

			// ref trips tree
			const hc3_trips = hc4_quads[sc1_graph];

			// each subject
			for(let sc1_subject in hc3_trips) {
				// replace blank node identifier
				if('#' === sc1_subject[0] && !sc1_subject.startsWith(s_issuer_prefix)) {
					sc1_subject = k_issuer._h_existing[sc1_subject];
				}

				// open subject
				const kh_grub = kh_graph.openC1Subject(sc1_subject as C1.Subject);

				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// open predicate
					const kh_grasp = kh_grub.openC1Predicate(sc1_predicate as C1.Predicate);

					// ref objects set
					const as_objects = hc2_probs[sc1_predicate];

					// each object
					for(let sc1_object of as_objects) {
						// replace blank node identifier
						if('#' === sc1_object[0] && !sc1_object.startsWith(s_issuer_prefix)) {
							sc1_object = k_issuer._h_existing[sc1_object] as C1.Object;
						}

						// add object to new dataset
						kh_grasp.addC1Object(sc1_object);
					}
				}
			}
		}

		// (8) deliver canonicalized dataset
		return kb_out.deliver({
			prefixed: false,
			prefixes: this._kd_source._h_prefixes,
		});
	}

	// implementation of ยง4.6.2: Hash First Degree Quads Algorithm
	hash_1dq(sc1_blank: C1.BlankNode): string {
		const {
			_h_blanks: h_blanks,
			_hc4_quads: hc4_quads,
		} = this;

		// (1)
		const a_norms = [];

		// ref blank node paths
		const g_blank = h_blanks[sc1_blank];

		// occurs as graph
		if(g_blank.graph) {
			// ref trips tree
			const hc3_trips = hc4_quads[sc1_blank];

			// create norm string
			const s_norm_g = '_:a\x02';

			// each subject
			for(const sc1_subject in hc3_trips) {
				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// create norm string
				const s_norm_gs = s_norm_g+('#' === sc1_subject[0]
					? (sc1_subject === sc1_blank ? '_:a\x01': '_:z\x01')
					: sc1_subject+'\x01');

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// ref objects set
					const as_objects = hc2_probs[sc1_predicate];

					// create norm string
					const s_norm_gsp = s_norm_gs+sc1_predicate+'\0';

					// each object
					for(const sc1_object of as_objects) {
						// push norm string
						if('#' === sc1_object[0]) {
							a_norms.push(s_norm_gsp+(sc1_object===sc1_blank? '_:a': '_:z'));
						}
						else {
							a_norms.push(s_norm_gsp+sc1_object);
						}
					}
				}
			}
		}

		// each occurrence of subject
		for(const sc1_graph of g_blank.subject) {
			// ref probs tree
			const hc2_probs = hc4_quads[sc1_graph][sc1_blank];

			// create norm string
			const s_norm_gs = ('#' === sc1_graph[0]? '_:z\x02': sc1_graph+'\x02')+'_:a\x01';

			// each predicate
			for(const sc1_predicate in hc2_probs) {
				// ref objects set
				const as_objects = hc2_probs[sc1_predicate];

				// create norm string
				const s_norm_gsp = s_norm_gs+sc1_predicate+'\0';

				// each object
				for(const sc1_object of as_objects) {
					// push norm string
					if('#' === sc1_object[0]) {
						a_norms.push(s_norm_gsp+(sc1_object===sc1_blank? '_:a': '_:z'));
					}
					else {
						a_norms.push(s_norm_gsp+sc1_object);
					}
				}
			}
		}

		// each occurrence of object
		for(const [sc1_graph, sc1_subject, sc1_predicate] of g_blank.object) {
			// init norm string
			let si_norm_gs = sc1_graph+'\x02';

			// graph is blank node
			if('#' === sc1_graph[0]) {
				si_norm_gs = sc1_graph === sc1_blank? '_:a\x02': '_:z\x02';
			}

			// subject is blank node
			if('#' === sc1_subject[0]) {
				si_norm_gs += sc1_subject === sc1_blank? '_:a\x01': '_:z\x01';
			}
			else {
				si_norm_gs += sc1_subject+'\x01';
			}

			// push norm string
			a_norms.push(si_norm_gs+sc1_predicate+'\0_:a');
		}

		// done
		return hash(a_norms.sort().join('\b'));
	}


	hash_ndq(sc1_blank: C1.BlankNode, k_issuer: Issuer): HndqResult {
		const {
			_k_issuer: k_issuer_root,
		} = this;

		// (3)
		const h_related = this.hash_related(sc1_blank, k_issuer);

		let s_input = '';

		for(const si_norm of Object.keys(h_related).sort()) {
			let s_path_chosen = '';
			let k_issuer_chosen: Issuer | undefined;

			// eslint-disable-next-line no-loop-func
			permute(h_related[si_norm], (a_perm) => {
				let k_issuer_copy = k_issuer.clone();
				let s_path = '';
				const a_recurse = [];

				for(const si_related of a_perm) {
					const si_issued = k_issuer_root._h_existing[si_related];
					if(si_issued) {
						s_path += si_issued;
					}
					else {
						if(!k_issuer_copy._h_existing[si_related]) {
							a_recurse.push(si_related);
						}

						s_path += k_issuer_copy.issue(si_related);
					}

					if(s_path_chosen.length
						&& s_path.length >= s_path_chosen.length
						&& s_path > s_path_chosen
					) {
						return;
					}
				}

				for(const si_related of a_recurse) {
					const g_hash_result = this.hash_ndq(si_related, k_issuer_copy);

					s_path += k_issuer_copy.issue(si_related);

					s_path += '<'+g_hash_result.hash+'>';

					k_issuer_copy = g_hash_result.issuer;

					if(s_path_chosen.length
						&& s_path.length >= s_path_chosen.length
						&& s_path > s_path_chosen
					) {
						return;
					}
				}

				if(!s_path_chosen.length || s_path < s_path_chosen) {
					s_path_chosen = s_path;
					k_issuer_chosen = k_issuer_copy;
				}
			});

			s_input += si_norm+s_path_chosen;

			k_issuer = k_issuer_chosen as Issuer;
		}

		return {
			hash: hash(s_input),
			issuer: k_issuer,
		};
	}


	// implementation of ยง4.7.2: Hash Related Blank Node Algorithm
	hash_relative(sc1_blank: C1.BlankNode, sc1_predicate: C1.Predicate, k_issuer: Issuer, i_role: number): string {
		return hash(''+i_role+(i_role? '<'+sc1_predicate+'>': '')+(
			this._k_issuer._h_existing[sc1_blank]
				|| k_issuer._h_existing[sc1_blank]
				|| this._h_hashes[sc1_blank]));
	}


	// helper method for (3) in ยง4.8.2: Hash N-Degree Quads
	hash_related(sc1_blank: C1.BlankNode, k_issuer: Issuer): BlankNodeAssociations {
		const {
			_h_blanks: h_blanks,
			_hc4_quads: hc4_quads,
		} = this;

		const h_related = {} as BlankNodeAssociations;

		// ref blank node paths
		const g_blank = h_blanks[sc1_blank];

		// occurs as graph
		if(g_blank.graph) {
			// ref trips tree
			const hc3_trips = hc4_quads[sc1_blank];

			// each subject
			for(const sc1_subject in hc3_trips) {
				// relate to subject
				const b_relate_subject = ('#' === sc1_subject[0] && sc1_subject !== sc1_blank);

				// ref probs tree
				const hc2_probs = hc3_trips[sc1_subject];

				// each predicate
				for(const sc1_predicate in hc2_probs) {
					// relate to subject
					if(b_relate_subject) {
						const si_related = this.hash_relative(sc1_subject as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 1);
						if(si_related in h_related) {
							h_related[si_related].push(sc1_subject as C1.BlankNode);
						}
						else {
							h_related[si_related] = [sc1_subject as C1.BlankNode];
						}
					}

					// ref objects set
					const as_objects = hc2_probs[sc1_predicate];

					// each object
					for(const sc1_object of as_objects) {
						// relate to object
						if('#' === sc1_object[0] && sc1_object !== sc1_blank) {
							const si_related = this.hash_relative(sc1_object as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 2);
							if(si_related in h_related) {
								h_related[si_related].push(sc1_object as C1.BlankNode);
							}
							else {
								h_related[si_related] = [sc1_object as C1.BlankNode];
							}
						}
					}
				}
			}
		}

		// each occurrence of subject
		for(const sc1_graph of g_blank.subject) {
			// relate to graph (guaranteed to not be graph)
			const b_relate_graph = '#' === sc1_graph[0];

			// ref probs tree
			const hc2_probs = hc4_quads[sc1_graph][sc1_blank];

			// each predicate
			for(const sc1_predicate in hc2_probs) {
				// relate to graph
				if(b_relate_graph) {
					const si_related = this.hash_relative(sc1_graph as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 0);
					if(si_related in h_related) {
						h_related[si_related].push(sc1_graph as C1.BlankNode);
					}
					else {
						h_related[si_related] = [sc1_graph as C1.BlankNode];
					}
				}

				// ref objects set
				const as_objects = hc2_probs[sc1_predicate];

				// each object
				for(const sc1_object of as_objects) {
					// relate to object
					if('#' === sc1_object[0] && sc1_object !== sc1_blank) {
						const si_related = this.hash_relative(sc1_object as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 2);
						if(si_related in h_related) {
							h_related[si_related].push(sc1_object as C1.BlankNode);
						}
						else {
							h_related[si_related] = [sc1_object as C1.BlankNode];
						}
					}
				}
			}
		}

		// each occurrence of object
		for(const [sc1_graph, sc1_subject, sc1_predicate] of g_blank.object) {
			// relate to graph
			if('#' === sc1_graph[0]) {
				const si_related = this.hash_relative(sc1_graph as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 0);
				if(si_related in h_related) {
					h_related[si_related].push(sc1_graph as C1.BlankNode);
				}
				else {
					h_related[si_related] = [sc1_graph as C1.BlankNode];
				}
			}

			// relate to subject
			if('#' === sc1_subject[0]) {
				const si_related = this.hash_relative(sc1_subject as C1.BlankNode, sc1_predicate as C1.Predicate, k_issuer, 1);
				if(si_related in h_related) {
					h_related[si_related].push(sc1_subject as C1.BlankNode);
				}
				else {
					h_related[si_related] = [sc1_subject as C1.BlankNode];
				}
			}
		}

		// done
		return h_related;
	}
}

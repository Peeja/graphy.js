import {
	F_NOOP,
	F_THROW,
	create_static_run_method,
} from './_interface.mjs';

import {stream} from 'readable-stream';

@> create_export_class(s_format, s_mode)
	@.{
		const s_label = ({
			ttl: 'Turtle',
			trig: 'TriG',
		})[s_format];

		const b_load = 'load' === s_mode;
		const sji_export = s_label+s_mode[0].toUpperCase()+s_mode.substr(1)+'er';
		const sji_consumer = /* syntax: js */ `${sji_export}Consumer`;
	}

	import {Consumer as @{sji_consumer}} from './@{s_format}/@{s_mode}.mjs';

	export class @{sji_export} extends stream.@{b_load? /* syntax: js */ `Writable`: /* syntax: js */ `Transform`} {
		constructor(gc_consumer={}) {
			super({
				// do not decode strings into buffers
				decodeStrings: false,

				// accept strings as input on writable side
				writableObjectMode: false,

				@if !b_load
					// output quad objects on readable side
					readableObjectMode: true,
				@;
			});

			// hash of rewired event handlers
			this._h_rewired = {};

			// instantiate consumer
			const k_consumer = this._k_consumer = new @{sji_consumer}(gc_consumer, @{sji_export});  // eslint-disable-line no-new

			// proxy stream
			k_consumer.proxy_transform(this);
		}

		_rewire_event(si_event) {
			// event not yet rewired
			if(this._h_rewired && !(si_event in this._h_rewired)) {
				let si_handler = `_fk_${si_event}`;

				// ref handler
				const fk_handler = this._k_consumer[si_handler]

				// legitimate event
				if(fk_handler){
					// reassign current handler
					if(F_NOOP !== fk_handler) {
						super.on(si_event, fk_handler);
					}

					// rewire handler
					this._k_consumer[si_handler] = (...a_args) => {
						this.emit(si_event, ...a_args);
					};

					// save to hash
					this._h_rewired[si_event] = 1;
				}
				// error event
				else if('error' === si_event) {
					const fe_handler = this._k_consumer._fe_error;

					// reassign current handler
					if(fe_handler && F_THROW !== fe_handler) {
						super.on('error', fe_handler);
					}

					// rewire handler
					this._k_consumer._fe_error = (...a_args) => {
						this.emit('error', ...a_args);
					};

					// save to hash
					this._h_rewired.error = 1;
				}
			}
		}

		// intercept on
		on(si_event, fk_event, gc_event) {
			// harden callback event
			this._rewire_event(si_event);

			// forward to proxy
			super.on(si_event, fk_event, gc_event);
		}

		// intercept once
		once(si_event, fk_event, gc_event) {
			// harden callback event
			this._rewire_event(si_event);

			// forward to proxy
			super.once(si_event, fk_event, gc_event);
		}

		@if !b_load
			// intercept pipe
			pipe(ds_out) {
				let ds_dst = ds_out;

				// non-object mode
				if(!ds_dst._writableState.objectMode) {
					// transform to JSON
					ds_out = stream.quads_to_json();
				}
				// yet object mode and graphy writable
				else if(ds_out.isGraphyWritable) {
					// transform to writable data events
					ds_out = stream.quads_to_writable();
				}

				// interim stream created
				if(ds_out !== ds_dst) {
					// forward output to super
					super.pipe(ds_out);

					// pipe outpu to destination
					return ds_out.pipe(ds_dst);
				}
				// forward as-is to super
				else {
					return super.pipe(ds_dst);
				}
			}
		@;
	}

	// assign static method
	@{sji_export}.run = create_static_run_method(@{sji_consumer}, @{sji_export});

	// export default @{sji_export};
@;

@{create_export_class('ttl', 'read')}
@{create_export_class('ttl', 'load')}

@import '../../../share/iris.jmacs'
@import '../../../share/channel.jmacs'
@import '../../../share/polyfills.jmacs'

@./* global FORMAT */
@//@

@{polyfill.queueMicrotask()}

@$ TTL = 'ttl' === FORMAT;
@$ TRIG = 'trig' === FORMAT;
@$ QUADS = TRIG;

@$ S_LABEL = TTL? 'Turtle': 'TriG';

@$ B_OPTIMIZE_PAIRS = false;
@$ B_UPGRADE_FACTORY = true;
@$ B_OPTIMIZE_PREFIX_IDS = false;

@// 1% speedup
@$ B_OPTIMIZE_PN = true;

@.{
	let SJ_RDF_TYPE;
	let SJ_RDF_FIRST;
	let SJ_RDF_REST;
	let SJ_RDF_NIL;
	let SJ_DEFAULT_GRAPH;

	let terms_equal;

	if(B_UPGRADE_FACTORY) {
		SJ_RDF_TYPE = 'this._kt_rdf_type';
		SJ_RDF_FIRST = 'this._kt_rdf_first';
		SJ_RDF_REST = 'this._kt_rdf_rest';
		SJ_RDF_NIL = 'this._kt_rdf_nil';
		SJ_DEFAULT_GRAPH = 'this._kt_default_graph';
		terms_equal = (sj_a, sj_b) => /* syntax: js */ `${sj_a}.equals(${sj_b})`;
	}
	else {
		SJ_RDF_TYPE = 'KT_RDF_TYPE';
		SJ_RDF_FIRST = 'KT_RDF_FIRST';
		SJ_RDF_REST = 'KT_RDF_REST';
		SJ_RDF_NIL = 'KT_RDF_NIL';
		SJ_DEFAULT_GRAPH = 'KT_DEFAULT_GRAPH';
		terms_equal = (sj_a, sj_b) => /* syntax: js */ `${sj_a} === ${sj_b}`;
	}


	let prefixed_name;

	if(B_OPTIMIZE_PN) {
		prefixed_name = (sj_pre, sj_suf) => /* syntax: js */ `this.prefixed_name(${sj_pre}, ${sj_suf})`;
	}
	else {
		prefixed_name = (sj_pre, sj_suf) => /* syntax: js */ `this.named_node(this._h_prefixes[${sj_pre}] + ${sj_suf})`;
	}
}

@// import parser macros
@import '../../text.read.jmacs'

const uri = require('uri-js');
const string_decoder = require('string_decoder');

const stream = require('@{channel('core.iso.stream')}');
const factory = require('@{channel('core.data.factory')}');
const quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);

// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_NAMESPACE_VALID = /^(@{PN_PREFIX()})?$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^@{PN_LOCAL()}$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_BLANK_NODE_VALID = /^[@{RANGE_PN_CHARS_U()}0-9]@{PN_CHARS_FS()}$/u;
const RT_NAMED_NODE_VALID = /@{RT_NAMED_NODE_VALID(false)}/;
const RT_NAMED_NODE_ESCAPELESS_VALID = /@{RT_NAMED_NODE_VALID(true)}/;

const RT_LITERAL_CONTENTS_VALID = /@{RT_LITERAL_CONTENTS_VALID()}/;

const R_UNICODE_ANY = /@{R_UNICODE_4()}|@{R_UNICODE_8()}/g;

const F_REPLACE_UNICODE_ANY = @{F_REPLACE_UNICODE_ANY()};

const OPHOP = Object.prototype.hasOwnProperty;


@$ H_LOOKAHEADS = {
	comment: {
		chars: '#',
	},
	tree: {
		sub: 'comment',
		chars: '<',  // node
	},
	predicate: {
		sub: 'tree',
		chars: ''
			+'['  // blank node property list
			+'('  // collection
			+'"\''  // string
			,
	},
	object: {
		sub: 'comment',
		chars: ''
			+','  // object list
			+';'  // predicate-object list
			+'\\]'  // blank node property list
			+')'  // collection
			,
	},
	terminal: {
		sub: 'object',
		chars: ''
			+'.'  // triple
			+(TRIG? '}': '')  // end-of-graph
			,
	},
	string: {
		sub: 'terminal',
		chars: ''
			+'@'  // langtag
			+'^'  // datatype
			,
	},
	blank_node: {
		sub: 'object',
		chars: ''
			+'<'  // iri
			+':'  // prefixed name (only one colon allowed in blank node label)
			+(TRIG? '{': '')  // start-of-graph (subject)
			,
	},
};

@>> lookahead(s_key, s_append='', s_prepend='')
	@//@regex
	(?:\s+|(?=@{s_prepend}[@*{
		let h_node;
		do {
			h_node = H_LOOKAHEADS[s_key];
			yield h_node.chars;
		} while(h_node.sub && (s_key=h_node.sub));
	}])@{s_append})
@;


@>> R_CHAR(s_delims='')
	@//@regex
	[^\s#@<[("'@{s_delims}@{QUADS? '{}': ''}]
@;

@>> R_CHAR_NO_CLOSERS(s_puncts='.;,')
	@//@regex
	[^\s#@<[("'@{s_puncts}@{QUADS? '{}': ''})\]\\]
@;

@>> R_PREFIX_ID()
	@//@regex
	@{R_CHAR(':_')}@{R_CHAR(':')}*
@;

@>> R_ESCAPE_SEQUENCE()
	@//@regex
	\\ (?:
		%[0-9A-Fa-f][0-9A-Fa-f]
		| [^\s"]
	)
@;

@>> R_CONTENT_LOOKAHEAD_OLD()
	@//@regex
	(?=
		\.[<[("';,)\]#@{QUADS? '{}': ''}\s\0]
		| [<[("';,)\]#@{QUADS? '{}': ''}]
	)
@;

@>> R_CONTENT_LOOKAHEAD()
	@//@regex
	(?=
		\.?[<[("';,)\]#@{QUADS? '{}': ''}]
		| \.[\s\0]
	)
@;

@>> R_PREFIXED_NAME_QUICK()
	@//@regex
	(
		[A-Za-z]  @// PN_CHARS_BASE simplified
		[A-Za-z0-9_-]*  @// PN_CHARS (omit '.' from middle for perf)
	)? :(
		[A-Za-z_0-9:]  @// PN_LOCAL[0]
		[A-Za-z0-9_:-]*  @// PN_LOCAL[1-$]
	)
	(?:
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME_QUICK = /@{R_PREFIXED_NAME_QUICK()}/y;

@>> R_PREFIXED_NAME_ESCAPELESS()
	@//@regex
	(@{R_PREFIX_ID()})? :
	(
		(?:
			@{R_CHAR_NO_CLOSERS()}
			(?:
				@{R_CHAR_NO_CLOSERS(';,')}*
				@{R_CHAR_NO_CLOSERS()}
			)?
		)?
	)
	(?:
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME_ESCAPELESS = /@{R_PREFIXED_NAME_ESCAPELESS()}/y;

@- B_OPTIMIZE_PAIRS
	const R_OPTIMIZED_PAIRS = /@{R_PREFIXED_NAME_ESCAPELESS()}@{R_PREFIXED_NAME_ESCAPELESS()}/y;
@;


@>> R_PREFIXED_NAME(b_lookahead=false)
	@//@regex
	(@{R_PREFIX_ID()})? :				@// 1: prefix id
	(											@// 2: prefix iri
		(?:
			(?:									@// firt name char
				@{R_CHAR_NO_CLOSERS()}			@// not invalid name char
				| @{R_ESCAPE_SEQUENCE()}		@// or an escape sequence
			)
			(?:									@// middle name chars
				(?:
					@{R_CHAR_NO_CLOSERS(';,')}	@// not invalid name chars
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)*
				(?:								@// last name char
					@{R_CHAR_NO_CLOSERS()}		@// not invalid name char
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)
			)?
		)?
	)
	@- b_lookahead
		(?:											@// consume trailing whitespace
			\s+
			| @{R_CONTENT_LOOKAHEAD()}
		)
	@;
@;

const R_PREFIXED_NAME = /@{R_PREFIXED_NAME(true)}/y;

const R_PN_LOCAL_ESCAPES = /\\(.)/g;

@// blank node labels
@>> R_BLANK_NODE_LABEL()
	@//@regex
	_:(.(?:[^\s:<;,)\]#@{QUADS? '}': ''}]*[^\s:<.;,)\]#@{QUADS? '}': ''}])?)
@;

const R_BLANK_NODE_LABEL = /@{R_BLANK_NODE_LABEL()}@{lookahead('blank_node')}/y;
const R_BLANK_NODE_LABEL_TERMINAL = /@{R_BLANK_NODE_LABEL()}@{lookahead('blank_node', '|(?=\\.[\\s@#<({[}])', '\\.?')}/y;

const R_IRIREF_ESCAPELESS = /<([^\\>]*)>\s*/y;
const R_IRIREF = /<([^>]*)>\s*/y;

const R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))(\.?[eE][+-]?[0-9]+)?)(?:\s+|(?=\.[^eE0-9]|[;,)\]]))/y;
const R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\s*/y;
const R_A = /a@{lookahead('predicate')}/y;

const R_DOUBLE_CARET = /\^\^/y;
const R_WS = /\s*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)@{lookahead('terminal')}/y;

const R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\s*/y;
const R_PREFIX_ID = /([^#:]*):\s*/iy;
const R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\s*/y;

@- TRIG
	const R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\s*<([^\\>]*)>\s*\{\s*/iy;
	const R_GRAPH_PREFIXED_NAME = /(?:graph)?\s*@{R_PREFIXED_NAME()}\s*\{\s*/iy;
	const R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\s*@{R_BLANK_NODE_LABEL()}\s*\{\s*/iy;
	const R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\s*\[\s*\]\s*\{\s*/iy;
	const R_GRAPH_IRI = /(?:graph)?\s*<([^>]*)>\s*\{\s*/iy;
	const R_GRAPH = /graph(?:\s+|(?=[#<[{]))/iy;
@;

const R_COMMENT = /(#[^\n]*\n\s*)+/y;

const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\-+]*:/;
const R_RELATIVE_URI = /^(\/[^?#]+)([?#].*)?$/;
@>> R_BASE_IRI()
	@//@regex
	^(								@// 1: uri
		(							@// 2: root
			([A-Za-z0-9.\-+]*:\/)?	@// 3: scheme
			\/[^/>]*				@// [authority]
		)?
		(							@// 4: path
			\/(?:[^/>]*\/)*
		)?
		[^>]*						@// [rest]
	)$
@;
const R_BASE_IRI = /@{R_BASE_IRI()}/;

const R_ANONYMOUS_BLANK_NODE = /\[\s*\]\s*/y;
const R_CHAR_BLANK_NODE = /\[(?:\s+|(?=[^\]]))/y;
const R_CHAR_COLLECTION = /\(\s*/y;

const R_CHAR_KET = /\]\s*/y

@- TRIG
	const R_CHAR_OPEN = /\{\s*/y;
	const R_CHAR_CLOSE = /\}\s*/y;
@;

const R_CHAR_STOP = /\.\s*/y;

@- !B_UPGRADE_FACTORY
	const KT_RDF_LANG_STRING = factory.namedNode('@{P_IRI_RDF}langString');
	const KT_RDF_TYPE = factory.namedNode('@{P_IRI_RDF}type');
	const KT_RDF_FIRST = factory.namedNode('@{P_IRI_RDF}first');
	const KT_RDF_REST = factory.namedNode('@{P_IRI_RDF}rest');
	const KT_RDF_NIL = factory.namedNode('@{P_IRI_RDF}nil');

	const KT_DEFAULT_GRAPH = factory.defaultGraph();
@;




@//	pre-escape sequence
@//	(?<!
@//		(?:
@//			[^\\] | ^
@//		)
@//		(?:\\\\)*
@//		\\
@//	)


@// const R_STRLIT_CONTENTS_ESCAPES_SOFT_OG = /\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8})|([^uU]))(?=[^])/g;


const R_STRLIT_SHORT_DOUBLE_BREAK = /[\\"\r\n]/g;
const R_STRLIT_SHORT_SINGLE_BREAK = /[\\'\r\n]/g;

const R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /"{1,2}$/g;
const R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;

const R_STRLIT_LONG_DOUBLE_BREAK = /(\\|""")/g;
const R_STRLIT_LONG_SINGLE_BREAK = /(\\|''')/g;

@{unescape_literals(true)}

const match_prefixed_name_quick = (s, i) => {
	R_PREFIXED_NAME_QUICK.lastIndex = i;
	return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
};

const match_prefixed_name_escapeless = (s, i) => {
	R_PREFIXED_NAME_ESCAPELESS.lastIndex = i;
	return [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];
};

const match_prefixed_name = (s, i) => {
	R_PREFIXED_NAME.lastIndex = i;
	return [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];
};

@// will only be used by TriG
@> emit_graph_open()
	this.emit('enter', this._kt_graph);
@;

@// will only be used by TriG
@> emit_graph_close()
	this.emit('exit', this._kt_graph);
@;


@// consume whitespace
@> whitespace(s_offset='0', b_local=false)
	// consume whitespace (and incidentally reset index)
	R_WS.lastIndex = @{s_offset};
	R_WS.exec(s);
	@{b_local? '': 'this.'}i = R_WS.lastIndex;
@;


@// assert the prefix found in prefixed name is valid
@> valid_prefix(match, n_group)
	@. let sj_var = `s_prefix_id${n_group? '_'+n_group: ''}`;

	// check valid prefix
	let @{sj_var} = @{match}[@{n_group || 1}] || '';

	@- B_OPTIMIZE_PREFIX_IDS
		// invalid prefix
		if(!(this._as_prefix_ids.has(@{sj_var}))) return this.error(`no such prefix "${@{sj_var}}"`);
	@:
		// invalid prefix
		if(!OPHOP.call(this._h_prefixes, @{sj_var})) return this.error(`no such prefix "${@{sj_var}}"`);
	@;
@;


@// extract uri from absolute / relative iri refs
@> iriref(sv_term, sv_match, b_object, b_set_base, b_has_escapes, b_not_this=false)
	@.{
		let sv_set = (b_not_this? '': ('this.'+(b_object? '_kt_': '_s_')))+sv_term;
		let set = b_object
			? s => `${sv_set} = this.check_named_node${b_has_escapes? '': '_escapeless'}(${s});`
			: s => `${sv_set} = ${s};`;
	}
	// ref iri
	let s_iri = @{sv_match}[1]@{b_has_escapes? `.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)`: ''};

	// absolute iri
	if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set @{sv_term}
		@{set(/* syntax: js */ `s_iri`)}
	}
	// relative iri
	else {
		@{set(/* syntax: js */ `uri.resolve(this._s_base_url, s_iri)`)}
	}

	@// update the base iri
	@- b_set_base
		let m_base_iri = R_BASE_IRI.exec(this._s_base_url);
		this._s_@{sv_term} = m_base_iri[1];
		this._s_@{sv_term}_root = m_base_iri[2] || '';
		this._s_@{sv_term}_scheme = m_base_iri[3] || '';
		this._s_@{sv_term}_path = m_base_iri[4] || ''; 
	@;
@;


@// set object value and datatype for numeric literal
@> numeric_literal()
	@- B_UPGRADE_FACTORY
		// it has exponent term, xsd:double
		if(m_numeric_literal[4]) {
			this._kt_object = this._dc_factory.double(m_numeric_literal[1]);
		}
		// contains decimal point, xsd:decimal
		else if(m_numeric_literal[2] || m_numeric_literal[3]) {
			this._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);
		}
		// otherwise, it is an integer
		else {
			this._kt_object = this._dc_factory.integer(m_numeric_literal[1]);
		}
	@:
		// it has exponent term, xsd:double
		if(m_numeric_literal[4]) {
			this._kt_object = factory.double(m_numeric_literal[1]);
		}
		// contains decimal point, xsd:decimal
		else if(m_numeric_literal[2] || m_numeric_literal[3]) {
			this._kt_object = factory.decimal(m_numeric_literal[1]);
		}
		// otherwise, it is an integer
		else {
			this._kt_object = factory.integer(m_numeric_literal[1]);
		}
	@;
@;

@// set object value and datatype for boolean literal
@> boolean_literal()
	@- B_UPGRADE_FACTORY
		// make literal
		this._kt_object = this._dc_factory.boolean(m_boolean_literal[1]? true: false);
	@:
		// make literal
		this._kt_object = factory.boolean(m_boolean_literal[1]? true: false);
	@;
@;


@// save current state to stack
@> push_state(state)
	this._a_nested.push([this._kt_subject, this._kt_predicate, '@{state}']);
@;

@// restore previous state from stack
@> pop_state()
	let s_resume_state;
	[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
	return this[s_resume_state]();
@;

@// change state
@> goto(s_method)
	return this.@{s_method}();
@;

@$ a_methods = [];

@// declare a parse state
@> method(s_name, b_extern)
	@.{
		a_methods.push(s_name);
	}

	// parse state for @{s_name}
	@- b_extern
		@{s_name}: () => {
	@:
		@{s_name}() {
	@;
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		@{s_name}: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
@;

@// end parse state method
@> end_method(s_name, max_token)
		}

		@- s_name
			// ran out of characters
			@{resume_state(s_name, false, max_token)}
		@;
	}
@;

@// set resume state & stop parsing in this stack
@> resume_state(s_state, b_use_field_chunk=false, s_max_token=null)
	// update index value
	this.i = i;

	// not yet eos
	if(i < this.n) {
		// expected token was not found
		if(0 === i) {
			// we've exceeded the maximum token length
			if(this.n > this.@{s_max_token || 'max_token_length'}) {
				return this.parse_error('@{s_state}');
			}
		}
	}

	// save state before pausing
	this._f_state = this.@{s_state};

	// store what is unparsed
	this.pre = @{b_use_field_chunk? 'this.' :''}s.slice(i);

	// if we're not parsing a stream, then this is an error
	if(this.eos) this.eos();
	return;
@;

@// emit a statement event to listener using current subject/predicate/object
@> emit_statement()
	@- B_UPGRADE_FACTORY
		this.data();
	@:
		this.data(quad(this));
	@;
@;

@// extract name from suffix
@> suffix(term)
	// escape local escapes
	let s_suffix = @{term}[2]
		.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
		.replace(R_PN_LOCAL_ESCAPES, '$1');
@;


@// set the object value of a string literal
@> set_string_literal(match, version)
	@- B_UPGRADE_FACTORY
		this._s_literal =
	@:
		// set literal value
		h_literal.value = 
	@;
	@- 'no-escape' === version
		@{match}[1];
	@:
		this.unescape_literal_@{'long'===version? 'long': 'short'}(@{match}[1]);
	@;
@;

@> full_stop()
	if(this._b_expecting_full_stop) {
		// change state
		@{goto('full_stop')}
	}
@;

@// emit statement and return control to whatever function asked for it
@> end_of_statement()
	// at this point, a new statement has been parsed
	@{emit_statement()}

	// goto next parsing state; bail out of stack
	return this.after_end_of_statement;
@;

@.{/*
// instead of putting this in a macro to be unrolled at every IRI resolution,
// ... spare the monstrosity from the source and make it a function
const F_DOT_SEGMENTS = (s_rel_iri) => {
	let m_rel_iri = R_RELATIVE_URI.exec(s_rel_iri);
	if(!m_rel_iri) return s_rel_iri;
	let [, s_iri, s_qs_hash] = m_rel_iri;

	let a_segments = s_iri.split('/');
	let a_output = [];
	let b_empty = true;

	for(let i=0; i<a_segments.length; i++) {
		let s_segment = a_segments[i];
		b_empty = false;

		// up a hierarchical level
		if('..' === s_segment) {
			if(a_output.length > 1) {
				a_output.pop();
				if(i === a_segments.length-1) {
					a_output.push('');
				}
			}
		}
		// down a level level
		else if('.' !== s_segment && (s_segment || !i || i === a_segments.length-1)) {
			a_output.push(s_segment);
		}
		// special case
		else if('.' === s_segment && i === a_segments.length-1) {
			a_output.push('');
		}
	}

	return a_output.join('/')+(s_qs_hash || '');
};
*/}

function Reader$syntax_error(k_self, i, si_state, s_info) {
	let i_off = Math.min(i, Math.abs(i-15));

	let s = k_self.s;

	return k_self.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
		+` ${' '.repeat(i-i_off)}^\n`
		+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
}


@- TTL
	@$ S_STATE_PRIMARY = 'statement';
@:
	@$ S_STATE_PRIMARY = 'block';
@;

class @{S_LABEL}_Reader extends stream.Transform {
	constructor(g_impls) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			// output quad objects on readable side
			readableObjectMode: true,

			// implementations
			flush: g_impls.flush,
			transform: g_impls.transform,
		});
	}

	// intercept pipe
	pipe(ds_out) {
		let ds_dst = ds_out;

		// non-object mode
		if(!ds_dst._writableState.objectMode) {
			// transform to JSON
			ds_out = stream.quads_to_json();
		}
		// yet object mode and graphy writable
		else if(ds_out.isGraphyWritable) {
			// transform to writable data events
			ds_out = stream.quads_to_writable();
		}

		// interim stream created
		if(ds_out !== ds_dst) {
			// forward output to super
			super.pipe(ds_out);

			// pipe outpu to destination
			return ds_out.pipe(ds_dst);
		}
		// forward as-is to super
		else {
			return super.pipe(ds_dst);
		}
	}
}


class Reader {
	constructor(g_config={}) {
		// impl-specific configs
		let {
			// input medium
			input: g_input=null,

			// a state to inherit
			state: g_state={},
		} = g_config;

		// inherit state from creator
		let {
			// index for anonymous blank node labels
			blank_node_index: i_anon=0,

			// prefix map
			prefixes: h_prefixes={},

			// blank node label map
			labels: h_labels={},
		} = g_state;


		@- B_UPGRADE_FACTORY
			let dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);

			let kt_default_graph = dc_factory.defaultGraph();

			// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()
			if(dc_factory !== factory.unfiltered) {
				// do not trust it, create a new object
				kt_default_graph = Object.create(kt_default_graph);
			}

			let kt_rdf_first = dc_factory.namedNode('@{P_IRI_RDF}first');

			let blankNode = dc_factory.blankNode;
			let namedNode = dc_factory.namedNode;

			this.emit_data = factory.unfiltered === dc_factory
				? function() {
					ds_transform.push(quad(this));
				}
				: function() {
					let g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
					ds_transform.push(g_quad);
				};
		@:
			let blankNode = factory.blankNode;
			let namedNode = factory.namedNode;

			this.emit_data = function(g_quad) {
				this.transform.push(g_quad);
			};
		@;

		// fields
		Object.assign(this, {
			// read index
			i: 0,

			// string buffer
			s: '',

			// string buffer length
			n: 0,

			// left-over string from previous data chunk
			pre: g_config.prepend || '',

			// debug state
			_b_debug: g_config.debug || false,

			// relax
			_b_relax: g_config.relax || false,

			@- B_UPGRADE_FACTORY
				// factory
				_dc_factory: dc_factory,
			@;

			// current reader state
			_f_state: this.@{S_STATE_PRIMARY},

			// map of current prefix ids => iris
			_h_prefixes: h_prefixes,

			@- B_OPTIMIZE_PREFIX_IDS
				// set of current prefix ids
				_as_prefix_ids: new Set(Object.keys(h_prefixes)),
			@;

			// reader was destroyed by an error
			_b_destroyed: false,

			// current @base url
			_s_base_url: '',
			_s_base_url_scheme: '',
			_s_base_url_root: '',
			_s_base_url_path: '',

			// current data
			_kt_subject: null,
			_kt_predicate: @{B_UPGRADE_FACTORY? 'kt_rdf_first': 'KT_RDF_FIRST'},
			_kt_object: null,
			_kt_graph: @{B_UPGRADE_FACTORY? 'kt_default_graph': 'KT_DEFAULT_GRAPH'},
			_s_literal: '',

			@- B_UPGRADE_FACTORY
				// static terms
				_kt_rdf_type: dc_factory.namedNode('@{P_IRI_RDF}type'),
				_kt_rdf_first: kt_rdf_first,
				_kt_rdf_rest: dc_factory.namedNode('@{P_IRI_RDF}rest'),
				_kt_rdf_nil: dc_factory.namedNode('@{P_IRI_RDF}nil'),
				_kt_default_graph: kt_default_graph,
			@;

			// queue of nested subject, predicate, state for blanknodes and collections
			_a_nested: [],

			// hash to keep track of all blank node labels in use
			_h_labels: h_labels,

			// event routing
			event: this.emit,
			data: this.emit_data,

			// for restoring the original event callback when resuming paused stream
			restore_data: this.emit_data,

			// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)
			_a_queue_event: [],

			// helper states
			_b_expecting_full_stop: false,
			_s_temp_prefix_id: null,
			_b_trim_start: true,

			anonymous_blank_node: s_label => blankNode(s_label, true),

			// finds the next non-conflicting blank node label
			next_label() {
				let s_label = '';
				do {
					s_label = 'g'+(i_anon++);
				} while(this._h_labels[s_label]);

				// claim this label, and remember that we invented it
				this._h_labels[s_label] = 2;

				// return the label
				return s_label;
			},

			// what to do when reach eos
			eos: null,

			// which state to go to after end of statement
			after_end_of_statement: this.post_object,

			// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160
			_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,

			// maximum length of a string (overrides max_token_length): defaults to Infinity
			_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,

			// byte tracking
			_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,
			_nb_seen: 0,
			_nb_last: 0,
			_nb_curr: 0,
		});

	if(g_config.relaxed) {
		console.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));
	}
	if('validate' in g_config) {
		console.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));
	}


@// ensure there are no conflicting blank node labels
@> no_label_conflict()
	// not first time use of label
	let z_label_state = this._h_labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this._h_labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this._h_labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this._h_labels[s_label] = 1;
	}
@;

		// term constructors
		Object.assign(this, !g_config.relax
			? {
				blank_node(s_label) {
					// test valid blank node label
					if(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: "${s_label}"`);

					@// check for conflicts
					@{no_label_conflict()}

					// make term
					return blankNode(s_label);
				},

				check_named_node(p_iri) {
					if(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: "${p_iri}"`);
					return namedNode(p_iri);
				},

				check_named_node_escapeless(p_iri) {
					if(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: "${p_iri}"`);
					return namedNode(p_iri);
				},

				match_prefixed_name_quick(s, i) {
					R_PREFIXED_NAME_QUICK.lastIndex = i;
					return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
				},

				match_prefixed_name_escapeless(s, i) {
					let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
					if(m_prefixed_name_e) {
						@// no need to check namespace since it was validated during declaration
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name_e, im_prefixed_name_e];
				},

				match_prefixed_name(s, i) {
					let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
					if(m_prefixed_name) {
						@// no need to check namespace since it was validated during declaration
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name, im_prefixed_name];
				},
			}
			: {
				// term constructors
				blank_node(s_label) {
					@// check for conflicts
					@{no_label_conflict()}

					// make term
					return blankNode(s_label);
				},

				check_named_node: namedNode,

				check_named_node_escapeless: namedNode,

				match_prefixed_name_escapeless,

				match_prefixed_name,
			});


		this.named_node = namedNode;

		this.prefixed_name = function(si_prefix, s_suffix) {
			return namedNode(h_prefixes[si_prefix] + s_suffix);
		};


		// oops -- user passed string into `base`
		if('string' === typeof g_config.base) {
			throw new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\n`
				+`did you mean to use the 'base_uri' key instead?`)
		}

		// base uri
		let p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;
		if(p_set_base_uri) {
			let m_base_iri = R_BASE_IRI.exec(p_set_base_uri);
			this._s_base_url = m_base_iri[1];
			this._s_base_url_root = m_base_iri[2] || '';
			this._s_base_url_scheme = m_base_iri[3] || '';
			this._s_base_url_path = m_base_iri[4] || ''; 
		}
		// not set; 'url' variant is
		else if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {
			throw new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);
		}

		// transform stream
		let ds_transform = this.transform = new @{S_LABEL}_Reader({
			// on data event
			transform: (s_chunk, s_encoding, fke_chunk) => {
				// concatenate current chunk to previous chunk
				let s = this.s = this.pre + s_chunk;

				// cache chunk length
				this.n = s.length;

				// eat whitespace before token and reset index
				if(this._b_trim_start) {
					@{whitespace()}
				}
				// do not eat whitespace; start at beginning
				else {
					this.i = 0;
				}

				// resume parsing; no errors
				if(this.safe_parse(true)) {
					// emit progress event updates
					ds_transform.emit('progress', s_chunk.length);

					// done transforming this chunk
					fke_chunk();
				}
			},

			// once there's no more data to consume, invoke eof
			flush: (fke_flush) => {
				// now that input stream has ended, clean up remainder
				try {
					this.eof(1);
				}
				// read error occurred
				catch(e_eof) {
					// destroy self and stream
					this.destroy(e_eof);

					// exit gracefully
					return;
				}

				// no errors. done flushing, close read stream
				fke_flush();
			},
		});

		// when the writable side is piped into
		ds_transform.on('pipe', (ds_input) => {
			this._ds_input = ds_input;

			let b_byte_tracking = this._b_byte_tracking;

			// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8
			if(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {
				ds_input.setEncoding('utf8');
			}
			// set decoding on write
			else {
				let f_write = ds_transform.write;
				let d_decoder = new string_decoder.StringDecoder('utf8');

				let f_write_track = (s_chunk, s_encoding, fk_write) => {
					// TODO: optimize by testing for multibyte chars and using string length instead?
					let nb_chunk = Buffer.from(s_chunk, 'utf8').length;
					this._nb_seen += nb_chunk;
					this._nb_last = nb_chunk;
					return f_write.call(ds_transform, s_chunk, s_encoding, fk_write);
				};

				let f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {
					let nb_chunk = this._nb_last = ab_chunk.length;
					this._nb_seen += nb_chunk;
					return f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);
				};

				let f_decode_write = (ab_chunk, s_encoding, fk_write) => {
					return f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);
				};

				ds_transform.write = function(z_chunk, s_encoding, fk_write) {
					// not null
					if(null !== z_chunk) {
						// chunk is string; adapt by resetting method to original
						if('string' === typeof z_chunk) {
							ds_transform.write = b_byte_tracking? f_write_track: f_write;
						}
						// chunk is buffer; adapt by setting decoder write method
						else {
							ds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;
						}

						// use set method
						return ds_transform.write(z_chunk, s_encoding, fk_write);
					}

					// null, use parent
					return f_write.call(ds_transform, z_chunk, s_encoding, fk_write);
				};

				// byte tracking is enabled
				if(b_byte_tracking) {
					// overwrite emit_data method
					this.emit_data = this.data = this.restore_data = function(@{B_UPGRADE_FACTORY? '': 'g_quad'}) {
						@- B_UPGRADE_FACTORY
							let g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
						@;
						let nb_post = Buffer.from(this.s.slice(this.i)).length;
						let ib_post = this._nb_seen - nb_post;
						g_quad.byteRange = [this._nb_curr, ib_post];
						this._nb_curr = ib_post;
						this.transform.push(g_quad);
					};
				}
			}
		});

		// new listener added
		ds_transform.on('newListener', (s_event) => {
			// comment
			if('comment' === s_event) {
				this.emit_comments = (s_captured) => {
					let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

					for(let s_comment of a_comments) {
						ds_transform.emit('comment', s_comment);
					}
				};
			}
		});

		// destroy
		ds_transform._destroy = (...a_args) => {
			this.destroy(...a_args);
		};

		// bind events to transform stream
		this.bind(g_config);

		// input given
		if(g_input) {
			// input is stream
			if(g_input.stream) {
				let ds_input = g_input.stream;

				// go async so caller has chance to bind event listeners
				queueMicrotask(() => {
					ds_input.pipe(ds_transform);
				});
			}
			// string
			else if('string' === typeof g_input.string) {
				let s_input = g_input.string;

				// go async so caller has chance to bind event listeners
				queueMicrotask(() => {
					ds_transform.end(s_input, 'utf8');
				});
			}
			// invalid arg
			else {
				throw new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);
			}
		}
	}

	// begin parsing, keep applying until no more stack bail-outs
	safe_parse() {
		try {
			let f_sync = this._f_state();
			while('function' === typeof f_sync) {
				f_sync = f_sync.apply(this);
			}
		}
		// read error occurred
		catch(e_read) {
			// destroy self and stream
			this.destroy(e_read);

			// failure
			return false;
		}
		
		// okay
		return true;
	}

@//	emit_data(@{B_UPGRADE_FACTORY? '': 'g_quad'}) {
@//		@- B_UPGRADE_FACTORY
@//			let g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
@//		@;
@//		this.transform.push(g_quad);
@//	}

	emit(s_event, ...a_args) {
		this.transform.emit(s_event, ...a_args);
	}

	queue(s_event, ...a_args) {
		this._a_queue_event.push({
			event: s_event,
			args: a_args,
		});
	}

	error(s_message) {
		// bail out
		throw new Error(s_message);
	}

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof=false) {
		let i = this.i;

		let i_off = Math.min(i, Math.abs(i-15));

		let s = this.s;

		return this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	}

	info_error(s_message) {
		let i = this.i;

		let i_off = Math.min(i, Math.abs(i-15));

		let s = this.s;

		this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+s_message);
	}

	// end of file
	eof() {
		// there are events queued
		if(this._a_queue_event.length) {
			let a_queue = this._a_queue_event;

			// drain event queue
			while(a_queue.length) {
				// remove event from front of queue
				let h_event = a_queue.shift();

				// make event callback
				this[h_event.event](h_event.data);
			}
		}

		// invalid parsing state
		if(this.@{S_STATE_PRIMARY} !== this._f_state) {
			// append EOF char
			this.s += '\0';

			// exit "flowing" mode
			this.n = this.s.length;

			// resume parsing; no errors
			if(this.safe_parse()) {
				// eof has occurred under safe parse
				if(null === this.s) return;

				// still invalid parsing state
				if(this.@{S_STATE_PRIMARY} !== this._f_state) {
					return this.parse_error(this._f_state.name, true);
				}
			}
		}

		// there are still unparsed characters
		if(this.i < this.n) {
			// consume whitespace and comments
			let s = this.s;
			let i = this.i;
			@{whitespace('i', true)}
			R_COMMENT.lastIndex = i;
			let m_comment = R_COMMENT.exec(s);

			// advance beyond comment
			if(R_COMMENT.lastIndex > i) {
				this.i = i = R_COMMENT.lastIndex;
				if(this.emit_comments) this.emit_comments(m_comment[0]);
			}

			// still unparsed characters
			if(i < this.n) {
				// not EOF
				if(!(i === this.n - 1 && '\0' === s[i])) {
					// bad input; parse error
					return this.parse_error(this._f_state.name);
				}
			}
		}

		// make buffer's alloc eligible for gc
		this.s = null;

		// transform stream
		let ds_transform = this.transform;

		// final progress update: no additional bytes were read
		ds_transform.emit('progress', 0);

		// call end event listener
		ds_transform.emit('eof', this._h_prefixes);

		// close write stream (EOF-signaling)
		ds_transform.push(null);
	};



@$ H_PARSE_EVENTS = {
	base: {},
	prefix: {},
	...(QUADS
		? {
			enter: {},
			exit: {},
		}
		: {}),
	comment: {},
	error: {},
	read: {once:true},
	progress: {},
	eof: {once:true},
	end: {once:true},
	finish: {once:true},
	data: {},  // attach data listener last
};

	// bind event listeners to transform stream
	bind(g_config) {
		let ds_transform = this.transform;
		@*{
			for(let [s_event, g_event] of Object.entries(H_PARSE_EVENTS)) {
				yield /* syntax: js */ `
					if(g_config.${s_event}) ds_transform.${g_event.once? 'once': 'on'}('${s_event}', g_config.${s_event});
					`.trim()+'\n';
			}
		}
	}

	// after a blank node subject (either property-list or colleciton)
	post_blank_subject() {
		let {s, i} = this;
		if('.' === s[i]) {
			@{whitespace('i+1')}

			@-QUADS
				// not inside block
				if(@{SJ_DEFAULT_GRAPH} === this._kt_graph) {
					@{goto('block')}
				}
				// inside block
				else {
					@{goto('statement')}
				}
			@:
				@{goto('statement')}
			@;
		@- QUADS
			@{else_if_match('R_CHAR_CLOSE')}
				// empty collection
				if(@{terms_equal(SJ_RDF_NIL, 'this._kt_subject')}) {
					return this.error('empty collection');
				}

				// emit graph_close event
				@{emit_graph_close()}

				// reset graph
				this._kt_graph = @{SJ_DEFAULT_GRAPH};

				// goto block state
				@{goto('block')}
			@{end_else()}
		@:
			}
		@;
		@{goto('pairs')}
	}
	@. a_methods.push('post_blank_subject');

	@// regexes are faster than character[0] switching in this context
	@{method('statement')}
		@//@

		// prefixed name quick
		@{if_match('R_PREFIXED_NAME_QUICK', 'm_pnq_subject')}
			@{valid_prefix('m_pnq_subject')}

			// commit subject iri from resolve prefixed name
			this._kt_subject = @{prefixed_name('s_prefix_id', 'm_pnq_subject[2]')};

			// predicate-object pairs state
			@{goto('pairs')}

		// iriref
		@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_subject')}
			@{iriref('subject', 'm_iriref_e_subject', true)}

			// predicate-object pairs state
			@{goto('pairs')}

		@// sub-macro for reusing statement productions
		@def triples(directives=false)
			@.{
				let gtg = () => goto('pairs');
				if(directives) {
					gtg = (s_alt='graph_or_subject') => goto(s_alt);
				}
			}

			// prefixed name
			@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_subject')}

				@{valid_prefix('m_prefixed_named_e_subject')}

				// make subject key
				this._kt_subject = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_subject[2]')}

				// predicate-object pairs state
				@{gtg()}

			// blank node label
			@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_subject')}
				// extract label
				let s_label = m_blank_node_label_subject[1];

				// make subject key
				this._kt_subject = this.blank_node(s_label);

				// predicate-object pairs state
				@{gtg()}

			// anonymous blank node subject
			@{else_if_match('R_ANONYMOUS_BLANK_NODE')}
				// set new blank node as subject
				this._kt_subject = this.anonymous_blank_node(this.next_label());

				// goto pairs state for inside property list
				@{gtg()}

			// anonymous blank node property list subject
			@{else_if_match('R_CHAR_BLANK_NODE')}
				// enter blank node
				this._kt_subject = this.anonymous_blank_node(this.next_label());

				// how to resume when we pop state
				@{push_state('post_blank_subject')}

				// goto pairs state for inside property list
				@{gtg('graph_or_subject_property_list')}

			@//@ this token can only be a subject, skip graph check
			// rdf collection
			@{else_if_match('R_CHAR_COLLECTION')}
				// indicate that collection subject should emit an initial statement
				this._kt_subject = null;
				
				// (don't push state, we don't have a subject yet)

				// goto collection-subject state
				@{goto('collection_subject')}

			@- TTL || directives
				// prefix with interupt (e.g., a comment)
				@{else_if_match('R_PREFIX_KEYWORD', 'm_prefix_keyword')}
					// save whether or not to expect a full stop
					this._b_expecting_full_stop = m_prefix_keyword[1]? true: false;

					// goto prefix state
					@{goto('prefix_id')}

				// base with interupt (e.g., a comment)
				@{else_if_match('R_BASE_KEYWORD', 'm_base_keyword')}
					// save whether or not to expect a full stop
					this._b_expecting_full_stop = m_base_keyword[1]? true: false;

					// goto base state
					@{goto('base_iri')}
			@;

			@- TRIG && !directives
				// closing graph '}'
				@{else_if_match('R_CHAR_CLOSE')}
					// emit graph_close event
					@{emit_graph_close()}

					// reset graph
					this._kt_graph = @{SJ_DEFAULT_GRAPH};

					// goto block state
					@{goto('block')}
			@;

			// iriref
			@{else_if_match('R_IRIREF', 'm_iriref_subject')}
				@{iriref('subject', 'm_iriref_subject', true, false, true)}

				// predicate-object pairs state
				@{gtg()}

			// prefixed name
			@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_subject')}
				@{valid_prefix('m_prefixed_named_subject')}

				@{suffix('m_prefixed_named_subject')}

				// make subject key
				this._kt_subject = @{prefixed_name('s_prefix_id', 's_suffix')};

				// predicate-object pairs state
				@{gtg()}
		@;

		@{triples()}

		@// dead code
		@// @// for trig only
		@// @- TRIG
		@// 	@{else_if_match('R_CHAR_CLOSE')}
		@// 		this._kt_graph = @{SJ_DEFAULT_GRAPH};
		@// 		@{goto('block')}
		@// @;

		// comment
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		// not iriref, not prefixed name, not blank node label, not prefix id, not base
		@{else_retry()}

	@{end_method('statement')}

	@- TRIG
		@{method('block')}

			@{if_match('R_GRAPH_IRI_ESCAPELESS', 'm_graph_iriref_e_graph')}
				@{iriref('graph', 'm_graph_iriref_e_graph', true)}

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_PREFIXED_NAME', 'm_graph_prefixed_name')}
				@{valid_prefix('m_graph_prefixed_name')}

				// make subject key
				this._kt_graph = @{prefixed_name('s_prefix_id', 'm_graph_prefixed_name[2]')};

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_CHAR_OPEN')}
				@- B_UPGRADE_FACTORY
					// make new default graph
					this._kt_graph = this._dc_factory.defaultGraph();
				@:
					// make new default graph
					this._kt_graph = factory.defaultGraph();
				@;

				@{emit_graph_open()}

				// goto statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_ANONYMOUS_BLANK_NODE', 'm_graph_anonymous_blank_node')}
				// make new label & set graph to blank node
				this._kt_graph = this.anonymous_blank_node(this.next_label());

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_LABELED_BLANK_NODE', 'm_graph_labeled_blank_node')}
				let s_label = m_graph_labeled_blank_node[1];

				this._kt_graph = this.blank_node(s_label);

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			// iriref
			@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_graph_subject')}
				@{iriref('subject', 'm_iriref_e_graph_subject', true)}

				// graph or subject
				@{goto('graph_or_subject')}

			@// try triples productions
			@{triples(true)}

			@// then try other graph keywords
			@{else_if_match('R_GRAPH_IRI', 'm_graph_iriref_graph')}
				@{iriref('graph', 'm_graph_iriref_graph', true, false, true)}

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			@{else_if_match('R_GRAPH')}
				@{goto('graph_keyword')}

			// not iriref, not prefixed name, not blank node label, not prefix id, not base
			@{else_retry()}

		@{end_method('block')}


		@{method('graph_or_subject')}
			let x = s[i];

			@{if_char('{')}
				@{whitespace('i+1')}

				// shift placeholder subject
				this._kt_graph = this._kt_subject;

				@{emit_graph_open()}

				// reset subject in case of collections
				this._kt_subject = null;

				// statement state
				@{goto('statement')}

			// non-comment
			@{else_if_not_char('#')}
				@{goto('pairs')};

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			@{else_retry()}

		@{end_method('graph_or_subject')}


		@{method('graph_or_subject_property_list')}
			let x = s[i];

			@{if_char(']')}
				@{whitespace('i+1')}

				// next state
				@{goto('graph_or_subject_anon')}

			// non-comment
			@{else_if_not_char('#')}
				@{goto('pairs')};

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			@{else_retry()}
		@{end_method('graph_or_subject_property_list')}


		@{method('graph_or_subject_anon')}
			let x = s[i];

			@{if_char('{')}
				@{whitespace('i+1')}

				// shift placeholder subject
				this._kt_graph = this._kt_subject;

				@{emit_graph_open()}

				// reset subject in case of collections
				this._kt_subject = null;

				// pop dummy state
				this._a_nested.pop();

				// statement state
				@{goto('statement')}

			// non-comment
			@{else_if_not_char('#')}
				@{goto('pairs')};

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			@{else_retry()}
		@{end_method('graph_or_subject_anon')}


		@{method('graph_keyword')}

			// prefixed name
			@{if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_graph')}

				@{valid_prefix('m_prefixed_named_e_graph')}

				// make subject key
				this._kt_graph = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_graph[2]')};

				// predicate-object pairs state
				@{goto('graph_post_name')}

			// iriref
			@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_graph')}
				@{iriref('graph', 'm_iriref_e_graph', true)}

				// graph
				@{goto('graph_post_name')}

			// blank node label
			@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_graph')}
				// extract label
				let s_label = m_blank_node_label_graph[1];

				// make graph key
				this._kt_graph = this.blank_node(s_label);

				// predicate-object pairs state
				@{goto('graph_post_name')}

			// anonymous blank node graph
			@{else_if_match('R_ANONYMOUS_BLANK_NODE')}
				// set new blank node as graph
				this._kt_graph = this.anonymous_blank_node(this.next_label());

				// goto pairs state for inside property list
				@{goto('graph_post_name')}

			// iriref
			@{else_if_match('R_IRIREF', 'm_iriref_graph')}
				@{iriref('graph', 'm_iriref_graph', true, false, true)}

				// predicate-object pairs state
				@{goto('graph_post_name')}

			// prefixed name
			@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_graph')}
				@{valid_prefix('m_prefixed_named_graph')}

				@{suffix('m_prefixed_named_graph')}

				// make subject key
				this._kt_graph = @{prefixed_name('s_prefix_id', 's_suffix')};

				// predicate-object pairs state
				@{goto('graph_post_name')}

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			// not iriref, not prefixed name, not blank node label, not prefix id, not base
			@{else_retry()}

		@{end_method('graph_keyword')}


		@{method('graph_post_name')}
			let x = s[i];

			@{if_char('{')}
				@{whitespace('i+1')}

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			// comment
			@{else_if_match('R_COMMENT', 'm_comment', true)}
				if(this.emit_comments) this.emit_comments(m_comment[0]);
				continue;

			@{else_retry()}

		@{end_method('graph_post_name')}
	@;


	@{method('pairs')}
		// benchmarks indicate: regex for end of blank node property list faster than ch

		@- B_OPTIMIZE_PAIRS
			// optimize
			@{if_match('R_OPTIMIZED_PAIRS', 'm_prefixed_named_pairs')}
				@{valid_prefix('m_prefixed_named_pairs', 1)}
				@{valid_prefix('m_prefixed_named_pairs', 3)}

				// make predicate key
				this._kt_predicate = @{prefixed_name('s_prefix_id_1', 'm_prefixed_named_pairs[2]')};

				// make object
				this._kt_object = @{prefixed_name('s_prefix_id_3', 'm_prefixed_named_pairs[4]')};

				//
				@{goto('post_object')}

			// iriref
			@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_predicate')}
				@{iriref('predicate', 'm_iriref_e_predicate', true)}

				// object-list state
				@{goto('object_list')}
		@:
			// iriref
			@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_predicate')}
				@{iriref('predicate', 'm_iriref_e_predicate', true)}

				// object-list state
				@{goto('object_list')}
		@;

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_predicate')}
			@{valid_prefix('m_prefixed_named_e_predicate')}

			// make predicate key
			this._kt_predicate = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_predicate[2]')};

			// object-list state
			@{goto('object_list')}

		// 'a'
		@{else_if_match('R_A')}
			// make predicate key
			this._kt_predicate = @{SJ_RDF_TYPE};

			// object-list state
			@{goto('object_list')}

		// ']' end of blank node property list
		@{else_if_match('R_CHAR_KET')}
			@{pop_state()}

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_predicate')}
			@{iriref('predicate', 'm_iriref_predicate', true, false, true)}

			// object-list state
			@{goto('object_list')}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_predicate')}
			@{valid_prefix('m_prefixed_named_predicate')}

			@{suffix('m_prefixed_named_predicate')}

			// make predicate key
			this._kt_predicate = @{prefixed_name('s_prefix_id', 's_suffix')};

			// object-list state
			@{goto('object_list')}


		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		// not iriref, not prefixed name, not 'a'
		@{else_retry()}

	@{end_method('pairs')}


	@> deduce_strlit_path(s_mode)
		@. let sj_char = 'single' === s_mode? `"'"`: `'"'`;
		// enough chars to deduce type
		if((i+2) < n) {
			// long type
			if(@{sj_char} === s[i+1] && @{sj_char} === s[i+2]) {
				// advance index beyond token
				this.i = i + 3;

				// read contents
				@{goto('string_literal_long_'+s_mode)}
			}
			// not long type
			else {
				// advance index beyond token
				this.i = i + 1;

				// read contents
				@{goto('string_literal_short_'+s_mode)}
			}
		}
		// enough chars to eliminate long type
		else if((i+1) < n && @{sj_char} !== s[i+1]) {
			// advance index beyond token
			this.i = i + 1;

			// read contents
			@{goto('string_literal_short_'+s_mode)}
		}
		// not enough chars to deduce type; retry next chunk
		else {
			break;
		}
	@;

	@{method('object_list')}
		// ref char
		let x = s[i];

		// string literal * double
		@{if_char('"')}
			@{deduce_strlit_path('double')}

		// prefixed name quick
		@{else_if_match('R_PREFIXED_NAME_QUICK', 'm_pnq_object')}
			@{valid_prefix('m_pnq_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 'm_pnq_object[2]')};

		// iriref
		@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object')}
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object')}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_object[2]')};

		// string literal * single
		@{else_if_char("'")}
			@{deduce_strlit_path('single')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal')}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal')}
			@{boolean_literal()}

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// make object
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

			// emit statement event
			@{emit_statement()}

			// push state to stack
			@{push_state('post_object')}

			// set new subject
			this._kt_subject = kt_blank_node;

			// goto parsing pairs state
			@{goto('pairs')}

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL_TERMINAL', 'm_blank_node_label_object')}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make object
			this._kt_object = this.blank_node(s_label);

		// collection
		@{else_if_char('(')}
			// advance index to next token
			@{whitespace('i+1')}

			// state to resume after collection ends
			@{push_state('post_object')}

			// goto collection-object state
			@{goto('collection_object')}

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object')}
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object')}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 's_suffix')};

		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		// rdf-star
		@{else_if_char('<<')}
			// advance to next token
			@{whitespace('i+2')}

			// 
			@{push_state('triple_x')}

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry()}

		// fall through for cases that did not change state on their own
		@{end_of_statement()}
	@{end_method('object_list')}


	@> string_literal_short(s_mode)
		@{method('string_literal_short_'+s_mode)}
			// something breaks string in this chunk
			@{if_match(`R_STRLIT_SHORT_${s_mode.toUpperCase()}_BREAK`, 'm_break')}
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case @{'single' === s_mode? `"'"`: `'"'`}: {
						// advance index to next token beyond delimiter
						@{whitespace('i_break + 1')}

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						@{goto('datatype_or_langtag')}
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_SHORT_@{s_mode.toUpperCase()}_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_SHORT_@{s_mode.toUpperCase()}_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_short_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							@{goto('datatype_or_langtag')}
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_short_@{s_mode};
						}
					}

					// invalid '\n'
					case '\n': {
						return this.info_error(`expected string_literal_short_@{s_mode} but invalid line feed character '\\n' (newline) within contents. failed to parse a valid token`);
					}

					// invalid '\r'
					case '\r': {
						return this.info_error(`expected string_literal_short_@{s_mode} but invalid form feed character '\\r' (carriage return) within contents. failed to parse a valid token`);
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_@{s_mode}`);
					}
				}

			// no terminator and nothing to escape
			@{else_any()}
				// save
				this._s_literal += i? s.slice(i): s;

				// set unparsed index
				i = n;

				// reached eos; pause normally
				break;

			@{end_else()}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

		// ran out of characters
		@{resume_state('string_literal_short_'+s_mode, false)}
	}
	@;


	@{string_literal_short('double')}

	@{string_literal_short('single')}



	@> string_literal_long(s_mode)
		@{method('string_literal_long_'+s_mode)}
			// something breaks string in this chunk
			@{if_match(`R_STRLIT_LONG_${s_mode.toUpperCase()}_BREAK`, 'm_break')}
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case @{'single' === s_mode? `"'"`: `'"'`}: {
						// advance index to next token beyond delimiter
						@{whitespace('i_break + 3')}

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						@{goto('datatype_or_langtag')}
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_LONG_@{s_mode.toUpperCase()}_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_LONG_@{s_mode.toUpperCase()}_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_long_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							@{goto('datatype_or_langtag')}
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_long_@{s_mode};
						}
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_@{s_mode}`);
					}
				}

			// no terminator and nothing to escape
			@{else_any()}
				// could be unfinished terminator
				R_STRLIT_LONG_@{s_mode.toUpperCase()}_UNFINISHED_TERM.lastIndex = i;
				let m_unfinished = R_STRLIT_LONG_@{s_mode.toUpperCase()}_UNFINISHED_TERM.exec(s);

				// unfinished terminator
				if(m_unfinished) {
					// save valid portion
					this._s_literal += s.slice(i, m_unfinished.index);

					// set unparsed index
					i = m_unfinished.index;
				}
				// not unfinished
				else {
					// save
					this._s_literal += i? s.slice(i): s;

					// set unparsed index
					i = n;
				}

				// reached eos; pause normally
				break;

			@{end_else()}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

		// ran out of characters
		@{resume_state('string_literal_long_'+s_mode, false)}
	}
	@;


	@{string_literal_long('double')}

	@{string_literal_long('single')}


	@//@ do not risk deducing type in certain states, defer to own string literal state
	@{method('string_literal')}
		// ref character
		let x = s[i];

		// string literal * double
		@{if_char('"')}
			@{deduce_strlit_path('double')}
			
		// string literal * single
		@{else_if_char("'")}
			@{deduce_strlit_path('single')}

		// not string literal long single quote, not string literal single quote
		@{else_retry()}

@// this is disabled since string literal handled in own state
@//		// complete literal
@//		@{goto('datatype_or_langtag')}
	@{end_method('string_literal', 'max_string_length')}



	@{method('datatype_or_langtag')}
		// ref character
		let x = s[i];

		// next token indicates datatype or langtag
		@{if_char('^', '@')}
			// '^^' datatype
			@{if_match('R_DOUBLE_CARET')}
				@{goto('datatype')}

			// '@' language tag
			@{else_if_match('R_LANGTAG', 'm_langtag')}
				@- B_UPGRADE_FACTORY
					this._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);

					// reset literal
					this._s_literal = '';
				@:
					// set literal language type
					this._kt_object.language = m_langtag[1].toLowerCase();
					this._kt_object.datatype = KT_RDF_LANG_STRING;
				@;

			// next token definitely datatype or langtag, we are just being interrupted by eos
			@{else_retry()}

		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		@- B_UPGRADE_FACTORY
			@{else_any()}
				this._kt_object = this._dc_factory.simpleLiteral(this._s_literal);

				// reset literal
				this._s_literal = '';
		@;

		// not datatype, not language tag => that's okay! those are optional
		@{end_else()}

		// goto end of statement state
		@{end_of_statement()}
	@{end_method('datatype_or_langtag')}


	@{method('datatype')}
		@- B_UPGRADE_FACTORY
			let kt_datatype = null;
		@;

		// prefixed name quick
		@{if_match('R_PREFIXED_NAME_QUICK', 'm_pnq_datatype')}
			@{valid_prefix('m_pnq_datatype')}

			// commit object iri from resolve prefixed name
			kt_datatype = @{prefixed_name('s_prefix_id', 'm_pnq_datatype[2]')};

		// iriref
		@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_datatype')}
			let p_datatype;
			@{iriref('p_datatype', 'm_iriref_e_datatype', false, false, false, true)}

			@- B_UPGRADE_FACTORY
				kt_datatype = this.check_named_node_escapeless(p_datatype);
			@:
				// set literal datatype
				this._kt_object.datatype = this.check_named_node_escapeless(p_datatype);
			@;

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_datatype')}
			@{valid_prefix('m_prefixed_named_e_datatype')}

			@- B_UPGRADE_FACTORY
				kt_datatype = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_datatype[2]')};
			@:
				// set literal datatype
				this._kt_object.datatype = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_datatype[2]')};
			@;

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_datatype')}
			let p_datatype;
			@{iriref('p_datatype', 'm_iriref_e_datatype', false, false, true, true)}

			@- B_UPGRADE_FACTORY
				kt_datatype = this.check_named_node(p_datatype);
			@:
				// set literal datatype
				this._kt_object.datatype = this.check_named_node(p_datatype);
			@;

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_datatype')}
			@{valid_prefix('m_prefixed_named_datatype')}

			@{suffix('m_prefixed_named_datatype')}

			@- B_UPGRADE_FACTORY
				// set literal datatype
				kt_datatype = @{prefixed_name('s_prefix_id', 's_suffix')};
			@:
				// set literal datatype
				this._kt_object.datatype = @{prefixed_name('s_prefix_id', 's_suffix')};
			@;

		// not iriref, not prefixed name
		@{else_retry()}

		@- B_UPGRADE_FACTORY
			this._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);

			// reset literal
			this._s_literal = '';
		@;

		// goto end of statement state
		@{end_of_statement()}
	@{end_method('datatype')}


	@{method('post_object')}
		let i_reset = i;

		// benchmarks confirm: character ref faster than regexes in this context
		let x = s[i];

		// advance index to next token beyond delimiter
		@{whitespace('i+1')}

		// ',' more objects
		@{if_char(',')}
			@{goto('object_list')};

		// ';' more predicate-object pairs
		@{else_if_char(';')}
			for(;;) {
				// next token is end of outer section
				let s_peek = s[this.i];
				if('.' === s_peek || ']' === s_peek || ';' === s_peek @{QUADS? /* syntax: js */ `|| '}' === s_peek`: ''}) {
					// goto post_object state
					@{goto('post_object')}
				}
				// comment
				else if('#' === s_peek) {
					// comment
					i = this.i;
					@{if_match('R_COMMENT', 'm_comment')}
						if(this.emit_comments) this.emit_comments(m_comment[0]);
						// retry
						continue;
					@{end_else()}
					// no eol to close comment (yet)
					else {
						// already consumed 
						break;
					}
				}
				// eos
				else if(this.i === n) {
					break;
				}
				// something else
				else {
					@{goto('pairs')}
				}
			}

			// rather than pushing a dedicated state, just try again next chunk
			i = i_reset;
			break;

		// '.' end of statement
		@{else_if_char('.')}
			// assert not nested
			if(this._a_nested.length) {
				// reset index to that character
				this.i = i;

				// emit parse error
				return this.parse_error('end_of_property_list');
			}
			@- TTL
				@{goto(S_STATE_PRIMARY)}
			@:
				return (@{SJ_DEFAULT_GRAPH} === this._kt_graph)? this.@{S_STATE_PRIMARY}(): this.statement();
			@;

		// ']' end of property-object pairs
		@{else_if_char(']')}
			@{pop_state()}

		// ')' end of collection
		@{else_if_char(')')}
			// should not be here
			return Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');

		@- QUADS
			// closing graph '}'
			@{else_if_match('R_CHAR_CLOSE')}
				// emit graph_close event
				@{emit_graph_close()}

				// reset graph
				this._kt_graph = @{SJ_DEFAULT_GRAPH};

				@{goto('block')}
		@;

		// comment
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
			continue;

		// comment interrupted by eos?
		@{else_retry()}

	@{end_method('post_object')}


	@{method('base_iri')}
		// prefix id
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_base')}
			@// set base url
			@{iriref('base_url', 'm_iriref_e_base', false, true)}

			// emit base event
			this.emit('base', this._s_base_url);

			@// handle full stop
			@{full_stop()}

			// goto prefix iri state
			@{goto(S_STATE_PRIMARY)}

		// prefix id
		@{else_if_match('R_IRIREF', 'm_iriref_base')}
			@// set base iri
			@{iriref('base_url', 'm_iriref_base', false, true, true)}

			// emit base event
			this.emit('base', this._s_base_url);

			@// handle full stop
			@{full_stop()}

			// goto prefix iri state
			@{goto(S_STATE_PRIMARY)}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
			continue;

		@{else_retry()}
	@{end_method('base_iri')}


	@{method('prefix_id')}
		// prefix id
		@{if_match('R_PREFIX_ID', 'm_prefix_id')}
			// set temp prefix id
			this._s_temp_prefix_id = m_prefix_id[1];

			// goto prefix iri state
			@{goto('prefix_iri')}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
			continue;

		@{else_retry()}

	@{end_method('prefix_id')}


@> update_prefixes()
	let b_relax = this._b_relax;

	// existing mapping
	@- B_OPTIMIZE_PREFIX_IDS
		if(as_prefix_ids.has(s_prefix_id)) {
	@:
		if(s_prefix_id in h_prefixes) {
	@;
		// doesn't match existing
		if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
			// emit change event
			if(this.prefix_change) {
				this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
			}

			// update prefix
			h_prefixes[s_prefix_id] = p_prefix_iri;
		}
	}
	// first mapping
	else {
		// check namespace, invalid
		if(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {
			return this.error(`Invalid namespace for prefixed name: "${s_prefix_id}:"`);
		}

		// set prefix
		h_prefixes[s_prefix_id] = p_prefix_iri;

		@- B_OPTIMIZE_PREFIX_IDS
			as_prefix_ids.add(s_prefix_id);
			// this._as_prefix_ids = new Set(Object.keys(h_prefixes).sort());
		@;
	}

	// check iri, invalid
	if(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {
		return this.error(`Invalid IRI found in prefix delcaration: "${s_iri}"`);
	}

	// emit prefix event
	this.event('prefix', s_prefix_id, p_prefix_iri);
@;

	@{method('prefix_iri')}
		let h_prefixes = this._h_prefixes;
		@- B_OPTIMIZE_PREFIX_IDS
			let as_prefix_ids = this._as_prefix_ids;
		@;
		let s_prefix_id = this._s_temp_prefix_id;
		let p_prefix_iri;

		// prefix iri
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_prefix')}
			@// set prefix mapping
			@{iriref('p_prefix_iri', 'm_iriref_e_prefix', false, false, false, true)}

			@{update_prefixes()}

			@// handle full stop
			@{full_stop()}

			// goto statement state
			@{goto(S_STATE_PRIMARY)}

		// prefix iri
		@{else_if_match('R_IRIREF', 'm_iriref_prefix')}
			@// set prefix mapping
			@{iriref('p_prefix_iri', 'm_iriref_prefix', false, false, true, true)}

			@{update_prefixes()}

			@// handle full stop
			@{full_stop()}

			// goto statement state
			@{goto(S_STATE_PRIMARY)}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
			continue;

		@{else_retry()}
	@{end_method('prefix_iri')}


	// in case eos happens twice during prefix / base (extremely unlikely)
	@{method('full_stop')}
		@{if_match('R_CHAR_STOP')}
			// resume statement
			@{goto(S_STATE_PRIMARY)}

		// poorly-placed comment
		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			// try again
			continue;
		
		// possibly interrupted by eos
		@{else_retry()}

	@{end_method('full_stop')}


	@{method('collection_subject')}
		// ref char
		let x = s[i];

		// end of collection
		@{if_char(')')}
			@{whitespace('i+1')}

			// no items in collection subject
			if(null === this._kt_subject) {
				// prepare subject
				this._kt_subject = @{SJ_RDF_NIL};

				// state was never pushed to stack, jump to post_subject state
				@{goto('post_blank_subject')}
			}
			// otherwise, there must be items in collection

			// commit collection end
			this._kt_object = @{SJ_RDF_NIL};
			@{emit_statement()}

			// restore state from stack
			@{pop_state()}
		@{end_else()}


		// otherwise, pre-emptively secure the next blank node label
		let s_pointer_label;

		// very first collection object
		let b_pushed = false;
		if(null === this._kt_subject) {
			// set quasi subject (really for resume state)
			s_pointer_label = this.next_label();
			this._kt_subject = this.anonymous_blank_node(s_pointer_label);
			@{push_state('pairs')}
			// reset subject for later conditional branch
			this._kt_subject = null;
			b_pushed = true;
		}

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object', true)}
			@// commit object iri as is
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object', true)}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_object[2]')};

		// string literal
		@{else_if_char('"', "'")}
			// first item in list
			if(null === this._kt_subject) {
				s_pointer_label = this.next_label();
				this._kt_subject = this.anonymous_blank_node(s_pointer_label);
				this._kt_predicate = @{SJ_RDF_FIRST};
			}
			// not first item in list
			else {
				// make nest list item
				s_pointer_label = this.next_label();
				let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}

				// setup for object literal
				this._kt_subject = kt_blank_node;
				this._kt_predicate = @{SJ_RDF_FIRST};
			}

			// how to resume collection subject state after object literal
			this.after_end_of_statement = function() {
				this._kt_predicate = @{SJ_RDF_REST};
				this.after_end_of_statement = this.post_object;
				return this.collection_subject();
			};
			@{goto('string_literal')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal', true)}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal', true)}
			@- B_UPGRADE_FACTORY
				// make literal
				this._kt_object = this._dc_factory.boolean(m_boolean_literal[1]? true: false);
			@:
				// make literal
				this._kt_object = factory.boolean(m_boolean_literal[1]? true: false);
			@;

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// this blank node is just the next item in the list
			s_pointer_label = this.next_label();
			let kt_blank_node;
			if(null !== this._kt_subject) {
				kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}
			}

			// subject needs to be set
			this._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
			this._kt_predicate = @{SJ_RDF_FIRST};
			let s_label = this.next_label();
			kt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);
			@{emit_statement()}

			// when resume
			this._kt_predicate = @{SJ_RDF_REST};

			// push state
			@{push_state('collection_subject')}

			// prepare next triple
			this._kt_subject = kt_blank_node;

			// goto parsing pairs state
			@{goto('pairs')}

		// new collection
		@{else_if_char('(')}
			@{whitespace('i+1', true)}

			// empty collection
			if(')' === s[i]) {
				this.i = i;
				this._kt_subject = this._a_nested[this._a_nested.length-1][0];
				this._kt_predicate = @{SJ_RDF_FIRST};
				this._a_nested.push([
					this._kt_subject,
					@{SJ_RDF_REST},
					'collection_subject',
				]);
				@{goto('collection_object')}
			}

@.{/*
			// commit list item pointer
			if(null !== this._kt_subject) {
				s_pointer_label = this.next_label();
				let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}

				// add this list as an item to the outer list
				this._kt_subject = kt_blank_node;
				this._kt_predicate = @{SJ_RDF_REST};

				@{push_state('collection_object')}
			}
			else {
				this._a_nested.push([
					this._a_nested[this._a_nested.length-1][0],
					@{SJ_RDF_REST},
					'collection_object',
				]);
			}


			// prepare next triple
			this._kt_predicate = @{SJ_RDF_FIRST};
*/}



			// commit list item pointer
			s_pointer_label = this.next_label();
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
			@{emit_statement()}

			// add this list as an item to the outer list
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_REST};
			@{push_state('collection_object')}

			// prepare next triple
			this._kt_predicate = @{SJ_RDF_FIRST};



@.{/*

			// commit list item pointer
			s_pointer_label = this.next_label();
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
			if(null === this._kt_subject) {
				let a_recent = this._a_nested[this._a_nested.length-1];
				this._kt_subject = a_recent[0];
				this._kt_predicate = a_recent[1];
			}
			@{emit_statement()}

			// add this list as an item to the outer list
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_REST};
			@{push_state('collection_object')}

			// prepare next triple
			this._kt_predicate = @{SJ_RDF_FIRST};


			// this blank node is just the next item in the list
			s_pointer_label = this.next_label();
			let kt_blank_node;
			if(null !== this._kt_subject) {
				kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}
			}

			// subject needs to be set
			this._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
			this._kt_predicate = @{SJ_RDF_FIRST};
			let s_label = this.next_label();
			kt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);
			@{emit_statement()}

			// when resume
			this._kt_predicate = @{SJ_RDF_REST};

			// push state
			@{push_state('collection_subject')}

			// prepare next triple
			this._kt_subject = kt_blank_node;
*/}

			// flowing
			continue;

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_object', true)}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make object
			this._kt_object = this.blank_node(s_label);

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object', true)}
			@// commit object iri as is
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object', true)}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 's_suffix')};

		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry(/* syntax: js */ `
			// ran out of characters after pushing state, pop it
			if(b_pushed) this._a_nested.pop();
		`)}

		let kt_blank_node_outer;
		if(!s_pointer_label) s_pointer_label = this.next_label();

		// not the very first item of collection subject
		if(this._kt_subject !== null) {
			// ref object
			let w_object = this._kt_object;

			// create blanknode to embed list
			kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

			// emit statement that functions as collection's head "pointer"
			@{emit_statement()}

			// swap back object
			this._kt_object = w_object;
		}

		// emit statement that is item
		this._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);
		this._kt_predicate = @{SJ_RDF_FIRST};
		@{emit_statement()}

		// prepare next predicate
		this._kt_predicate = @{SJ_RDF_REST};

	@{end_method('collection_subject')}



	@{method('collection_object')}

		// ref char
		let x = s[i];

		// end of collection
		@{if_char(')')}
			@{whitespace('i+1')}

			// make & emit collection's tail "pointer"
			this._kt_object = @{SJ_RDF_NIL};
			@{emit_statement()}

			// restore previous state
			@{pop_state()}
		@{end_else()}


		// otherwise, pre-emptively secure the next blank node label
		let s_pointer_label;

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object', true)}
			// commit object iri as is
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object', true)}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 'm_prefixed_named_e_object[2]')};

		// string literal
		@{else_if_char('"', "'")}
			// update index before changing states
			this.i = i;

			// create blanknode to embed list
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

			// emit statement that functions as collection's head "pointer"
			@{emit_statement()}

			// prepare statement that is item
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_FIRST};

			this.after_end_of_statement = function() {
				this._kt_predicate = @{SJ_RDF_REST};
				this.after_end_of_statement = this.post_object;
				return this.collection_object();
			};
			@{goto('string_literal')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal', true)}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal', true)}
			@- B_UPGRADE_FACTORY
				// make literal
				this._kt_object = this._dc_factory.booelan(m_boolean_literal[1]? true: false);
			@:
				// make literal
				this._kt_object = factory.booelan(m_boolean_literal[1]? true: false);
			@;

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// commit head of list pointer
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());
			@{emit_statement()}

			// setup state to resume and push
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_REST};
			@{push_state('collection_object')}

			// enter blank node
			this._kt_predicate = @{SJ_RDF_FIRST};
			kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());
			@{emit_statement()}

			// prepare next triple
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_FIRST};

			// goto parsing pairs state
			@{goto('pairs')}

		// new collection
		@{else_if_char('(')}
			@{whitespace('i+1', true)}

			// commit list item pointer
			s_pointer_label = this.next_label();
			let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
			if(null === this._kt_subject) {
				let a_recent = this._a_nested[this._a_nested.length-1];
				this._kt_subject = a_recent[0];
				this._kt_predicate = a_recent[1];
			}
			@{emit_statement()}

			// add this list as an item to the outer list
			this._kt_subject = kt_blank_node;
			this._kt_predicate = @{SJ_RDF_REST};
			@{push_state('collection_object')}

			// prepare next triple
			this._kt_predicate = @{SJ_RDF_FIRST};

			// flowing
			continue;

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_object', true)}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make collection pointer label first
			s_pointer_label = this.next_label();

			// make object
			this._kt_object = this.blank_node(s_label);

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object', true)}
			// commit object iri as is
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object', true)}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this._kt_object = @{prefixed_name('s_prefix_id', 's_suffix')};

		@{else_if_match('R_COMMENT', 'm_comment', true)}
			if(this.emit_comments) this.emit_comments(m_comment[0]);
			continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry()}


		// ref object
		let w_object = this._kt_object;

		// create blanknode to embed list
		if(!s_pointer_label) s_pointer_label = this.next_label();
		let kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

		// emit statement that functions as collection's head "pointer"
		@{emit_statement()}

		// emit statement that is item
		this._kt_subject = kt_blank_node_outer;
		this._kt_predicate = @{SJ_RDF_FIRST};
		this._kt_object = w_object;
		@{emit_statement()}

		// prepare next predicate
		this._kt_predicate = @{SJ_RDF_REST};

	@{end_method('collection_object')}

	@//@object-literal

	destroy(e_destroy) {
		@*{
			for(let s_method of a_methods) {
				yield /* syntax: js */ `
					this.${s_method} = () => {};
				`;
			}
		}

		this.eof = () => {
			this.s = null;
		};

		this._b_destroyed = true;

		// propagate input destroy
		if(!e_destroy && this._ds_input) {
			this._ds_input.destroy(e_destroy);
		}

		this.transform.demolish(e_destroy);
	}
}

module.exports = function(...a_args) {
	let g_config = {};

	@{normalize_reader_config('g_config')}

	// create reader, return transform stream
	return (new Reader(g_config)).transform;
};

'use strict';

@import '../../share/iris.jmacs'

@./* global S_FORMAT S_MODE */
@//

@$ TTL = 'ttl' === S_FORMAT;
@$ TRIG = 'trig' === S_FORMAT;
@$ B_QUADS = TRIG;

@$ B_TURTLE = TTL
@$ B_TRIG = TRIG

@$ S_LABEL = TTL? 'Turtle': 'TriG';

@$ S_STATE_PRIMARY = B_TURTLE? 'statement': 'block';

@$ B_LOAD = 'load' === S_MODE;
@$ B_READ = 'read' === S_MODE;
@$ B_STAR = true;
@$ B_OPTIMIZE_PAIRS = false;
@$ B_OPTIMIZE_PREFIX_IDS = false;

@$ B_LOAD_GSPO_BUILDER = true;

@// 1% speedup
@$ B_OPTIMIZE_PN = true;

@.{
	const ode = Object.entries;

	let SJ_RDF_TYPE;
	let SJ_RDF_FIRST;
	let SJ_RDF_REST;
	let SJ_RDF_NIL;
	let SJ_DEFAULT_GRAPH;

	let terms_equal;

	if(B_LOAD) {
		SJ_RDF_TYPE = /* syntax: js */ `this._sc1_rdf_type`;
		SJ_RDF_FIRST = /* syntax: js */ `this._sc1_rdf_first`;
		SJ_RDF_REST = /* syntax: js */ `this._sc1_rdf_rest`;
		SJ_RDF_NIL = /* syntax: js */ `this._sc1_rdf_nil`;
		SJ_DEFAULT_GRAPH = /* syntax: js */ `'*'`;
	}
	else {
		SJ_RDF_TYPE = /* syntax: js */ `this._kt_rdf_type`;
		SJ_RDF_FIRST = /* syntax: js */ `this._kt_rdf_first`;
		SJ_RDF_REST = /* syntax: js */ `this._kt_rdf_rest`;
		SJ_RDF_NIL = /* syntax: js */ `this._kt_rdf_nil`;
		SJ_DEFAULT_GRAPH = /* syntax: js */ `this._kt_default_graph`;
	}

	terms_equal = (sj_a, sj_b) => /* syntax: js */ `${sj_a}.equals(${sj_b})`;

	let prefixed_name;

	if(B_OPTIMIZE_PN) {
		prefixed_name = (sj_suf, sj_pre='s_prefix_id') => /* syntax: js */ `this.prefixed_name(${sj_pre}, ${sj_suf})`;
	}
	else {
		prefixed_name = (sj_suf, sj_pre='s_prefix_id') => /* syntax: js */ `this.named_node(this._h_prefixes[${sj_pre}] + ${sj_suf})`;
	}
}

@// import parser macros
@import '../text.read.jmacs'

import uri from 'uri-js';
import string_decoder from 'string_decoder';

import {stream} from '@@graphy/internal';
import {DataFactory} from '@@graphy/core';

@if B_LOAD
	@if B_LOAD_GSPO_BUILDER
		import {BasicQuadTree} from '@@graphy/memory';
	@;
	const {
		concise,
	} = DataFactory;

	const $_KEYS = Symbol(' keys');
	const $_QUADS = Symbol(' quads');
@;

import {
	ContentSyntaxError,
	UnexpectedTokenError,
	@if B_LOAD
		InvalidStateChangeError,
	@;
	NoSuchPrefixError,
	ExceededMaximumTokenLengthError,
} from '../../error.mjs';

// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_NAMESPACE_VALID = /^(@{PN_PREFIX()})?$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^@{PN_LOCAL()}$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_BLANK_NODE_VALID = /^[@{RANGE_PN_CHARS_U()}0-9]@{PN_CHARS_FS()}$/u;
const RT_NAMED_NODE_VALID = /@{RT_NAMED_NODE_VALID(false)}/;
const RT_NAMED_NODE_ESCAPELESS_VALID = /@{RT_NAMED_NODE_VALID(true)}/;

const RT_LITERAL_CONTENTS_VALID = /@{RT_LITERAL_CONTENTS_VALID()}/;

const R_UNICODE_ANY = /@{R_UNICODE_4()}|@{R_UNICODE_8()}/g;

const F_REPLACE_UNICODE_ANY = @{F_REPLACE_UNICODE_ANY()};

const OPHOP = Object.prototype.hasOwnProperty;


@$ H_LOOKAHEADS = {
	comment: {
		chars: '#',
	},
	tree: {
		sub: 'comment',
		chars: '<',  // node
	},
	predicate: {
		sub: 'tree',
		chars: ''
			+'['  // blank node property list
			+'('  // collection
			+'"\''  // string
			,
	},
	object: {
		sub: 'comment',
		chars: ''
			+','  // object list
			+';'  // predicate-object list
			+'\\]'  // blank node property list
			+')'  // collection
			+(B_STAR? '>': '')  // triple_x terminate
			,
	},
	terminal: {
		sub: 'object',
		chars: ''
			+'.'  // triple
			+(TRIG? '}': '')  // end-of-graph
			,
	},
	string: {
		sub: 'terminal',
		chars: ''
			+'@'  // langtag
			+'^'  // datatype
			,
	},
	blank_node: {
		sub: 'object',
		chars: ''
			+'<'  // iri
			+':'  // prefixed name (only one colon allowed in blank node label)
			+(TRIG? '{': '')  // start-of-graph (subject)
			,
	},
};

@def save_term(s_role, sj_expr)
	// save @{s_role} term to field
	@{'datatype' === s_role? '': 'this._'}kt_@{s_role} = @{sj_expr};
@;


@// extract uri from absolute / relative iri refs
@def iriref({s_role, sj_matched, b_escapeless=false})
	@.{
		let f_load;
		let b_set_role = false;
		let b_not_this = false;

		// g, s, p, o or d
		let b_gspod = true;
		switch(s_role) {
			case 'graph': f_load = load_graph; break;
			case 'subject': f_load = load_subject; break;
			case 'predicate': f_load = load_predicate; break;
			case 'object': f_load = load_object; break;

			case 'datatype': {
				b_not_this = true;
				break;
			}

			case 'base_iri':
			case 'prefix_iri': {
				b_set_role = true;
				b_gspod = false;
				break;
			}

			default: {
				b_gspod = false;
				break;
			}
		}

		let f_set;
		if(B_LOAD) {
			if(f_load) {
				f_set = sj => f_load(/* syntax: js */ `concise(${sj}, this._h_prefixes)`);
			}
			else {
				let sv_set = (b_not_this? '': 'this._')+(b_gspod? 'sc1_': 's_')+s_role;
				f_set = sj => /* syntax: js */ `${sv_set} = ${sj};`;
			}
		}
		else {
			let sv_set = b_set_role
				? `p_${s_role}`
				: (b_not_this? '': 'this._')+(b_gspod? 'kt_': 's_')+s_role;
			f_set = b_gspod
				? sj => /* syntax: js */ `${sv_set} = this.check_named_node${b_escapeless? '_escapeless': ''}(${sj});`
				: sj => /* syntax: js */ `${sv_set} = ${sj};`;
		}
	}
	// ref iri
	let p_@{s_role} = @{sj_matched}[1]@{b_escapeless? '': `.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)`};

	// absolute iri
	if(!this._s_base_iri || RT_IRI_ABSOLUTE.test(p_@{s_role})) {
		// set @{s_role}
		@{f_set(/* syntax: js */ `p_${s_role}`)}
	}
	// relative iri
	else {
		// set @{s_role}
		@{f_set(/* syntax: js */ `uri.resolve(this._s_base_iri, p_${s_role})`)}
	}

	@// update the base iri
	@if 'base_iri' === s_role
		const m_base_iri = R_BASE_IRI.exec(p_base_iri);
		this._s_@{s_role} = m_base_iri[1];
		this._s_@{s_role}_root = m_base_iri[2] || '';
		this._s_@{s_role}_scheme = m_base_iri[3] || '';
		this._s_@{s_role}_path = m_base_iri[4] || ''; 
	@;
@;

@def deduce_strlit_path(s_mode)
	@. let sj_char = 'single' === s_mode? `"'"`: `'"'`;
	// enough chars to deduce type
	if((i+2) < n) {
		// long type
		if(@{sj_char} === s[i+1] && @{sj_char} === s[i+2]) {
			// advance index beyond token
			this.i = i + 3;

			// read contents
			@{goto('string_literal_long_'+s_mode)}
		}
		// not long type
		else {
			// advance index beyond token
			this.i = i + 1;

			// read contents
			@{goto('string_literal_short_'+s_mode)}
		}
	}
	// enough chars to eliminate long type
	else if((i+1) < n && @{sj_char} !== s[i+1]) {
		// advance index beyond token
		this.i = i + 1;

		// read contents
		@{goto('string_literal_short_'+s_mode)}
	}
	// not enough chars to deduce type; retry next chunk
	else {
		break;
	}
@;


@def error_args(gc_args={})
	@//@object-literal
	@.{
		let sj_index = /* syntax: js */ `this.i`;
	}
	@if gc_args.rewind
		@.{
			sj_index = /* syntax: js */ `i_caret`;
		}
		...(() => {
			@*{
				let a_rewinds = gc_args.rewind;
				if(!Array.isArray(a_rewinds)) a_rewinds = [a_rewinds];

				let sj_token_prev = /* syntax: js */ `this.i`;
				const nl_rewinds = a_rewinds.length;
				for(let i_rewind=0; i_rewind<nl_rewinds; i_rewind++) {
					const sj_token_curr = /* syntax: js */ `i_token_${nl_rewinds-i_rewind-1}`;
					yield /* syntax: js */ `
						const ${sj_token_curr}_end = ${sj_token_prev} - /[ \\t]*$/.exec(this.s.slice(0, ${sj_token_prev}))[0].length;`;
					sj_token_prev = /* syntax: js */ `${sj_token_curr}_start`;
					yield /* syntax: js */ `
						const ${sj_token_prev} = ${sj_token_curr}_end - (${a_rewinds[i_rewind]});`;
				}
			}
			const i_caret = i_token_0_start + (@{gc_args.caret});

			return {
	@;
	content: this,
	source: this.s,
	token: {
		caret: @{sj_index},
		@if gc_args.rewind
			start: i_token_0_start,
			end: i_token_0_end,
		@;
	},
	...this._b_line_tracking
		? {
			location: {
				line: 1 + this._c_lines + count_lines_until(this.s, @{sj_index})@{gc_args.line || ''},
				col: @{sj_index} - this.s.lastIndexOf('\n', @{sj_index}),
			},
		}
		: {},

	@if gc_args.rewind
		}})(),
	@;
@;


@def update_prefixes()
	let b_tolerant = this._b_tolerant;

	// existing mapping
	@if B_OPTIMIZE_PREFIX_IDS
		if(as_prefix_ids.has(s_prefix_id)) {
	@else
		if(s_prefix_id in h_prefixes) {
	@;
		// doesn't match existing
		if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
			@if B_LOAD
				throw new InvalidStateChangeError({
					message: `Loader requires all prefix mappings declared before data statements. Detected IRI change of prefix namespace '${s_prefix_id}' from <${h_prefixes[s_prefix_id]}> to <${p_prefix_iri}>`,
					@{error_args()}
				});
			@+ B_READ
				// emit change event
				if(this.prefix_change) {
					this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
				}

				// update prefix
				h_prefixes[s_prefix_id] = p_prefix_iri;
			@;
		}
	}
	// first mapping
	else {
		// check namespace, invalid
		if(!b_tolerant && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {
			throw new ContentSyntaxError({
				message: `Invalid namespace for prefixed name: '${s_prefix_id}:'`,
				@{error_args({
					rewind: [
						/* syntax: js */ `p_prefix_iri.length + 2`,
						/* syntax: js */ `s_prefix_id.length + 1`,
					],
					caret: /* syntax: js */ `
						/[^${RANGE_PN_CHARS_BASE()}]/u.test(s_prefix_id[0])
						? 0
						: /[^.${RANGE_PN_CHARS_U()}\\-0-9\\xb7\\u{203f}-\\u{2040}]/u.exec(s_prefix_id)?.index || s_prefix_id.length-1
					`,
				})}
			});
		}

		// set prefix
		@if B_LOAD
			// prefixes are cached and frozen, clone them while assigning new preifx
			h_prefixes = {
				...h_prefixes,
				[s_prefix_id]: p_prefix_iri,
			};
		@+ B_READ
			h_prefixes[s_prefix_id] = p_prefix_iri;
		@;

		@if B_OPTIMIZE_PREFIX_IDS
			as_prefix_ids.add(s_prefix_id);
			// this._as_prefix_ids = new Set(Object.keys(h_prefixes).sort());
		@;
	}

	// check iri, invalid
	if(!b_tolerant && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {
		throw new ContentSyntaxError({
			message: `Invalid IRI found in prefix delcaration: "${p_prefix_iri}"`,
			@{error_args()}
		});
	}

	@if B_LOAD
		// re-cache prefixes
		this._h_prefixes = DataFactory.cachePrefixes(h_prefixes);

		// update xsd scp string
		this._scp_xsd_decimal = '^'+concise('@{P_IRI_XSD}decimal', h_prefixes)+'"';
		this._sc1_rdf_type = concise('@{P_IRI_RDF}type', h_prefixes);
	@;

	// emit prefix event
	this._fk_prefix(s_prefix_id, this.named_node(p_prefix_iri));
@;


@.{
	const modal = (h_modes) => h_modes[S_MODE];

	const commit_term = (s_role, sj_expr) => modal({
		read: save_term(s_role, sj_expr),
		load: load_term(s_role, sj_expr),
	});

	const gen_rule_iri = ({b_escapeless}) => ({role:s_role, node_mod:s_mod}) => ({
		type: 'match',
		test: /* syntax: js */ `R_${'graph' === s_mod? 'GRAPH_': ''}IRIREF${b_escapeless? '_ESCAPELESS': ''}`,
		action: ({sj_matched}) => [
			iriref({s_role, sj_matched, b_escapeless}),

			// // already handled in iriref above
			// modal({
			// 	read: save_term(s_role, /* syntax: js */ `this.check_named_node${b_escapeless? '_escapeless': ''}(p_${s_role})`),
			// 	load: load_term(s_role, /* syntax: js */ `concise(p_${s_role}, this._h_prefixes)`),
			// }),
		],
	});

	const gen_action_prefixed_name = ({b_escapeless, role:s_role}) => ({sj_matched}) => [
		valid_prefix(sj_matched),
		modal({
			read: save_term(s_role, /* syntax: js */ `this.prefixed_name(s_prefix_id, ${sj_matched}[2])`),
			load: load_term(s_role, /* syntax: js */ `${sj_matched}[1]`),
		}),
	];

	const gen_rule_prefixed_name = modal({
		read: ({b_escapeless}) => ({role:s_role}) => ({
			type: 'call',
			test: /* syntax: js */ `this.match_prefixed_name${b_escapeless? '_escapeless': ''}`,
			action: gen_action_prefixed_name({
				escapeless: b_escapeless,
				role: s_role,
			}),
		}),
		load: ({b_escapeless}) => ({role:s_role}) => ({
			type: 'match',
			test: /* syntax: js */ `R_PREFIXED_NAME${b_escapeless? '_ESCAPELESS': ''}`,
			action: gen_action_prefixed_name({
				escapeless: b_escapeless,
				role: s_role,
			}),
		}),
	});

	const gen_rule_labeled_blank_node = ({b_terminal}) => ({role:s_role, node_mod:s_mod}) => ({
		type: 'match',
		test: /* syntax: js */ `R_${'graph' === s_mod? 'GRAPH_': ''}LABELED_BLANK_NODE${b_terminal? '_TERMINAL': ''}`,
		action: ({sj_matched}) => [
			/* syntax: js */ `
				// extract label
				let s_label = ${sj_matched}[1];
			`,
			modal({
				read: save_term(s_role, /* syntax: js */ `this.blank_node(s_label)`),
				load: load_term(s_role, /* syntax: js */ `'#'+s_label`),
			}),
			...('graph' === s_mod? [emit_graph_open()]: []),
		],
	});

	const gen_rule_literal = (s_which) => ({role:s_role}) => ({
		type: 'chars',
		test: 'single' === s_which? `'`: `"`,
		action: deduce_strlit_path(s_which),
	});

	const gen_rule_base_iriref = ({b_escapeless}) => () => ({
		type: 'match',
		test: /* syntax: js */ `R_IRIREF${b_escapeless? '_ESCAPELESS': ''}`,
		action: ({sj_matched}) => [
			iriref({s_role:'base_iri', sj_matched, b_escapeless}),
			modal({
				read: /* syntax: js */ `
						this._fk_base(this._s_base_iri);
					`,
				load: '',
			}),
			// handle full stop
			full_stop(),
		],
		goto: S_STATE_PRIMARY,
	});

	const gen_rule_prefix_iriref = ({b_escapeless}) => () => ({
		type: 'match',
		test: /* syntax: js */ `R_IRIREF${b_escapeless? '_ESCAPELESS': ''}`,
		action: ({sj_matched}) => [
			iriref({s_role:'prefix_iri', sj_matched, b_escapeless}),
			modal({
				read: /* syntax: js */ `
					${update_prefixes()}
				`,
				load: '',
			}),
			// handle full stop
			full_stop(),
		],
		goto: S_STATE_PRIMARY,
	});

	const H_RULES = {
		graph_terminator: () => ({
			type: 'test',
			test: /* syntax: js */ `R_CHAR_CLOSE`,
			action: modal({
				read: /* syntax: js */ `
					// emit graph close event
					${emit_graph_close()}

					// reset graph
					this._kt_graph = ${SJ_DEFAULT_GRAPH};
				`,
				load: load_default_graph(),
			}),
			goto: 'block',
		}),

		non_comment: () => ({
			type: 'not_chars',
			test: '#',
			action: [],
			goto: 'pairs',
		}),

		disambiguating_graph_open: ({anonymous:b_anon}) => ({
			type: 'chars',
			test: '{',
			action: [
				modal({
					read: /* syntax: js */ `
						// shift placeholder subject
						${load_graph(/* syntax: js */ `this._sc1_subject`)}

						// reset subject in case of collections
						this._sc1_subject = null;
					`,
					load: /* syntax: js */ `
						// shift placeholder subject
						this._kt_graph = this._kt_subject;

						${emit_graph_open()}

						// reset subject in case of collections
						this._kt_subject = null;
					`,
				}),
				b_anon? /* syntax: js */ `
					// pop dummy state
					this._a_nested.pop();
				`: '',
			],
			goto: 'statement',
		}),

		prefixed_name_quick: ({role:s_role}) => ({
			type: 'match',
			test: /* syntax: js */ `R_PREFIXED_NAME_QUICK`,
			action: gen_action_prefixed_name({role:s_role}),
		}),
		
		iriref: gen_rule_iri({b_escapeless:false}),
		iriref_escapeless: gen_rule_iri({b_escapeless:true}),
		graph_iriref_escapeless: ({role:s_role}) => gen_rule_iri({b_escapeless:true})({role:s_role, node_mod:'graph'}),

		prefixed_name: gen_rule_prefixed_name({b_escapeless:false}),
		prefixed_name_escapeless: gen_rule_prefixed_name({b_escapeless:true}),

		labeled_blank_node: gen_rule_labeled_blank_node({b_terminal:false}),
		labeled_blank_node_terminal: gen_rule_labeled_blank_node({b_terminal:true}),

		anonymous_blank_node: ({role:s_role, node_mod:s_mod}) => ({
			type: 'match',
			test: /* syntax: js */ `R_${'graph' === s_mod? 'GRAPH_': ''}ANONYMOUS_BLANK_NODE`,
			action: [
				modal({
					read: save_term(s_role, /* syntax: js */ `this.anonymous_blank_node(this.next_label())`),
					load: load_term(s_role, /* syntax: js */ `'#'+this.next_label()`),
				}),
				...('graph' === s_mod? [emit_graph_open()]: []),
			],
		}),

		string_literal_single: gen_rule_literal('single'),
		string_literal_double: gen_rule_literal('double'),

		numeric_literal: ({role:s_role}) => ({
			type: 'match',
			test: /* syntax: js */ `R_NUMERIC_LITERAL`,
			action: ({sj_matched}) => /* syntax: js */ `
				// it has exponent term, xsd:double
				if(${sj_matched}[4]) {
					${modal({
						read: save_term(s_role, /* syntax: js */ `this._dc_factory.doubleLiteral(${sj_matched}[1])`),
						load: load_term(s_role, /* syntax: js */ `this._scp_xsd+'double"'+${sj_matched}[1]`),
					})}
				}
				// contains decimal point, xsd:decimal
				else if(${sj_matched}[2] || ${sj_matched}[3]) {
					${modal({
						read: save_term(s_role, /* syntax: js */ `this._dc_factory.decimalLiteral(${sj_matched}[1])`),
						load: load_term(s_role, /* syntax: js */ `this._scp_xsd+'decimal"'+${sj_matched}[1]`),
					})}
				}
				// otherwise, it is an integer
				else {
					${modal({
						read: save_term(s_role, /* syntax: js */ `this._dc_factory.integerLiteral(${sj_matched}[1])`),
						load: load_term(s_role, /* syntax: js */ `this._scp_xsd+'integer"'+${sj_matched}[1]`),
					})}
				}
			`,
		}),

		boolean_literal: ({role:s_role}) => ({
			type: 'match',
			test: /* syntax: js */ `R_BOOLEAN_LITERAL`,
			action: ({sj_matched}) => modal({
				read: save_term(s_role, /* syntax: js */ `this._dc_factory.booleanLiteral(${sj_matched}[1]? 'true': 'false')`),
				load: load_term(s_role, /* syntax: js */ `this._scp_xsd+'boolean"'+(${sj_matched}[1]? 'true': 'false')`),
			}),
		}),

		collection: () => ({
			type: 'chars',
			test: '(',
			action: push_state('post_object'),
			goto: 'collection_object',
		}),

		rdf_star: ({role:s_role, b_star=false}) => ({
			type: 'chars',
			test: '<<',
			action: /* syntax: js */ `
				// rdf-star not enabled
				if(!this._b_rdf_star) break;

				${b_star
					? push_state('subject' === s_role? 'star_predicate_x': 'star_post_object_x')
					: /* syntax: js */ `
						this.emit_data = this.exit_star;
						this.restore_after_eot = this.after_eot;
						this.after_eot = this.triple_x_close;

						${push_state('subject' === s_role? 'star_pairs': 'star_post_object')}
					`}
			`,
			goto: 'triple_x',
		}),

		comment: () => ({
			type: 'match',
			test: /* syntax: js */ `R_COMMENT`,
			args: {
				local_i: true,
			},
			action: ({sj_matched}) => /* syntax: js */ `
				if(this.emit_comments) this.emit_comments(${sj_matched}[0]);
				continue;
			`,
			goto: null,
		}),
	};

	const gen_matcher_strs = (a_strs, s_cmp='===', s_id='x') => a_strs.map((s_str) => {
			let b_mono = 1 === s_str.length;
			return (b_mono? '': '(')+s_str.split('')
				.map((s, i) => `'${s.replace(/'/g, '\\\'')}' ${s_cmp} ${i? `s[i+${i}]`: s_id}`)
				.join(' && ')+(b_mono? '': ')');
		}).join(' || ');

	const gen_matcher_regex = (b_match=false) => (sj_var, {role:s_role='it', local_i:b_local_i=false}) => {
		let sj_matched = /* syntax: js */ `m_${sj_var.replace(/^R_/, '').toLowerCase()}_${s_role}`;

		return {
			context: {
				...(b_match? {sj_matched}: {}),
			},
			render: /* syntax: js */ `
				// prepare sticky regex index
				${sj_var}.lastIndex = i;

				${b_match
					? /* syntax: js */ `
						// execute regex
						let ${sj_matched} = ${sj_var}.exec(s);

						// ${s_role} matches ${sj_var}
						if(${sj_matched}) {
					`
					: /* syntax: js */ `
						// ${s_role} matches ${sj_var}
						if(${sj_var}.test(s)) {
					`}

					// advance index
					${b_local_i? '': 'this.'}i = ${sj_var}.lastIndex;
			`,
		};
	};

	const H_MATCHERS = {
		raw: {
			apply: (s_raw) => /* syntax: js */ `
				if(${s_raw}) {
			`,
		},
		strs: {
			apply: (a_strs, {uncached_char:b_uncached=false}) => /* syntax: js */ `
				if(${gen_matcher_strs(a_strs, '===', b_uncached? 's[i]': 'x')}) {
			`,
		},
		chars: {
			apply: (a_chars, {uncached_char:b_uncached=false, local_i:b_local_i=false}) => /* syntax: js */ `
				if(${gen_matcher_strs([a_chars], '===', b_uncached? 's[i]': 'x')}) {
					${whitespace(a_chars.length, b_local_i)}
			`,
		},
		not_chars: {
			apply: (a_chars, {uncached_char:b_uncached=false}) => /* syntax: js */ `
				if(${gen_matcher_strs([a_chars], '!==', b_uncached? 's[i]': 'x')}) {
			`,
		},
		test: {
			branches: true,
			apply: gen_matcher_regex(false),
		},
		match: {
			branches: true,
			apply: gen_matcher_regex(true),
		},
		call: {
			branches: true,
			apply: (sj_method, {role:s_role, local_i:b_local_i=false}) => {
				let sj_no_shadow = (sj_method+'_'+s_role).replace(/[^a-z0-9]/gi, '_');
				let sj_matched = /* syntax: js */ `m_${sj_method.replace(/^this\./, '')}_${s_role}`;
				return {
					context: {
						sj_matched,
					},
					render: /* syntax: js */ `
						// try match
						let aw_valid_${sj_no_shadow} = ${sj_method}(s, i);

						// stack bail out
						if(!aw_valid_${sj_no_shadow}) return true;

						let [${sj_matched}, i${sj_matched}] = aw_valid_${sj_no_shadow};

						// ${s_role} passes ${sj_method}
						if(${sj_matched}) {
							// advance index
							${b_local_i? '': 'this.'}i = i${sj_matched};
					`,
				};
			},
		},
	};

	function* states(h_states) {
		for(let [si_state, g_state] of ode(h_states)) {
			// prep body string
			let s_body = '';

			// make else 
			let b_else = false;

			// branch counter
			let c_branches = 1;

			// each rule
			for(let [si_rule, z_rule] of ode(g_state.rules)) {
				// create args
				let h_args = {
					...(g_state.apply || {}),
				};

				// prep rule
				let f_rule;

				switch(typeof z_rule) {
					// function; inline rule
					case 'function': {
						f_rule = z_rule;
						break;
					}

					// object
					case 'object': {
						// rule id not exist
						if(!(si_rule in H_RULES)) {
							throw new Error(`rule id '${si_rule}' not found in mapping`);
						}

						// ref rule function
						f_rule = H_RULES[si_rule];

						// spread object value into args
						h_args = {
							...h_args,
							...z_rule,
						};
						break;
					}

					// string
					case 'string': {
						// special
						if(si_rule.startsWith('_')) {
							// close if
							if(b_else) s_body += '\n}\n';

							// break continuity
							b_else = false;

							// append directly
							s_body += z_rule;

							// continue on with rules
							continue;
						}
					}

					// fallthrough or other
					default: {
						throw new Error(`invalid rule at '${si_rule}': ${z_rule}`);
					}
				}

				// specifier
				let g_spec = f_rule(h_args);

				let si_matcher = g_spec.type;
				let g_matcher = H_MATCHERS[si_matcher];

				if(!g_matcher) {
					 throw new Error(`no such matcher defined '${si_matcher}'`);
				}

				// render within else branch
				if(b_else) {
					s_body += /* syntax: js.if */ `}
						// ${si_rule}
						else `;

					// the matcher branches
					if(g_matcher.branches) {
						c_branches += 1;
						s_body += /* syntax: js */ `{`;
					}
				}

				// now within else
				b_else = true;

				// apply matcher
				let z_applied = g_matcher.apply(g_spec.test, {
					...h_args,
					...(g_spec.args || {}),
				});

				// prep render and context
				let s_render;
				let h_context = {};

				// returned render string
				if('string' === typeof z_applied) {
					s_render = z_applied;
				}
				// returned applied result
				else {
					({
						render: s_render,
						context: h_context,
					} = z_applied);
				}

				// append rendered string to body (strip leading ws from if blocks)
				s_body += s_render.replace(/^\s+if\b/, 'if');

				// rule actions
				let z_action = g_spec.action;

				// resolve action function with matcher context
				if('function' === typeof z_action) {
					z_action = z_action(h_context);
				}

				// coalesce action into string
				s_body += Array.isArray(z_action)? z_action.flat(Infinity).join('\n'): (z_action || '')+'';

				// there is a goto action, append it
				if(g_spec.goto || (null !== g_spec.goto && h_args.goto)) s_body += goto(g_spec.goto || h_args.goto);
			}

			if('bypass' !== g_state.loop) {
				// final else branch
				s_body += /* syntax: js.if */ `} else {`;

				// else body is defined
				if(g_state.else) {
					s_body += g_state.else;
				}
				// default to retry
				else {
					s_body += (g_state.cleanup || '')+/* syntax: js */ `
						// break loop to retry on next chunk if eos
						break;
					`;
				}
			}

			// close branches
			s_body += '}\n'.repeat(c_branches);

			// loop control type
			let sx_loop = ({
				bypass: '',
				for: /* syntax: js */ `for(;;) {`,
				'': /* syntax: js */ `${si_state.toUpperCase()}: while(i < n) {  // !eslint-disable-line no-unmodified-loop-condition`,
			})[g_state.loop || ''];

			yield /* syntax: js.method */ `
				// parse state for ${si_state}
				${si_state}() {
					// destruct chunk, length, and index
					let s = this.s;
					let i = this.i;
					let n = this.n;

					${g_state.preamble || ''}

					// start labeled loop, run while there are characters
					${sx_loop}
						${s_body}
						${g_state.fallthrough || ''}
					${sx_loop? '}': ''}

					${g_state.postscript || ''}

					${g_state.no_auto_resume? '': resume_state(si_state, false, g_state.max)}
				}
			`;
		}
	}
}


@>> lookahead(s_key, s_append='', s_prepend='')
	@//@regex
	(?:\s+|(?=@{s_prepend}[@*{
		let h_node;
		do {
			h_node = H_LOOKAHEADS[s_key];
			yield h_node.chars;
		} while(h_node.sub && (s_key=h_node.sub));
	}])@{s_append})
@;


@>> R_CHAR(s_delims='')
	@//@regex
	[^\s#@<@{B_STAR? '>':''}[("'@{s_delims}@{B_QUADS? '{}': ''}]
@;

@>> R_CHAR_NO_CLOSERS(s_puncts=null)
	@//@regex
	[^\s#@<@{B_STAR? '>':''}[("'@{s_puncts || '.;,'+(B_STAR? '>': '')}@{B_QUADS? '{}': ''})\]\\]
@;

@>> R_PREFIX_ID()
	@//@regex
	@{R_CHAR(':_')}@{R_CHAR(':')}*
@;

@>> R_ESCAPE_SEQUENCE()
	@//@regex
	\\ (?:
		%[0-9A-Fa-f][0-9A-Fa-f]
		| [^\s"]
	)
@;

@>> R_CONTENT_LOOKAHEAD()
	@//@regex
	(?=
		\.?[<[("';,)\]#@{B_QUADS? '{}': ''}]
		@{B_STAR? '| >':''}
		| \.[\s\0]
	)
@;

@>> R_PREFIXED_NAME_QUICK()
	@//@regex
	(
		[A-Za-z]  @// PN_CHARS_BASE simplified
		[A-Za-z0-9_-]*  @// PN_CHARS (omit '.' from middle for perf)
	@{B_LOAD? ':': ')? :('}  @// load mode can use 1 capture group instead of 2
		[A-Za-z_0-9:]  @// PN_LOCAL[0]
		[A-Za-z0-9_:-]*  @// PN_LOCAL[1-$]
	)
	(?:
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME_QUICK = /@{R_PREFIXED_NAME_QUICK()}/y;

@>> R_PREFIXED_NAME_ESCAPELESS()
	@//@regex
	(@{R_PREFIX_ID()}
	@{B_LOAD? ':': ')? :('}  @// load mode can use 1 capture group instead of 2
		(?:
			@{R_CHAR_NO_CLOSERS()}
			(?:
				@{R_CHAR_NO_CLOSERS(';,'+(B_STAR? '>': ''))}*
				@{R_CHAR_NO_CLOSERS()}
			)?
		)?
	)
	(?:
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME_ESCAPELESS = /@{R_PREFIXED_NAME_ESCAPELESS()}/y;

@if B_OPTIMIZE_PAIRS
	const R_OPTIMIZED_PAIRS = /@{R_PREFIXED_NAME_ESCAPELESS()}@{R_PREFIXED_NAME_ESCAPELESS()}/y;
@;


@>> R_PREFIXED_NAME(b_lookahead=false)
	@//@regex
	(@{R_PREFIX_ID()}				@// 1: prefix id
	@{B_LOAD? ':': ')? :('}  @// load mode can use 1 capture group instead of 2
												@// 2: prefix iri
		(?:
			(?:									@// firt name char
				@{R_CHAR_NO_CLOSERS()}			@// not invalid name char
				| @{R_ESCAPE_SEQUENCE()}		@// or an escape sequence
			)
			(?:									@// middle name chars
				(?:
					@{R_CHAR_NO_CLOSERS(';,'+(B_STAR? '>': ''))}	@// not invalid name chars
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)*
				(?:								@// last name char
					@{R_CHAR_NO_CLOSERS()}		@// not invalid name char
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)
			)?
		)?
	)
	@if b_lookahead
		(?:											@// consume trailing whitespace
			\s+
			| @{R_CONTENT_LOOKAHEAD()}
		)
	@;
@;

const R_PREFIXED_NAME = /@{R_PREFIXED_NAME(true)}/y;

const R_PN_LOCAL_ESCAPES = /\\(.)/g;

@// blank node labels
@>> R_LABELED_BLANK_NODE()
	@//@regex
	_:(.(?:[^\s:<;,)\]#@{B_QUADS? '}': ''}]*[^\s:<.;,)\]#@{B_QUADS? '}': ''}])?)
@;

const R_LABELED_BLANK_NODE = /@{R_LABELED_BLANK_NODE()}@{lookahead('blank_node')}/y;
const R_LABELED_BLANK_NODE_TERMINAL = /@{R_LABELED_BLANK_NODE()}@{lookahead('blank_node', '|(?=\\.[\\s@#<({[}])', '\\.?')}/y;

const R_IRIREF_ESCAPELESS = /<([^\\<>]*)>\s*/y;
const R_IRIREF = /<([^<>]*)>\s*/y;

const R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))(\.?[eE][+-]?[0-9]+)?)(?:\s+|(?=\.[^eE0-9]|[;,)\]]))/y;
const R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\s*/y;
const R_A = /a@{lookahead('predicate')}/y;

const R_DOUBLE_CARET = /\^\^/y;
const R_WS = /\s*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)@{lookahead('terminal')}/y;

const R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\s*/y;
const R_PREFIX_ID = /([^#:]*):\s*/iy;
const R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\s*/y;

@if TRIG
	const R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\s*<([^\\>]*)>\s*\{\s*/iy;
	const R_GRAPH_PREFIXED_NAME = /(?:graph)?\s*@{R_PREFIXED_NAME()}\s*\{\s*/iy;
	const R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\s*@{R_LABELED_BLANK_NODE()}\s*\{\s*/iy;
	const R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\s*\[\s*\]\s*\{\s*/iy;
	const R_GRAPH_IRI = /(?:graph)?\s*<([^>]*)>\s*\{\s*/iy;
	const R_GRAPH = /graph(?:\s+|(?=[#<[{]))/iy;
@;

const R_COMMENT = /(#[^\n]*\n\s*)+/y;
const R_COMMENT_EOF = /(#[^\n]*(?:\n\s*|$))+/y;

// const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9\-._~]*:/;
// const RT_IRI_ABSOLUTE = /^[A-Za-z]/;
const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9+.-]*:/;
const R_RELATIVE_URI = /^(\/[^?#]+)([?#].*)?$/;
@>> R_BASE_IRI()
	@//@regex
	^(								@// 1: uri
		(							@// 2: root
			([A-Za-z0-9.\-+]*:\/)?	@// 3: scheme
			\/[^/>]*				@// [authority]
		)?
		(							@// 4: path
			\/(?:[^/>]*\/)*
		)?
		[^>]*						@// [rest]
	)$
@;
const R_BASE_IRI = /@{R_BASE_IRI()}/;

const R_ANONYMOUS_BLANK_NODE = /\[\s*\]\s*/y;
const R_CHAR_BLANK_NODE = /\[(?:\s+|(?=[^\]]))/y;
const R_CHAR_COLLECTION = /\(\s*/y;

const R_CHAR_KET = /\]\s*/y

@if TRIG
	const R_CHAR_OPEN = /\{\s*/y;
	const R_CHAR_CLOSE = /\}\s*/y;
@;

const R_CHAR_STOP = /\.\s*/y;



@//	pre-escape sequence
@//	(?<!
@//		(?:
@//			[^\\] | ^
@//		)
@//		(?:\\\\)*
@//		\\
@//	)


@// const R_STRLIT_CONTENTS_ESCAPES_SOFT_OG = /\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8})|([^uU]))(?=[^])/g;


const R_STRLIT_SHORT_DOUBLE_BREAK = /[\\"\r\n]/g;
const R_STRLIT_SHORT_SINGLE_BREAK = /[\\'\r\n]/g;

const R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /"{1,2}$/g;
const R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;

const R_STRLIT_LONG_DOUBLE_BREAK = /(\\|""")/g;
const R_STRLIT_LONG_SINGLE_BREAK = /(\\|''')/g;

@{unescape_literals(true)}

const match_prefixed_name_quick = (s, i) => {
	R_PREFIXED_NAME_QUICK.lastIndex = i;
	return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
};

const match_prefixed_name_escapeless = (s, i) => {
	R_PREFIXED_NAME_ESCAPELESS.lastIndex = i;
	return [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];
};

const match_prefixed_name = (s, i) => {
	R_PREFIXED_NAME.lastIndex = i;
	return [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];
};

@// will only be used by TriG
@>> emit_graph_open()
	this._fk_enter(this._kt_graph);
@;

@// will only be used by TriG
@>> emit_graph_close()
	this._fk_exit(this._kt_graph);
@;

@// emit a statement event to listener using current subject/predicate/object
@>> emit_statement()
	this.emit_data();
@;


@// consume whitespace
@def whitespace(z_offset='0', b_local_i=false)
	@. let s_offset = 'number' === typeof z_offset? `i+${z_offset}`: z_offset
	// consume whitespace (and incidentally reset index)
	R_WS.lastIndex = @{s_offset};
	R_WS.exec(s);
	@{b_local_i? '': 'this.'}i = R_WS.lastIndex;
@;


@// assert the prefix found in prefixed name is valid
@def valid_prefix(match, n_group)
	@if B_READ
		@. let sj_var = `s_prefix_id${n_group? '_'+n_group: ''}`;

		// check valid prefix
		let @{sj_var} = @{match}[@{n_group || 1}] || '';

		@if B_OPTIMIZE_PREFIX_IDS
			// invalid prefix
			if(!(this._as_prefix_ids.has(@{sj_var}))) {
				return new NoSuchPrefixError({
					prefix: @{sj_var},
					@{error_args()}
				});
		@else
			// invalid prefix
			if(!OPHOP.call(this._h_prefixes, @{sj_var})) {
				return new NoSuchPrefixError({
					prefix: @{sj_var},
					@{error_args()}
				});
			}
		@;
	@;
@;



@// save current state to stack
@def push_state(state)
	this._a_nested.push([this._kt_subject, this._kt_predicate, '@{state}']);
@;


@// restore previous state from stack
@def pop_state(s_err)
	// invalid place to pop
	if(!this._a_nested.length) {
		throw new ContentSyntaxError({
			message: `Unexpected @{s_err}`,
			@{error_args()}
		});
	}
	let s_resume_state;
	[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
	return this[s_resume_state]();
@;

@// change state
@def goto(s_method)
	return this.@{s_method}();
@;

@$ a_methods = [];


@// set resume state & stop parsing in this stack
@def resume_state(s_state, b_use_field_chunk=false, s_max_token=null)
	// update index value
	this.i = i;

	// not yet eos
	if(i < this.n) {
		// expected token was not found
		if(0 === i) {
			// we've exceeded the maximum token length
			if(this.n > this.@{s_max_token || 'max_token_length'}) {
				throw new ExceededMaximumTokenLengthError({
					state: '@{s_state}',
					mtl: this.@{s_max_token || 'max_token_length'},
					constraint: '',
					@{error_args()}
				});
			}
		}
	}

	// save state before pausing
	this._f_state = this.@{s_state};

	// store what is unparsed
	this.pre = @{b_use_field_chunk? 'this.' :''}s.slice(i);

	// if we're not parsing a stream, then this is an error
	if(this.eos) this.eos();
	return;
@;


@def full_stop()
	if(this._b_expecting_full_stop) {
		// change state
		@{goto('full_stop')}
	}
@;


@def load_default_graph()
	@if B_LOAD_GSPO_BUILDER
		this._kh_graph = this._k_builder.openC1Graph('*');
	@else
		this._sc1_graph = '*';
		let hc4_quads = this._hc4_quads;

		// not first encounter w/ graph
		if('*' in hc3_triples) {
			this._hc3_triples = hc4_quads['*'];
		}
		// first encounter of graph
		else {
			hc4_quads[$_KEYS] += 1;
			this._hc3_triples = hc4_quads['*'] = {
				[$_KEYS]: 0,
				[$_QUADS]: 0,
			};
		}
	@;
@;

@def load_graph(sj_expr)
	@if B_LOAD_GSPO_BUILDER
		this._kh_graph = this._k_builder.openC1Graph(@{sj_expr});
	@else
		let sc1_graph = this._sc1_graph = @{sj_expr};
		let hc4_quads = this._hc4_quads;

		// not first encounter w/ graph
		if(sc1_subject in hc3_triples) {
			this._hc3_triples = hc4_quads[sc1_graph];
		}
		// first encounter of graph
		else {
			hc4_quads[$_KEYS] += 1;
			this._hc3_triples = hc4_quads[sc1_graph] = {
				[$_KEYS]: 0,
				[$_QUADS]: 0,
			};
		}
	@;
@;

@def load_subject(sj_expr)
	@if B_LOAD_GSPO_BUILDER
		this._kh_grub = this._kh_graph.openC1Subject(@{sj_expr});
	@else
		@.{
			const s_rand = Math.round(Math.random()*10e8);
			const sj_subject = /* syntax: js */ `sc1_subject_${s_rand}`;
			const sj_triples = /* syntax: js */ `hc3_triples${s_rand}`;
		}

		let @{sj_subject} = this._sc1_subject = @{sj_expr};
		let @{sj_triples} = this._hc3_triples;

		// not first encounter w/ subject
		if(@{sj_subject} in @{sj_triples}) {
			this._hc2_pairs = @{sj_triples}[@{sj_subject}];
		}
		// first encounter of subject
		else {
			@{sj_triples}[$_KEYS] += 1;
			this._hc2_pairs = @{sj_triples}[@{sj_subject}] = {
				[$_KEYS]: 0,
				[$_QUADS]: 0,
			};
		}
	@;
@;

@def load_predicate(sj_expr)
	@if B_LOAD_GSPO_BUILDER
		this._kh_greed = this._kh_grub.openC1Predicate(@{sj_expr});
	@else
		@.{
			const s_rand = Math.round(Math.random()*10e8);
			const sj_predicate = /* syntax: js */ `sc1_predicate_${s_rand}`;
			const sj_pairs = /* syntax: js */ `hc2_pairs_${s_rand}`;
		}
		let @{sj_predicate} = this._sc1_predicate = @{sj_expr};
		let @{sj_pairs} = this._hc2_pairs;

		// not first encounter w/ predicate
		if(@{sj_predicate} in @{sj_pairs}) {
			this._as_objects = @{sj_pairs}[@{sj_predicate}];
		}
		// first encounter of predicate
		else {
			@{sj_pairs}[$_KEYS] += 1
			this._as_objects = @{sj_pairs}[@{sj_predicate}] = new Set();
		}
	@;
@;

@def load_object(sj_expr)
	@if B_LOAD_GSPO_BUILDER
		this._kh_greed.addC1Object(@{sj_expr});
	@else
		this.load_object(@{sj_expr});
	@;
@;

@.{
	const H_LOADERS = {
		subject: load_subject,
		predicate: load_predicate,
		object: load_object,
		graph: load_graph,
		datatype: (sj_expr) => /* syntax: js */ `
			sc1_datatype = ${sj_expr};
		`,
	};

	const load_term = (s_role, sj_expr) => {
		const f_loader = H_LOADERS[s_role];
		if(!f_loader) throw new Error(`no such term loader for '${s_role}'`);
		return f_loader(sj_expr);
	};
}

@// emit statement and return control to whatever function asked for it
@def eot()
	@if B_READ
		// at this point, a new statement has been parsed
		@{emit_statement()}
	@;

	// goto next parsing state; bail out of stack
	return this.after_eot;
@;


function count_all_lines(s_chunk) {
	let c_lines = 0;
	let i_scan = -1;

	while((i_scan = s_chunk.indexOf('\n', i_scan+1)) >= 0) {
		c_lines += 1;
	}
	return c_lines;
}

function count_lines_until(s_chunk, i_until=0) {
	let c_lines = 0;
	let i_scan = -1;

	for(;;) {
		i_scan = s_chunk.indexOf('\n', i_scan+1);
		if(i_scan < 0 || i_scan >= i_until) return c_lines;
		c_lines += 1;
	}
}

@$ S_EXPORT = S_LABEL+S_MODE[0].toUpperCase()+S_MODE.substr(1)+'er';


@$ H_PARSE_EVENTS = {
	base: {},
	prefix: {},
	...(B_QUADS && {
		enter: {},
		exit: {},
	}),
	comment: {},
	error: {},
	read: {once:true},
	progress: {},
	eof: {once:true},
	...(B_LOAD && {
		load: {once:true},
	}),
	data: {},  // attach data listener last
};


export class @{S_EXPORT} extends stream.@{B_LOAD? /* syntax: js */ `Writable`: /* syntax: js */ `Transform`} {
	static async run(z_input, gc_run) {
		// instantiate consumer
		const k_consumer = new Consumer(gc_run, @{S_EXPORT});

		// string
		if('string' === typeof z_input) {
			k_consumer.consume_string(z_input);
		}
		// stream
		else {
			await k_consumer.consume_stream(z_input);
		}
	}

	constructor(gc_consumer={}) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			@if !B_LOAD
				// output quad objects on readable side
				readableObjectMode: true,
			@;
		});

		// hash of rewired event handlers
		this._h_rewired = {};

		// instantiate consumer
		const k_consumer = this._k_consumer = new Consumer(gc_consumer, @{S_EXPORT});  // eslint-disable-line no-new

		// proxy stream
		k_consumer.proxy_transform(this);
	}

	_rewire_event(si_event) {
		// event not yet rewired
		if(this._h_rewired && !(si_event in this._h_rewired)) {
			let si_handler = `_fk_${si_event}`;

			// ref handler
			const fk_handler = this._k_consumer[si_handler]

			// legitimate event
			if(fk_handler){
				// reassign current handler
				if(F_NOOP !== fk_handler) {
					super.on(si_event, fk_handler);
				}

				// rewire handler
				this._k_consumer[si_handler] = (...a_args) => {
					this.emit(si_event, ...a_args);
				};

				// save to hash
				this._h_rewired[si_event] = 1;
			}
			// error event
			else if('error' === si_event) {
				const fe_handler = this._k_consumer._fe_error;

				// reassign current handler
				if(fe_handler && F_THROW !== fe_handler) {
					super.on('error', fe_handler);
				}

				// rewire handler
				this._k_consumer._fe_error = (...a_args) => {
					this.emit('error', ...a_args);
				};

				// save to hash
				this._h_rewired.error = 1;
			}
		}
	}

	// intercept on
	on(si_event, fk_event, gc_event) {
		// harden callback event
		this._rewire_event(si_event);

		// forward to proxy
		super.on(si_event, fk_event, gc_event);
	}

	// intercept once
	once(si_event, fk_event, gc_event) {
		// harden callback event
		this._rewire_event(si_event);

		// forward to proxy
		super.once(si_event, fk_event, gc_event);
	}

	@if !B_LOAD
		// intercept pipe
		pipe(ds_out) {
			let ds_dst = ds_out;

			// non-object mode
			if(!ds_dst._writableState.objectMode) {
				// transform to JSON
				ds_out = stream.quads_to_json();
			}
			// yet object mode and graphy writable
			else if(ds_out.isGraphyWritable) {
				// transform to writable data events
				ds_out = stream.quads_to_writable();
			}

			// interim stream created
			if(ds_out !== ds_dst) {
				// forward output to super
				super.pipe(ds_out);

				// pipe outpu to destination
				return ds_out.pipe(ds_dst);
			}
			// forward as-is to super
			else {
				return super.pipe(ds_dst);
			}
		}
	@;
}

export default @{S_EXPORT};


const F_NOOP = () => {};
const F_THROW = (e_read) => {
	throw e_read;
};

class Consumer {
	constructor(gc_consumer, dc_actor) {
		// impl-specific configs
		let {
			// a state to inherit
			state: g_state={},
		} = this._gc_consumer = gc_consumer;

		this._dc_actor = dc_actor;

		// assign event callbacks
		@*{
			for(const [si_event, g_event] of ode(H_PARSE_EVENTS)) {
				// do not create handlers for proxy events
				if(g_event.proxy) continue;

				if('error' === si_event) {
					yield /* syntax: js */ `this._fe_error = gc_consumer.error || F_THROW;\n`;
				}
				else {
					yield /* syntax: js */ `this._fk_${si_event} = gc_consumer.${si_event} || F_NOOP;\n`;
				}
			}
		}

		// enable comments
		if(F_NOOP !== this._fk_comment) {
			this.enable_comments();
		}

		// inherit state from creator
		let {
			// index for anonymous blank node labels
			blank_node_index: i_anon=0,

			// prefix map
			prefixes: h_prefixes={},

			// blank node label map
			labels: h_labels={},
		} = g_state;


		// in case user provides a factory, adopt it so reader can still create special literals
		const dc_factory = DataFactory.adopt(gc_consumer.dataFactory || gc_consumer.data_factory || DataFactory.unfiltered);

		// default graph
		let kt_default_graph = dc_factory.defaultGraph();

		// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()
		if(dc_factory !== DataFactory.unfiltered) {
			// do not trust it, create a new object
			kt_default_graph = Object.create(kt_default_graph);
		}

		const kt_rdf_first = dc_factory.namedNode('@{P_IRI_RDF}first');

		const blankNode = dc_factory.blankNode;
		const namedNode = dc_factory.namedNode;

		@if B_LOAD
			const k_builder = gc_consumer.into || new BasicQuadTree.Builder();
		@+ B_READ
			this.restore_data = function() {
				this._fk_data(this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph));
			};
		@;

		// fields
		@.{
			const SX_NUM_ZERO = /* syntax: js */ `0`;
			const SX_STR_EMPTY = /* syntax: js */ `''`;
			const SX_NULL = /* syntax: js */ `null`;
			const SX_TRUE = /* syntax: js */ `true`;
			const SX_FALSE = /* syntax: js */ `false`;
			const SX_ARR_EMPTY = /* syntax: js */ `[]`;
		}
		@*{/* eslint-disable multiline-ternary */ yield* declare_properties({
			// read index
			i: SX_NUM_ZERO,

			// string buffer
			s: SX_STR_EMPTY,

			// string buffer length
			n: SX_NUM_ZERO,

			// left-over string from previous data chunk
			pre: /* syntax: js */ `gc_consumer.prepend || ''`,

			// debug state
			_b_debug: /* syntax: js */ `!!gc_consumer.debug`,

			// tolerant
			_b_tolerant: /* syntax: js */ `!!gc_consumer.tolerant || !!gc_consumer.relax`,

			// factory
			_dc_factory: /* syntax: js */ `dc_factory`,

			// current reader state
			_f_state: /* syntax: js */ `this.${S_STATE_PRIMARY}`,

			// map of current prefix ids => iris
			_h_prefixes: /* syntax: js */ `h_prefixes`,

			...(B_OPTIMIZE_PREFIX_IDS && {
				// set of current prefix ids
				_as_prefix_ids: /* syntax: js */ `new Set(Object.keys(h_prefixes))`,
			}),

			// reader was destroyed by an error
			_b_destroyed: SX_FALSE,

			// rdf-star
			_b_rdf_star: /* syntax: js */ `!!gc_consumer.star`,

			// current @base iri
			_s_base_iri: SX_STR_EMPTY,
			_s_base_iri_scheme: SX_STR_EMPTY,
			_s_base_iri_root: SX_STR_EMPTY,
			_s_base_iri_path: SX_STR_EMPTY,

			// current data
			...(B_LOAD? {
				_sc1_subject: SX_STR_EMPTY,
				_sc1_predicate: SX_STR_EMPTY,
				_sc1_object: SX_STR_EMPTY,
				_sc1_graph: /* syntax: js */ `'*'`,
				...(B_LOAD_GSPO_BUILDER? {
					_k_builder: /* syntax: js */ `k_builder`,
					_kh_graph: /* syntax: js */ `k_builder.openC1Graph('*')`,
					_kh_grub: SX_NULL,
					_kh_greed: SX_NULL,
				}: {
					...(B_QUADS? {
						_hc4_quads: `{
							[$_KEYS]: 0,
							[$_QUADS]: 0,
						}`,
						_hc3_triples: SX_NULL,
					}: {
						_hc3_triples: `{
							[$_KEYS]: 0,
							[$_QUADS]: 0,
						}`,
					}),
					_hc2_pairs: SX_NULL,
					_a_objects: SX_NULL,
				}),
			}: {
				_kt_subject: SX_NULL,
				_kt_predicate: /* syntax: js */ `kt_rdf_first`,
				_kt_object: SX_NULL,
				_kt_graph: /* syntax: js */ `kt_default_graph`,
				_kq_star: SX_NULL,
			}),

			_s_literal: SX_STR_EMPTY,

			...(B_LOAD? {
				// cached concise-term strings
				_scp_xsd_decimal: SX_NULL,
				_sc1_rdf_type: SX_NULL,
			}: {
				// static terms
				_kt_rdf_type: /* syntax: js */ `dc_factory.namedNode('${P_IRI_RDF}type')`,
				_kt_rdf_first: /* syntax: js */ `kt_rdf_first`,
				_kt_rdf_rest: /* syntax: js */ `dc_factory.namedNode('${P_IRI_RDF}rest')`,
				_kt_rdf_nil: /* syntax: js */ `dc_factory.namedNode('${P_IRI_RDF}nil')`,
				_kt_default_graph: /* syntax: js */ `kt_default_graph`,
			}),

			// queue of nested subject, predicate, state for blanknodes and collections
			_a_nested: SX_ARR_EMPTY,

			// hash to keep track of all blank node labels in use
			_h_labels: /* syntax: js */ `h_labels`,

			// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)
			_a_queue_event: SX_ARR_EMPTY,

			// helper states
			_b_expecting_full_stop: SX_FALSE,
			_s_temp_prefix_id: SX_NULL,
			_b_trim_start: SX_TRUE,

			// event routing
			emit_data: /* syntax: js */ `this.restore_data`,

			anonymous_blank_node: /* syntax: js */ `s_label => blankNode(s_label, true)`,

			// finds the next non-conflicting blank node label
			next_label: /* syntax: js */ `function() {
				let s_label = '';
				do {
					s_label = 'g'+(i_anon++);
				} while(this._h_labels[s_label]);

				// claim this label, and remember that we invented it
				this._h_labels[s_label] = 2;

				// return the label
				return s_label;
			}`,

			// what to do when reach eos
			eos: SX_NULL,

			// which state to go to after end of statement
			after_eot: /* syntax: js */ `this.post_object`,
			restore_after_eot: SX_NULL,

			// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160
			_n_max_token_length: /* syntax: js */ `gc_consumer.max_token_length || gc_consumer.maxTokenLength || 2048`,

			// maximum length of a string (overrides max_token_length): defaults to 524288 (~1-2 MiB in UTF-16)
			_n_max_string_length: /* syntax: js */ `gc_consumer.max_string_length || gc_consumer.maxStringLength || 524288`,

			// byte tracking
			_b_byte_tracking: /* syntax: js */ `gc_consumer.byte_tracking || gc_consumer.byteTracking || false`,
			_nb_seen: SX_NUM_ZERO,
			_nb_last: SX_NUM_ZERO,
			_nb_curr: SX_NUM_ZERO,

			// line tracking
			_b_line_tracking: /* syntax: js */ `!gc_consumer.swift`,
			_c_lines: SX_NUM_ZERO,
		}, /* syntax: js */ `this`);
	/* eslint-enable multiline-ternary */ }

	if(gc_consumer.relaxed) {
		console.warn((new TypeError(`No such option 'relaxed'; did you mean 'relax' ? Suggestion: use 'tolerant' instead`)).stack.replace(/^Error:/, 'Warning:'));
	}

	if('relax' in gc_consumer) {
		console.warn((new TypeError(`Option 'relax' will be deprecated in future release. Use the 'tolerant' option if you wish to disable validation for faster parsing.`)));
	}

	if('input' in gc_consumer) {
		console.warn((new TypeError(`Option 'input' has been deprecated. You can either use this parser as a Transform or use the static 'run' method.`)));
	}

	if('validate' in gc_consumer) {
		console.warn((new TypeError(`Option 'validate' has been deprecated. Validation is now enabled by default. Use the 'tolerant' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));
	}


@// ensure there are no conflicting blank node labels
@def no_label_conflict()
	// not first time use of label
	let z_label_state = this._h_labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this._h_labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this._h_labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this._h_labels[s_label] = 1;
	}
@;

		// term constructors
		if(this._b_tolerant) {
			@*{yield* declare_properties({
				// term constructors
				blank_node: /* syntax: js */ `function(s_label) {
					// check for conflicts
					${no_label_conflict()}

					// make term
					${B_LOAD
						? /* syntax: js */ `return '#'+s_label;`
						: /* syntax: js */ `return blankNode(s_label);`}
				}`,

				check_named_node: /* syntax: js */ `namedNode`,
				check_named_node_escapeless: /* syntax: js */ `namedNode`,
				match_prefixed_name_escapeless: /* syntax: js */ `match_prefixed_name_escapeless`,
				match_prefixed_name: /* syntax: js */ `match_prefixed_name`,
			}, /* syntax: js */ `this`)}
		}
		else {
			@*{yield* declare_properties({
				blank_node: /* syntax: js */ `function(s_label) {
					// test valid blank node label
					if(!RT_BLANK_NODE_VALID.test(s_label)) {
						throw new ContentSyntaxError({
							message: \`Invalid blank node label: '\${s_label}'\`,
							${error_args({
								// past length of label and `_:` sequence
								rewind: /* syntax: js */ `s_label.length + 2`,

								// position the caret at: [0] first label char [1] next extra-range [2] last char
								caret: /* syntax: js */ `2 + (
									/[^${RANGE_PN_CHARS_U()}0-9]/u.test(s_label[0])
										? 0
										: /[^${RANGE_PN_CHARS_U()}\\-0-9\\xb7\\u{203f}-\\u{2040}]/u.exec(s_label)?.index || s_label.length-1
									)`.replace(/[\r\n\t]+/g, ''),
							})}
						});
					}

					// check for conflicts
					${no_label_conflict()}

					// make term
					return blankNode(s_label);
				}`,

				check_named_node: /* syntax: js */ `function(p_iri) {
					if(!RT_NAMED_NODE_VALID.test(p_iri)) {
						throw new ContentSyntaxError({
							message: \`Invalid IRI: <\${p_iri}>\`,
							${error_args({
								// past length of iri and `<`, `>`` chars
								rewind: /* syntax: js */ `p_iri.length + 2`,

								// TODO: find invalid char
								caret: `1`,
							})}
						});
					}
					return namedNode(p_iri);
				}`,

				check_named_node_escapeless: /* syntax: js */ `function(p_iri) {
					if(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) {
						throw new ContentSyntaxError({
							message: \`Invalid IRI: <\${p_iri}>\`,
							${error_args({
								// past `>` char, length of iri, then back to index of first invalid char
								rewind: /* syntax: js */ `p_iri.length + 2`,
								caret: /* syntax: js */ `1 + /[${RANGE_NAMED_NODE_INVALID(true)}]/.exec(p_iri).index`,
							})}
						});
					}
					return namedNode(p_iri);
				}`,

				match_prefixed_name_quick: /* syntax: js */ `function(s, i) {
					R_PREFIXED_NAME_QUICK.lastIndex = i;
					return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
				}`,

				match_prefixed_name_escapeless: /* syntax: js */ `function(s, i) {
					let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
					if(m_prefixed_name_e) {
						// no need to check namespace since it was validated during declaration
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {
							throw new ContentSyntaxError({
								message: \`Invalid prefixed name local name: '\${m_prefixed_name_e[2]}:'\`,
								${error_args()}
							});
						}
					}

					return [m_prefixed_name_e, im_prefixed_name_e];
				}`,

				match_prefixed_name: /* syntax: js */ `function(s, i) {
					let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
					if(m_prefixed_name) {
						// no need to check namespace since it was validated during declaration
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
							throw new ContentSyntaxError({
								message: \`Invalid prefixed name local name: '\${m_prefixed_name[2]}:'\`,
								${error_args()}
							});
						}
					}

					return [m_prefixed_name, im_prefixed_name];
				}`,
			}, /* syntax: js */ `this`)}
		}


		this.named_node = namedNode;

		this.prefixed_name = function(si_prefix, s_suffix) {
			return namedNode(h_prefixes[si_prefix] + s_suffix);
		};


		// oops -- user passed string into `base`
		if('string' === typeof gc_consumer.base) {
			throw new TypeError(`Invalid type \`string\` was given for 'base' option event listener: '${gc_consumer.base}'\n`
				+`did you mean to specify the 'baseIRI' option instead?`)
		}

		// base iri
		let p_set_base_iri = gc_consumer.baseIRI || gc_consumer.baseIri || gc_consumer.base_iri;
		if(p_set_base_iri) {
			let m_base_iri = R_BASE_IRI.exec(p_set_base_iri);
			this._s_base_iri = m_base_iri[1];
			this._s_base_iri_root = m_base_iri[2] || '';
			this._s_base_iri_scheme = m_base_iri[3] || '';
			this._s_base_iri_path = m_base_iri[4] || ''; 
		}
		// not set; 'url' variant is
		else if(gc_consumer.base_url || gc_consumer.baseUrl || gc_consumer.baseURL) {
			throw new TypeError(`Invalid option: 'base${gc_consumer.base_url? '_url': gc_consumer.baseUrl? 'Url': gc_consumer.baseURL? 'URL': ''}'; use the 'baseIRI' option instead`);
		}
	}

@def write_chunk(b_fke_chunk)
	@//@
	// concatenate current chunk to previous chunk
	const s = this.s = this.pre + s_chunk;

	// cache chunk length
	this.n = s.length;

	// eat whitespace before token and reset index
	if(this._b_trim_start) {
		@{whitespace()}
	}
	// do not eat whitespace; start at beginning
	else {
		this.i = 0;
	}

	// resume parsing
	const e_parse = this.safe_parse(true);

	// parse error
	if(e_parse) {
		@if b_fke_chunk
			// handle thru stream callback
			return fke_chunk(e_parse);
		@else
			// handle using callback
			return this._fe_error(e_parse);
		@;
	}
	// no errors
	else {
		@if B_LOAD
			// debugger;
			// this.emit_data();
		@;

		// emit progress event updates
		this._fk_progress(s_chunk.length);

		// count lines
		if(this._b_line_tracking) {
			this._c_lines += count_all_lines(s_chunk);
		}

		@if b_fke_chunk
			// done transforming this chunk
			fke_chunk();
		@;
	}
@;

	// consume a string
	consume_string(s_chunk) {
		@{write_chunk()}

		// eof
		const e_eof = this.eof(1);

		// handle error
		if(e_eof) return this._fe_error(e_eof);
	}

	// consume a stream
	consume_stream(ds_input) {
		// input stream destroyed flag
		let b_destroyed = false;

		// go async
		return new Promise((fk_consumed, fe_reject) => {
			// create stream destroyer
			const fe_destroy = (e_read) => {
				// attempt to destroy input stream
				if(ds_input.destroy) ds_input.destroy();

				// forward to promise rejection
				fe_reject(e_read);

				// destroyed
				b_destroyed = true;
			};

			// re-route error handling to promise rejection
			if(F_THROW === this._fe_error) {
				this._fe_error = fe_destroy;
			}
			// wrap error handler
			else {
				// ref original handler
				const fe_handler = this._fe_error;

				// set new handler
				this._fe_error = (e_read) => {
					// callback user-defined error handler
					fe_handler(e_read);

					// then, reject promise
					fe_destroy(e_read);
				};
			}

			// bind data listener
			ds_input.on('data', (s_chunk) => {
				@{write_chunk()}
			});

			// forward errors
			ds_input.on('error', this._fe_error);

			// all data has been read
			ds_input.on('end', () => {
				// do not emit eof nor resolve promise
				if(b_destroyed) return;

				// signal eof
				const e_eof = this.eof(1);

				// reject with failure
				if(e_eof) return this._fe_error(e_eof);

				// resolve promise
				fk_consumed();
			});
		});
	}

@def gen_steam_proxy(gc_stream)
	// on data event
	ds_@{gc_stream.kind}._@{gc_stream.data} = (s_chunk, s_encoding, fke_chunk) => {
		@{write_chunk('stream')}
	};

	// once there's no more data to consume, invoke eof
	ds_@{gc_stream.kind}._@{gc_stream.terminal} = (fke_@{gc_stream.terminal}) => {
		// now that input stream has ended, clean up remainder
		const e_eof = this.eof(1);

		// read error occurred; allow stream to handle error
		if(e_eof) return fke_@{gc_stream.terminal}(e_eof);

		// no errors. done with @{gc_stream.terminal}, close stream
		fke_@{gc_stream.terminal}();
	};

	// new listener added
	ds_@{gc_stream.kind}.on('newListener', (s_event) => {
		// comment
		if('comment' === s_event && !this.emit_comments) {
			this.enable_comments();
		}
	});

	// destroy
	ds_@{gc_stream.kind}._destroy = (...a_args) => {
		this.destroy(...a_args);
	};

	// when the writable side is piped into
	ds_@{gc_stream.kind}.on('pipe', (ds_input) => {
		this._ds_input = ds_input;

		let b_byte_tracking = this._b_byte_tracking;

		// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8
		if(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {
			ds_input.setEncoding('utf8');
		}
		// set decoding on write
		else {
			let f_write = ds_@{gc_stream.kind}.write;
			let d_decoder = new string_decoder.StringDecoder('utf8');

			let f_write_track = (s_chunk, s_encoding, fk_write) => {
				// TODO: optimize by testing for multibyte chars and using string length instead?
				let nb_chunk = Buffer.from(s_chunk, 'utf8').length;
				this._nb_seen += nb_chunk;
				this._nb_last = nb_chunk;
				return f_write.call(ds_@{gc_stream.kind}, s_chunk, s_encoding, fk_write);
			};

			let f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {
				let nb_chunk = this._nb_last = ab_chunk.length;
				this._nb_seen += nb_chunk;
				return f_write.call(ds_@{gc_stream.kind}, d_decoder.write(ab_chunk), s_encoding, fk_write);
			};

			let f_decode_write = (ab_chunk, s_encoding, fk_write) => {
				return f_write.call(ds_@{gc_stream.kind}, d_decoder.write(ab_chunk), s_encoding, fk_write);
			};

			ds_@{gc_stream.kind}.write = function(z_chunk, s_encoding, fk_write) {
				// not null
				if(null !== z_chunk) {
					// chunk is string; adapt by resetting method to original
					if('string' === typeof z_chunk) {
						ds_@{gc_stream.kind}.write = b_byte_tracking? f_write_track: f_write;
					}
					// chunk is buffer; adapt by setting decoder write method
					else {
						ds_@{gc_stream.kind}.write = b_byte_tracking? f_decode_write_track: f_decode_write;
					}

					// use set method
					return ds_@{gc_stream.kind}.write(z_chunk, s_encoding, fk_write);
				}

				// null, use parent
				return f_write.call(ds_@{gc_stream.kind}, z_chunk, s_encoding, fk_write);
			};

			// byte tracking is enabled
			if(b_byte_tracking) {
				// overwrite emit_data method
				this.emit_data = this.restore_data = function() {
					let g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
					let nb_post = Buffer.from(this.s.slice(this.i)).length;
					let ib_post = this._nb_seen - nb_post;
					g_quad.byteRange = [this._nb_curr, ib_post];
					this._nb_curr = ib_post;
					ds_@{gc_stream.kind}.push(g_quad);
				};
			}
		}
	});
@;

	// proxy a stream wrapper
	@if B_LOAD
		proxy_writable(ds_writable) {
			this._ds_proxy = ds_writable;

			@{gen_steam_proxy({
				kind: 'writable',
				data: 'write',
				terminal: 'final',
			})}
		}
	@+ B_READ
		proxy_transform(ds_transform) {
			this._ds_proxy = ds_transform;

			@{gen_steam_proxy({
				kind: 'transform',
				data: 'transform',
				terminal: 'flush',
			})}
		}
	@;

	enable_comments() {
		this.emit_comments = (s_captured) => {
			let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

			for(let s_comment of a_comments) {
				this._fk_comment(s_comment);
			}
		};
	}

	// begin parsing, keep applying until no more stack bail-outs
	safe_parse() {
		try {
			let f_sync = this._f_state();
			while('function' === typeof f_sync) {
				f_sync = f_sync.apply(this);
			}
		}
		// read error occurred; return it
		catch(e_read) {
			return e_read
		}
	}

	queue(s_event, ...a_args) {
		this._a_queue_event.push({
			event: s_event,
			args: a_args,
		});
	}


	@if B_LOAD
		@if B_LOAD_GSPO_BUILDER
			load_object(sc1_object) {
				this._kh_greed.addC1Object(sc1_object);
			}
		@else
			load_object(sc1_object) {
				// first encounter w/ object
				let as_objects = this._as_objects;
				if(!as_objects.has(sc1_object)) {
					this._hc3_triples[$_QUADS] += 1;
					this._hc2_pairs[$_QUADS] += 1;
					as_objects.add(sc1_object);
				}
			}
		@;
	@;

	// end of file
	eof() {
		// there are events queued
		if(this._a_queue_event.length) {
			let a_queue = this._a_queue_event;

			// drain event queue
			while(a_queue.length) {
				// remove event from front of queue
				const g_event = a_queue.shift();

				// make event callback
				this[g_event.event](g_event.data);
			}
		}

		// invalid parsing state
		if(this.@{S_STATE_PRIMARY} !== this._f_state) {
			// append EOF char
			this.s += '\0';

			// exit "flowing" mode
			this.n = this.s.length;

			// resume parsing final chunk
			const e_parse_final = this.safe_parse();

			// error
			if(e_parse_final) {
				// handle gracefully
				return this._fe_error(e_parse_final);
			}
			// no errors
			else {
				// eof has occurred under safe parse
				if(null === this.s) return;
				// still invalid parsing state
				if(this.@{S_STATE_PRIMARY} !== this._f_state) {
					debugger;
					// handle using callback
					return new UnexpectedTokenError({
						state: this._f_state.name,
						found: '<<EOF>>',
						@{error_args({
							line: /* syntax: js */ `+ count_all_lines(this.s)`,
						})}
					});
				}
			}
		}

		// there are still unparsed characters
		if(this.i < this.n) {
			// consume whitespace and comments
			let s = this.s;
			let i = this.i;
			@{whitespace('i', true)}
			R_COMMENT_EOF.lastIndex = i;
			let m_comment = R_COMMENT_EOF.exec(s);

			// advance beyond comment
			if(R_COMMENT_EOF.lastIndex > i) {
				this.i = i = R_COMMENT_EOF.lastIndex;
				if(this.emit_comments) this.emit_comments(m_comment[0]);
			}

			// still unparsed characters
			if(i < this.n) {
				// not EOF
				if(!(i === this.n - 1 && '\0' === s[i])) {
					// bad input; parse error
					return new UnexpectedTokenError({
						state: this._f_state.name,
						@{error_args({
							line: /* syntax: js */ `+ count_all_lines(this.s)`,
						})}
					});
				}
			}
		}

		// make buffer's alloc eligible for gc
		this.s = null;

		// final progress update: no additional bytes were read
		this._fk_progress(0);

		// call end event listener
		this._fk_eof(this._h_prefixes);

		@if B_LOAD
			@if B_LOAD_GSPO_BUILDER
				// deliver dataset; call 'load' handler
				this._k_builder.deliver().then((k_dataset) => {
					this._fk_load(k_dataset);
				});
			@else
				// ref self
				const k_self = this;

				// call 'load-trad' handler
				this._fk_load_trad({
					get size() {
						return k_self._hc3_triples[$_QUADS];
					},

					distinct() {
						return k_self._hc3_triples[$_KEYS];
					},
				});
			@;
		@;
	};

	@if B_STAR
		exit_star() {
			// create quad
			this._kq_star = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object);
		}
	@;


	// after a blank node subject (either property-list or colleciton)
	post_blank_subject_DELETE_THIS() {
		let {s, i} = this;
		if('.' === s[i]) {
			@{whitespace(+1)}

			@ifB_QUADS
				// not inside block
				if(@{SJ_DEFAULT_GRAPH} === this._kt_graph) {
					@{goto('block')}
				}
				// inside block
				else {
					@{goto('statement')}
				}
			@else
				@{goto('statement')}
			@;
		@if B_QUADS
			@{else_if_match('R_CHAR_CLOSE')}
				// empty collection
				if(@{terms_equal(SJ_RDF_NIL, 'this._kt_subject')}) {
					throw new Error('empty collection');
				}

				// emit graph_close event
				@{emit_graph_close()}

				// reset graph
				@if B_LOAD
					@{load_default_graph()}
				@else
					this._kt_graph = @{SJ_DEFAULT_GRAPH};
				@;

				// goto block state
				@{goto('block')}
			@{end_else()}
		@else
			}
		@;
		@{goto('pairs')}
	}
	@. a_methods.push('post_blank_subject');


	@.{
		function subassign(h_source, h_add) {
			for(let [, h_sub] of ode(h_source)) {
				Object.assign(h_sub, h_add);
			}
		}

		const SJ_REF_X_CHAR = /* syntax: js */ `
			// ref char
			let x = s[i];
		`;

		const gen_state_predicate = ({b_star=false}) => ({
			apply: {
				role: 'predicate',
				goto: b_star? 'object_x': 'object_list',
			},
			rules: {
				prefixed_name_quick: {},
				rdf_type_alias: () => ({
					type: 'match',
					test: /* syntax: js */ `R_A`,
					action: commit_term('predicate', SJ_RDF_TYPE),
				}),
				iriref_escapeless: {},
				prefixed_name_escapeless: {},
				iriref: {},
				prefixed_name: {},
				...(!b_star
					? {
						blank_node_property_list_terminator: () => ({
							type: 'match',
							test: /* syntax: js */ `R_CHAR_KET`,
							action: [
								pop_state(`end of blank node property list ']'`),
							],
							goto: null,
						}),
					}: {}),
				comment: {},
			},
		});

		const gen_state_object = ({b_star=false}) => ({
			preamble: SJ_REF_X_CHAR,
			apply: {
				role: 'object',
			},
			rules: {
				string_literal_double: {},
				prefixed_name_quick: {},
				iriref_escapeless: {},
				prefixed_name_escapeless: {},
				string_literal_single: {},
				numeric_literal: {},
				boolean_literal: {},
				...(!b_star? {
					blank_node_property_list: () => ({
						type: 'chars',
						test: '[',
						action: modal({
							read: /* syntax: js */ `
								// make blank node
								let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

								// emit statement event
								${emit_statement()}

								// push state to stack
								${push_state('post_object')}

								// set new subject
								this._kt_subject = kt_blank_node;
							`,
							load: /* syntax: js */ `
								// make blank node
								let sc1_blank_node = this._sc1_object = '#'+this.next_label();

								// commit to memory
								${load_object(/* syntax: js */ `sc1_blank_node`)}

								// push state to stack
								${push_state('post_object')}

								// set new subject
								${load_subject(/* syntax: js */ `sc1_blank_node`)}
							`,
						}),
						goto: 'pairs',
					}),
				}: {}),
				labeled_blank_node_terminal: {},
				...(!b_star? {
					collection_object: () => ({
						type: 'chars',
						test: '(',
						action: push_state('post_object'),
						goto: 'collection_object',
					}),
				}: {}),
				iriref: {},
				prefixed_name: {},
				rdf_star: {},
				comment: {},
			},
			// fallthrough for cases that did not change state on their own
			fallthrough: eot(),
		});

		const gen_rules_triples = ({h_prepend={}, h_append={}, b_directives=false, b_star=false}) => ({
			...h_prepend,
			prefixed_name_escapeless: {},
			labeled_blank_node: {},
			anonymous_blank_node: {},
			...(!b_star
				? {
					blank_node_property_list: () => ({
						type: 'chars',
						test: '[',
						...(B_TURTLE
							? {
								action: modal({
									read: /* syntax: js */ `
										// make blank node
										this._kt_subject = this.anonymous_blank_node(this.next_label());

										// push state to stack so it can resume when we pop state
										${push_state('post_blank_subject')}
									`,
									load: /* syntax: js */ `
										// make blank node
										let sc1_blank_node = this._sc1_subject = '#'+this.next_label();

										// commit to memory
										${load_subject(/* syntax: js */ `sc1_blank_node`)}

										// push state to stack
										${push_state('post_blank_subject')}
									`,
								}),
								goto: 'pairs',
							}
							: {
								action: [],
								goto: 'graph_or_subject_property_list',
							}),
					}),
				}
				: {}),
			collection: () => ({
				type: 'test',
				test: /* syntax: js */ `R_CHAR_COLLECTION`,
				action: [
					// indicate that collection subject should commit initial statement
					commit_term('subject', /* syntax: js */ `null`),

					// (don't push state, we don't have a subject yet)
				],
				goto: 'collection_subject',
			}),
			...((B_TURTLE || b_directives)
				? {
					// prefix with interupt (e.g., a comment or eos)
					prefix_keyword: () => ({
						type: 'match',
						test: /* syntax: js */ `R_PREFIX_KEYWORD`,
						action: ({sj_matched}) => /* syntax: js */ `
							// save whether or not to expect a full stop
							this._b_expecting_full_stop = ${sj_matched}[1]? true: false;
						`,
						goto: 'prefix_id',
					}),
					// prefix with interupt (e.g., a comment or eos)
					base_keyword: () => ({
						type: 'match',
						test: /* syntax: js */ `R_BASE_KEYWORD`,
						action: ({sj_matched}) => /* syntax: js */ `
							// save whether or not to expect a full stop
							this._b_expecting_full_stop = ${sj_matched}[1]? true: false;
						`,
						goto: 'base_iri',
					}),
				}: {}),
			...((B_TRIG && !b_directives)
				? {
					// closing graph '}'
					graph_terminator: {},
				}: {}),
			iriref: {},
			prefixed_name: {},
			...h_append,
		});

		const gen_state_subject = ({b_star=false}) => ({
			apply: {
				role: 'subject',
				goto: b_star? 'predicate_x': 'pairs',
				uncached_char: true,
			},
			rules: gen_rules_triples({
				b_directives: false,
				b_star: b_star,
				h_prepend: {
					prefixed_name_quick: {},
					iriref_escapeless: {},
				},
				h_append: {
					triple_x: () => ({
						type: 'chars',
						test: '<<',
						action: /* syntax: js */ `
							// rdf-star not enabled
							if(!this._b_rdf_star) break;

							${b_star? push_state('star_predicate_x'): ''}

							this.emit_data = this.exit_star;
							this.after_eot = this.triple_x_close;
							${push_state('star_pairs')}
						`,
						goto: 'triple_x',
					}),
					comment: {},
				},
			}),
		});

		const gen_state_literal = (s_type, s_which) => ({
			rules: {
				string: () => ({
					type: 'match',
					test: /* syntax: js */ `R_STRLIT_${s_type.toUpperCase()}_${s_which.toUpperCase()}_BREAK`,
					action: ({sj_matched}) => /* syntax: js */ `
						// index of break
						let i_break = ${sj_matched}.index;

						// add to contents
						this._s_literal += s.slice(i, i_break);

						// depending on char
						switch(s[i_break]) {
							// terminator
							case ${'single' === s_which? `"'"`: `'"'`}: {
								// advance index to next token beyond delimiter
								${whitespace(/* syntax: js */ `i_break + ${'short' === s_type? 1: 3}`)}

								// resume eating whitespace at start of next chunk
								this._b_trim_start = true;

								// consume rest
								${goto('datatype_or_langtag')}
							}

							// escape
							case '\\\\': {
								// try to find end
								R_STRLIT_${s_type.toUpperCase()}_${s_which.toUpperCase()}_TERM.lastIndex = i_break;
								let m_term = R_STRLIT_${s_type.toUpperCase()}_${s_which.toUpperCase()}_TERM.exec(s);

								// end is in this chunk
								if(m_term) {
									// index of terminator
									let i_term = m_term.index;

									// extract dirty potion
									let s_dirty = s.slice(i_break, i_term);

									// clean and save
									this._s_literal += unescape_literal_${s_type}_hard(s_dirty);

									// advance index beyond terminator
									this.i = i_term + m_term[0].length;

									// resume eating whitespace at start of next chunk
									this._b_trim_start = true;

									// consume rest
									${goto('datatype_or_langtag')}
								}
								// end is not in this chunk
								else {
									// extract whole portion
									let s_dirty = s.slice(i_break);

									// unescape to clean part
									let [s_clean, s_incomplete] = unescape_literal_${s_type}_soft(s_dirty);

									// save
									this._s_literal += s_clean;

									// set unparsed index
									i = n - s_incomplete.length;

									// reached eos; pause normally
									break STRING_LITERAL_${s_type.toUpperCase()}_${s_which.toUpperCase()};
								}
							}

							${'short' === s_type
								? /* syntax: js.switch */ `
									// invalid '\\n'
									case '\\n': {
										throw new ContentSyntaxError({
											message: \`Expected string_literal_${s_type}_${s_which} but found an invalid line feed character '\\\\n' (newline) within contents.\`,
											${error_args()}
										});
									}

									// invalid '\\r'
									case '\\r': {
										throw new ContentSyntaxError({
											message: \`Expected string_literal_${s_type}_${s_which} but found an invalid form feed character '\\\\r' (carriage return) within contents.\`,
											${error_args()}
										});
									}
								`: ''}

							// invalid
							default: {
								console.assert(\`Unhandle invalid character \${JSON.stringify(s[i_break])} case for string_literal_${s_type}_${s_which}\`);
							}
						}
					`,
				}),
			},
			else: 'single' === s_type
				? /* syntax: js */ `
					// save
					this._s_literal += i? s.slice(i): s;

					// set unparsed index
					i = n;

					// reached eos; pause normally
					break;
				`
				: /* syntax: js */ `
					// could be unfinished terminator
					R_STRLIT_LONG_${s_which.toUpperCase()}_UNFINISHED_TERM.lastIndex = i;
					let m_unfinished = R_STRLIT_LONG_${s_which.toUpperCase()}_UNFINISHED_TERM.exec(s);

					// unfinished terminator
					if(m_unfinished) {
						// save valid portion
						this._s_literal += s.slice(i, m_unfinished.index);

						// set unparsed index
						i = m_unfinished.index;
					}
					// not unfinished
					else {
						// save
						this._s_literal += i? s.slice(i): s;

						// set unparsed index
						i = n;
					}

					// reached eos; pause normally
					break;
				`,
			postscript: /* syntax: js */ `
				// do not eat whitespace at start of next chunk
				this._b_trim_start = false;

				// ran out of characters
				${resume_state(`string_literal_${s_type}_${s_which}`, false)}
			`,
			no_auto_resume: true,
		});
	}

	@*{yield* states({
		...(B_TRIG? {
			block: {
				apply: {
					role: 'graph',
					goto: 'statement',
					node_mod: 'graph',
				},
				rules: {
					graph_iriref_escapeless: {},
					prefixed_name: {},
					graph_open: () => ({
						type: 'test',
						test: /* syntax: js */ `R_CHAR_OPEN`,
						action: modal({
							read: [
								save_term('graph', /* syntax: js */ `this._dc_factory.defaultGraph()`),
								emit_graph_open(),
							],
							load: load_default_graph(),
						}),
					}),
					anonymous_blank_node: {},
					labeled_blank_node: {},
					iriref_escapeless: {
						role: 'subject',
						goto: 'graph_or_subject',
					},
					...subassign(gen_rules_triples({b_directives:true, b_star:false}), {
						role: 'subject',
						goto: 'pairs',
					}),
					graph_iri: () => ({
						type: 'match',
						test: /* syntax: js */ `R_GRAPH_IRI`,
						action: ({sj_matched}) => [
							iriref({s_role:'graph', sj_matched}),
							modal({
								read: emit_graph_open(),
								load: '',
							}),
						],
					}),
					comment: {},
					graph: () => ({
						type: 'test',
						test: /* syntax: js */ `R_GRAPH`,
						action: [],
						goto: 'graph_keyword',
					}),
				},
			},

			graph_or_subject: {
				preamble: SJ_REF_X_CHAR,
				rules: {
					disambiguating_graph_open: {},
					non_comment: {},
					comment: {},
				},
			},

			graph_or_subject_property_list: {
				preamble: SJ_REF_X_CHAR,
				rules: {
					blank_node_property_list_terminator: () => ({
						type: 'chars',
						test: ']',
						goto: 'graph_or_subject_anon',
					}),
					non_comment: {},
					comment: {},
				},
			},

			graph_or_subject_anon: {
				preamble: SJ_REF_X_CHAR,
				rules: {
					disambiguating_graph_open: {
						anonymous: true,
					},
					non_comment: {},
					comment: {},
				},
			},

			graph_keyword: () => ({
				apply: {
					role: 'graph',
					goto: 'graph_post_name',
				},
				rules: {
					prefixed_name_quick: {},
					iriref_escapeless: {},
					labeled_blank_node: {},
					anonymous_blank_node: {},
					iriref: {},
					prefixed_name: {},
					comment: {},
				},
			}),

			graph_post_name: () => ({
				preamble: SJ_REF_X_CHAR,
				rules: {
					graph_open_block: () => ({
						type: 'chars',
						test: '{',
						action: modal({
							read: emit_graph_open(),
							load: '',
						}),
						goto: 'statement',
					}),
					comment: {},
				},
			}),
		}: {}),

		statement: gen_state_subject({b_star:false}),
		triple_x: gen_state_subject({b_star:true}),

		pairs: gen_state_predicate({b_star:false}),
		predicate_x: gen_state_predicate({b_star:true}),

		object_list: gen_state_object({b_star:false}),
		object_x: gen_state_object({b_star:true}),

		triple_x_close: {
			loop: 'bypass',
			rules: {
				rdf_star_terminator: () => ({
					type: 'chars',
					test: '>>',
					args: {
						uncached_char: true,
					},
					action: pop_state(`end of "triple x" ${S_LABEL}* '>>'`),
				}),
			},
		},

		// do not risk deducing type in certain states, defer to own string literal state
		string_literal: {
			max: 'max_string_length',
			preamble: SJ_REF_X_CHAR,
			loop: 'for',
			rules: {
				string_literal_double: {},
				string_literal_single: {},
			},
		},

		string_literal_short_single: gen_state_literal('short', 'single'),
		string_literal_short_double: gen_state_literal('short', 'double'),
		string_literal_long_single: gen_state_literal('long', 'single'),
		string_literal_long_double: gen_state_literal('long', 'double'),

		datatype: {
			apply: {
				role: 'datatype',

			},
			preamble: modal({
				read: /* syntax: js */ `
					let kt_datatype = null;
				`,
				load: /* syntax: js */ `
					let sc1_datatype = '';
				`,
			}),
			loop: 'for',
			rules: {
				prefixed_name_quick: {},
				iriref_escapeless: {},
				prefixed_name_escapeless: {},
				iriref: {},
				prefixed_name: {},
			},
			fallthrough: /* syntax: js */ `
				${modal({
					read: save_term('object', /* syntax: js */ `this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype)`),
					load: load_object(/* syntax: js */ `'^'+sc1_datatype+'"'+this._s_literal`),
				})}

				// reset literal
				this._s_literal = '';

				// goto end of statement state
				${eot()}
			`,
		},

		datatype_or_langtag: {
			apply: {
				role: 'datatype',
			},
			preamble: SJ_REF_X_CHAR,
			rules: {
				datatype_or_langtag: () => ({
					type: 'strs',
					test: ['^', '@'],
					action: [
						// '^^' datatype
						if_match('R_DOUBLE_CARET'),
							goto('datatype'),

						// '@' language tag
						else_if_match('R_LANGTAG', 'm_langtag'),
							modal({
								read: /* syntax: js */ `
									this._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);
								`,
								load: load_object(/* syntax: js */ `'@'+m_langtag[1]+'"'+this._s_literal`),
							}),

						/* syntax: js */ `
							// reset literal
							this._s_literal = '';
						`,

						// next token definitely datatype or langtag, we are just being interrupted by eos
						else_retry(),
					],
				}),
				comment: {},
			},
			else: /* syntax: js */ `
				${modal({
					read: save_term('object', /* syntax: js */ `this._dc_factory.simpleLiteral(this._s_literal)`),
					load: load_object(/* syntax: js */ `'"'+this._s_literal`),
				})}

				// reset literal
				this._s_literal = '';
			`,
			fallthrough: /* syntax: js */ `
				// goto end of statement state
				${eot()}
			`,
		},

		post_object: {
			preamble: /* syntax: js */ `
				// cache current index
				let i_reset = i;

				// benchmarks confirm: character ref faster than regexes in this context
				let x = s[i];
			`,
			rules: {
				more_objects: () => ({
					type: 'chars',
					test: ',',
					action: [],
					goto: 'object_list',
				}),
				more_pairs: () => ({
					type: 'chars',
					test: ';',
					action: /* syntax: js */ `
						for(;;) {
							// next token is end of outer section
							let s_peek = s[this.i];
							if('.' === s_peek || ']' === s_peek || ';' === s_peek ${B_QUADS? /* syntax: js */ `|| '}' === s_peek`: ''}) {
								// goto post_object state
								${goto('post_object')}
							}
							// comment
							else if('#' === s_peek) {
								// comment
								i = this.i;
								${if_match('R_COMMENT', 'm_comment')}
									if(this.emit_comments) this.emit_comments(m_comment[0]);
									// retry
									continue;
								${end_else()}
								// no eol to close comment (yet)
								else {
									// already consumed 
									break;
								}
							}
							// eos
							else if(this.i === n) {
								break;
							}
							// something else
							else {
								${goto('pairs')}
							}
						}

						// rather than pushing a dedicated state, just try again next chunk
						i = i_reset;
						break;
					`,
				}),
				statement_terminator: () => ({
					type: 'chars',
					test: '.',
					action: [
						/* syntax: js */ `
							// assert not nested
							if(this._a_nested.length) {
								// reset index to that character
								this.i = i;

								// emit parse error
								throw new UnexpectedTokenError({
									state: 'end_of_property_list',
									${error_args()}
								});
							}
						`,
						B_TURTLE
							? goto(S_STATE_PRIMARY)
							: modal({
								read: /* syntax: js */ `
									return (${SJ_DEFAULT_GRAPH} === this._kt_graph)? this.${S_STATE_PRIMARY}(): this.statement();
								`,
								load: /* syntax: js */ `
									return (${SJ_DEFAULT_GRAPH} === this._sc1_graph)? this.${S_STATE_PRIMARY}(): this.statement();
								`,
							}),
					],
				}),
				blank_node_property_list_terminator: () => ({
					type: 'chars',
					test: ']',
					action: pop_state(`end of blank node property list ']'`),
				}),
				collection_terminator: () => ({
					type: 'chars',
					test: ')',
					action: /* syntax: js */ `
						// should not be here
						throw new UnexpectedTokenError({
							state: 'post_object',
							found: 'end of collection',
							${error_args()}
						});
					`,
				}),
				...(B_QUADS? {
					// closing graph '}'
					graph_terminator: {},
				}: {}),
				comment: {},
			},
		},

		base_iri: {
			rules: {
				iriref_escapeless: gen_rule_base_iriref({b_escapeless:true}),
				iriref: gen_rule_base_iriref({b_escapeless:false}),
				comment: {},
			},
		},

		prefix_id: {
			rules: {
				prefix_id: () => ({
					type: 'match',
					test: /* syntax: js */ `R_PREFIX_ID`,
					action: ({sj_matched}) => /* syntax: js */ `
						// set temp prefix id
						this._s_temp_prefix_id = ${sj_matched}[1];
					`,
					goto: 'prefix_iri',
				}),
				comment: {},
			},
		},

		prefix_iri: {
			preamble: /* syntax: js */ `
				let h_prefixes = this._h_prefixes;
				${B_OPTIMIZE_PREFIX_IDS? /* syntax: js */ `
					let as_prefix_ids = this._as_prefix_ids;
				`: ''}
				let s_prefix_id = this._s_temp_prefix_id;
			`,
			rules: {
				iriref_escapeless: gen_rule_prefix_iriref({b_escapeless:true}),
				iriref: gen_rule_prefix_iriref({b_escapeless:false}),
				comment: {},
			},
		},

		// in case eos happens twice during prefix / base (extremely unlikely)
		full_stop: {
			rules: {
				char_stop: () => ({
					type: 'match',
					test: /* syntax: js */ `R_CHAR_STOP`,
					action: [],
					goto: S_STATE_PRIMARY,
				}),
				// poorly placed comment
				comment: {},
			},
		},

		collection_subject: {
			apply: {
				role: 'object',
			},
			rules: {
				_ref_x_char: /* syntax: js */ `
					// ref char
					let x = s[i];
				`,
				collection_terminator: () => ({
					type: 'chars',
					test: ')',
					action: [
						// make & emit collection's tail "pointer"
						modal({
							read: /* syntax: js */ `
								// no items in collection subject
								if(null === this._kt_subject) {
									// prepare subject
									this._kt_subject = ${SJ_RDF_NIL};

									// state was never pushed to stack, jump to post_subject state
									${goto('post_blank_subject')}
								}
								// otherwise, there must be items in collection

								// commit collection end
								this._kt_object = ${SJ_RDF_NIL};
								${emit_statement()}
							`,
							load: /* syntax: js */ `
								// no items in collection subject
								if(null === this._sc1_subject) {
									// prepare subject
									this._sc1_subject = ${SJ_RDF_NIL};

									// state was never pushed to stack, jump to post_subject state
									${goto('post_blank_subject')}
								}
								// otherwise, there must be items in collection

								// commit collection end
								${load_object(SJ_RDF_NIL)}
							`,
						}),
						// restore state from stack
						pop_state(`end of collection ')'`),
					],
					goto: null,
				}),
				_continue: ((sj_subject) => /* syntax: js */ `
					// otherwise, pre-emptively secure the next blank node label
					let s_pointer_label;

					// very first collection object
					let b_pushed = false;
					if(null === ${sj_subject}) {
						// set quasi subject (really for resume state)
						s_pointer_label = this.next_label();
						${sj_subject} = ${modal({
							read: /* syntax: js */ `this.anonymous_blank_node(s_pointer_label)`,
							load: /* syntax: js */ `'#'+s_pointer_label`,
						})}
						${push_state('pairs')}
						// reset subject for later conditional branch
						${sj_subject} = null;
						b_pushed = true;
					}
				`)(`this._${B_LOAD? 'sc1': 'kt'}_subject`),
				iriref_escapeless: {
					local_i: true,
				},
				prefixed_name_escapeless: {
					local_i: true,
				},
				string_literal: () => ({
					type: 'raw',
					test: /* syntax: js */ `'"' === x || "'" === x`,
					action: modal({
						read: /* syntax: js */ `
							// first item in list
							if(null === this._kt_subject) {
								s_pointer_label = this.next_label();
								this._kt_subject = this.anonymous_blank_node(s_pointer_label);
								this._kt_predicate = ${SJ_RDF_FIRST};
							}
							// not first item in list
							else {
								// make nest list item
								s_pointer_label = this.next_label();
								let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
								${emit_statement()}

								// setup for object literal
								this._kt_subject = kt_blank_node;
								this._kt_predicate = ${SJ_RDF_FIRST};
							}

							// how to resume collection subject state after object literal
							this.after_eot = function() {
								this._kt_predicate = ${SJ_RDF_REST};
								this.after_eot = this.post_object;
								return this.collection_subject();
							};
						`,
						load: /* syntax: js */ `
							// first item in list
							if(null === this._sc1_subject) {
								s_pointer_label = this.next_label();
								${load_subject(/* syntax: js */ `'#'+s_pointer_label`)}
								${load_predicate(SJ_RDF_FIRST)}
							}
							// not first item in list
							else {
								// make nest list item
								s_pointer_label = this.next_label();
								let sc1_blank_node = '#'+s_pointer_label;
								${load_object(/* syntax: js */ `sc1_blank_node`)}

								// setup for object literal
								${load_subject(/* syntax: js */ `sc1_blank_node`)}
								${load_predicate(SJ_RDF_FIRST)}
							}

							// how to resume collection subject state after object literal
							this.after_eot = function() {
								${load_predicate(SJ_RDF_REST)}
								this.after_eot = this.post_object;
								return this.collection_subject();
							};
						`,
					}),
					goto: 'string_literal',
				}),
				numeric_literal: {
					local_i: true,
				},
				boolean_literal: {
					local_i: true,
				},
				blank_node_property_list: () => ({
					type: 'chars',
					test: '[',
					action: modal({
						read: /* syntax: js */ `
							// this blank node is just the next item in the list
							s_pointer_label = this.next_label();
							let kt_blank_node;
							if(null !== this._kt_subject) {
								kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
								${emit_statement()}
							}

							// subject needs to be set
							this._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
							this._kt_predicate = ${SJ_RDF_FIRST};
							let s_label = this.next_label();
							kt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);
							${emit_statement()}

							// when resume
							this._kt_predicate = ${SJ_RDF_REST};

							// push state
							${push_state('collection_subject')}

							// prepare next triple
							this._kt_subject = kt_blank_node;
						`,
						load: /* syntax: js */ `
							// this blank node is just the next item in the list
							s_pointer_label = '#'+this.next_label();
							let sc1_blank_node;
							if(null !== this._sc1_subject) {
								sc1_blank_node = '#'+s_pointer_label;
								${load_object(/* syntax: js */ `sc1_blank_node`)}
							}

							// subject needs to be set
							this._sc1_subject = sc1_blank_node || '#'+s_pointer_label;
							this._sc1_predicate = ${SJ_RDF_FIRST};
							let s_label = this.next_label();
							sc1_blank_node = '#'+s_label;
							${load_object(/* syntax: js */ `sc1_blank_node`)}

							// when resume
							${load_predicate(SJ_RDF_REST)}

							// push state
							${push_state('collection_subject')}

							// prepare next triple
							${load_subject(/* syntax: js */ `sc1_blank_node`)}
						`,
					}),
					goto: 'pairs',
				}),
				nested_collection: () => ({
					type: 'chars',
					test: '(',
					args: {
						local_i: true,
					},
					action: ((sj_term) => /* syntax: js */ `
						// empty collection
						if(')' === s[i]) {
							this.i = i;
							${sj_term}_subject = this._a_nested[this._a_nested.length-1][0];
							${sj_term}_predicate = ${SJ_RDF_FIRST};

							this._a_nested.push([
								${sj_term}_subject,
								${SJ_RDF_REST},
								'collection_subject',
							]);
							${goto('collection_object')}
						}

						// commit list item pointer
						s_pointer_label = this.next_label();

						${modal({
							read: /* syntax: js */ `
								let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
								${emit_statement()}

								// add this list as an item to the outer list
								this._kt_subject = kt_blank_node;
							`,
							load: /* syntax: js */ `
								let sc1_blank_node = '#'+s_pointer_label;
								${load_object(/* syntax: js */ `sc1_blank_node`)}

								// add this list as an item to the outer list
								this._sc1_subject = sc1_blank_node;
							`,
						})}

						${sj_term}_predicate = ${SJ_RDF_REST};
						${push_state('collection_object')}

						// prepare next triple
						${sj_term}_predicate = ${SJ_RDF_FIRST};
					`)(`this._${B_LOAD? 'sc1': 'kt'}`),
				}),
				labeled_blank_node: {
					local_i: true,
				},
				iriref: {
					local_i: true,
				},
				prefixed_name: {
					local_i: true,
				},
				comment: {},
			},
			cleanup: /* syntax: js */ `
				// ran out of characters after pushing state, pop it
				if(b_pushed) this._a_nested.pop();
			`,
			fallthrough: modal({
				read: /* syntax: js */ `
					let kt_blank_node_outer;
					if(!s_pointer_label) s_pointer_label = this.next_label();

					// not the very first item of collection subject
					if(this._kt_subject !== null) {
						// ref object
						let w_object = this._kt_object;

						// create blanknode to embed list
						kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

						// emit statement that functions as collection's head "pointer"
						${emit_statement()}

						// swap back object
						this._kt_object = w_object;
					}

					// emit statement that is item
					this._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);
					this._kt_predicate = ${SJ_RDF_FIRST};
					${emit_statement()}

					// prepare next predicate
					this._kt_predicate = ${SJ_RDF_REST};
				`,
				load: /* syntax: js */ `
					let sc1_blank_node_outer;
					if(!s_pointer_label) s_pointer_label = this.next_label();

					// not the very first item of collection subject
					if(this._sc1_subject !== null) {
						// ref object
						// ?????
						throw new Error('in LOAD mode, ._sc1_object is not used as a local field');
						// TODO: fix
						/*
						let w_object = this._sc1_object;

						// create blanknode to embed list
						sc1_blank_node_outer = '#'+s_pointer_label;

						// commit statement that functions as collection's head "pointer"
						${load_object(/* syntax: js */ `sc1_blank_node_outer`)}

						// swap back object
						this._sc1_object = w_object;
						*/
					}

					// emit statement that is item
					this._open_subject(sc1_blank_node_outer || '#'+s_pointer_label);
					this._open_predicate(${SJ_RDF_FIRST});
					this._add_object(this._sc1_object);

					// prepare next predicate
					this._open_predicate(${SJ_RDF_REST});
				`,
			}),
		},

		collection_object: {
			// preamble: SJ_REF_X_CHAR,
			apply: {
				role: 'object',
			},
			rules: {
				_ref_x_char: /* syntax: js */ `
					// ref char
					const x = s[i];
				`,
				collection_terminator: () => ({
					type: 'chars',
					test: ')',
					action: [
						// make & emit collection's tail "pointer"
						...modal({
							read: [
								save_term('object', SJ_RDF_NIL),
								emit_statement(),
							],
							load: [
								load_object(/* syntax: js */ `this._sc1_rdf+'nil'`),
							],
						}),
						pop_state(`end of collection object ')'`),
					],
				}),
				_continue: /* syntax: js */ `
					// otherwise, pre-emptively secure the next blank node label
					let s_pointer_label;
				`,
				iriref_escapeless: {
					local_i: true,
				},
				prefixed_name_escapeless: {
					local_i: true,
				},
				string_literal: () => ({
					type: 'raw',
					test: /* syntax: js */ `'"' === x || "'" === x`,
					action: modal({
						read: /* syntax: js */ `
							// update index before changing states
							this.i = i;

							// create blanknode to embed list
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

							// emit statement that functions as collection's head "pointer"
							${emit_statement()}

							// prepare statement that is item
							this._kt_subject = kt_blank_node;
							this._kt_predicate = ${SJ_RDF_FIRST};

							this.after_eot = function() {
								this._kt_predicate = ${SJ_RDF_REST};
								this.after_eot = this.post_object;
								return this.collection_object();
							};
						`,
						load: /* syntax: js */ `
							// update index before changing states
							this.i = i;

							// create blanknode to embed list
							let sc1_blank_node = '#'+this.next_label();

							// commit statement that functions as collection's head "pointer"
							${load_object(/* syntax: js */ `sc1_blank_node`)}

							// prepare statement that is item
							${load_subject(/* syntax: js */ `sc1_blank_node`)}
							${load_predicate(SJ_RDF_FIRST)}

							this.after_eot = function() {
								${load_predicate(SJ_RDF_REST)}
								this.after_eot = this.post_object;
								return this.collection_object();
							};
						`,
					}),
					goto: 'string_literal',
				}),
				numeric_literal: {
					local_i: true,
				},
				boolean_literal: {
					local_i: true,
				},
				blank_node_property_list: () => ({
					type: 'chars',
					test: '[',
					action: modal({
						read: /* syntax: js */ `
							// make blank node
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

							// emit statement event
							${emit_statement()}

							// setup state to resume and push
							this._kt_subject = kt_blank_node;
							this._kt_predicate = ${SJ_RDF_REST};
							${push_state('collection_object')}

							// enter blank node
							this._kt_predicate = ${SJ_RDF_FIRST};
							kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());
							${emit_statement()}

							// prepare next triple
							this._kt_subject = kt_blank_node;
							this._kt_predicate = ${SJ_RDF_FIRST};
						`,
						load: /* syntax: js */ `
							// make blank node
							let sc1_blank_node = '#'+this.next_label();

							// commit to memory
							${load_object(/* syntax: js */ `sc1_blank_node`)}

							// setup state to resume and push
							${load_subject(/* syntax: js */ `sc1_blank_node`)}
							${load_predicate(/* syntax: js */ `this._sc1_rdf+'rest'`)}
							${push_state('collection_object')}

							// enter blank node
							${load_predicate(/* syntax: js */ `this._sc1_rdf+'first'`)}
							sc1_blank_node = '#'+this.next_label();
							${load_object(/* syntax: js */ `sc1_blank_node`)}

							// prepare next triple
							${load_subject(/* syntax: js */ `sc1_blank_node`)}
							${load_predicate(/* syntax: js */ `this._sc1_rdf+'first'`)}
						`,
					}),
					goto: 'pairs',
				}),
				nested_collection: () => ({
					type: 'chars',
					test: '(',
					args: {
						local_i: true,
					},
					action: modal({
						read: /* syntax: js */ `
							// commit list item pointer
							s_pointer_label = this.next_label();
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
							if(null === this._kt_subject) {
								let a_recent = this._a_nested[this._a_nested.length-1];
								this._kt_subject = a_recent[0];
								this._kt_predicate = a_recent[1];
							}
							${emit_statement()}

							// add this list as an item to the outer list
							this._kt_subject = kt_blank_node;
							this._kt_predicate = ${SJ_RDF_REST};
							${push_state('collection_object')}

							// prepare next triple
							this._kt_predicate = ${SJ_RDF_FIRST};

							// flowing
							continue;
						`,
						load: /* syntax: js */ `
							// commit list item pointer
							s_pointer_label = this.next_label();
							let sc1_blank_node = '#'+s_pointer_label;
							if(null === this._sc1_subject) {
								let a_recent = this._a_nested[this._a_nested.length-1];
								${load_subject(/* syntax: js */ `a_recent[0]`)}
								${load_predicate(/* syntax: js */ `a_recent[1]`)}
							}
							${load_object(/* syntax: js */ `sc1_blank_node`)}

							// add this list as an item to the outer list
							${load_subject(/* syntax: js */ `sc1_blank_node`)}
							${load_predicate(SJ_RDF_REST)}
							${push_state('collection_object')}

							// prepare next triple
							${load_predicate(SJ_RDF_FIRST)}

							// flowing
							continue;
						`,
					}),
				}),
				labeled_blank_node: () => ({
					type: 'match',
					test: /* syntax: js */ `R_LABELED_BLANK_NODE`,
					args: {
						local_i: true,
					},
					action: ({sj_matched}) => /* syntax: js */ `
						// ref blank node label
						let s_label = ${sj_matched}[1];

						// make collection pointer label first
						s_pointer_label = this.next_label();

						${modal({
							read: save_term('object', /* syntax: js */ `this.blank_node(s_label)`),
							load: load_object(/* syntax: js */ `'#'+s_label`),
						})}
					`
				}),
				iriref: {
					local_i: true,
				},
				prefixed_name: {
					local_i: true,
				},
				comment: {},
			},
			fallthrough: modal({
				read: /* syntax: js */ `
					// ref object
					let w_object = this._kt_object;

					// create blanknode to embed list
					if(!s_pointer_label) s_pointer_label = this.next_label();
					let kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

					// emit statement that functions as collection's head "pointer"
					${emit_statement()}

					// emit statement that is item
					this._kt_subject = kt_blank_node_outer;
					this._kt_predicate = ${SJ_RDF_FIRST};
					this._kt_object = w_object;
					${emit_statement()}

					// prepare next predicate
					this._kt_predicate = ${SJ_RDF_REST};
				`,
				load: /* syntax: js */ `
					// ref object
					let w_object = this._sc1_object;

					// create blanknode to embed list
					if(!s_pointer_label) s_pointer_label = this.next_label();
					let sc1_blank_node_outer = s_pointer_label;

					// commit statement that functions as collection's head "pointer"
					${load_object(/* syntax: js */ `sc1_blank_node_outer`)}

					// commit statement that is item
					${load_subject(/* syntax: js */ `sc1_blank_node_outer`)}
					${load_predicate(SJ_RDF_FIRST)}
					${load_object(/* syntax: js */ `w_object`)}

					// prepare next predicate
					${load_predicate(SJ_RDF_REST)}
				`,
			}),
		},
	})}

	@//@class
	star_predicate_x() {
		// set as subject
		this._kt_subject = this._kq_star;

		// resume
		@{goto('predicate_x')}
	}

	star_pairs() {
		// set as subject
		this._kt_subject = this._kq_star;

		// restore data and after_eot
		this.emit_data = this.restore_data;
		this.after_eot = this.restore_after_eot

		// resume
		@{goto('pairs')}
	}

	star_post_object_x() {
		// set as object
		this._kq_star = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kq_star);

		// resume
		@{goto('triple_x_close')}
	}

	star_post_object() {
		// set as object
		this._kt_object = this._kq_star;

		// restore data and after_eot
		this.emit_data = this.restore_data;
		this.after_eot = this.restore_after_eot;

		// emit data
		@{emit_statement()}

		// resume
		@{goto('post_object')}
	}
	@//@


	@//@object-literal

	destroy(e_destroy) {
		@*{
			for(const s_method of a_methods) {
				yield /* syntax: js */ `
					this.${s_method} = () => {};
				`;
			}
		}

		this.eof = () => {
			this.s = null;
		};

		this._b_destroyed = true;

		// propagate input destroy
		if(!e_destroy && this._ds_input) {
			this._ds_input.destroy(e_destroy);
		}

		if(this._ds_proxy && this._ds_proxy.demolish) {
			this._ds_proxy.demolish(e_destroy);
		}
	}
}

// delete this once post_blank_subject calls have been refactored
Consumer.prototype.post_blank_subject = Consumer.prototype.pairs;


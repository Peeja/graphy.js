@import '../../share/iris.jmacs'
@import '../../share/channel.jmacs'

@./* global S_FORMAT S_MODE */
@//@

@$ NT = 'nt' === S_FORMAT;
@$ NQ = 'nq' === S_FORMAT;
@$ B_QUADS = NQ;

@$ S_LABEL = NT? 'NTriples': 'NQuads';

@$ B_LOAD = 'load' === S_MODE;
@$ B_READ = 'read' === S_MODE;

@$ B_OPTIMIZE_UNESCAPE = true;

@// import parser macros
@import '../text.read.jmacs'

import {stream} from '@@graphy/internal';
import {DataFactory} from '@@graphy/core';

@if B_LOAD
	@if B_LOAD_GSPO_BUILDER
		import {BasicQuadTree} from '@@graphy/memory';
	@;
	const {
		concise,
	} = DataFactory;

	const $_KEYS = Symbol(' keys');
	const $_QUADS = Symbol(' quads');
@;

import {
	ContextualError,
	ContentSyntaxError,
	UnexpectedTokenError,
	@if B_LOAD
		InvalidStateChangeError,
	@;
	ExceededMaximumTokenLengthError,
} from '../../error.mjs';

const RT_ABSOLUTE_IRI_VALID = /^[a-z][a-z0-9+\-.]*:(?:[^\0-\x20<>"{}|^`\\]|@{UCHAR()})*$/;
const RT_ABSOLUTE_IRI_ESCAPELESS_VALID = /^[a-z][a-z0-9+\-.]*:[^\0-\x20<>"{}|^`]*$/;
const RT_NAMED_NODE_VALID = /@{RT_NAMED_NODE_VALID(false)}/;
const RT_NAMED_NODE_ESCAPELESS_VALID = /@{RT_NAMED_NODE_VALID(true)}/;

const R_UNICODE_ANY = /@{R_UNICODE_4()}|@{R_UNICODE_8()}/g;

const F_REPLACE_UNICODE_ANY = @{F_REPLACE_UNICODE_ANY()};


const R_CLEAN = /\s*(?:#[^\n]*\n\s*)*\s*/y;
const R_CLEAN_COMMENTS = /\s*(#[^\n]*\n\s*)*\s*/y;
const RT_HAS_ESCAPES = /[\\]/;
const R_EOL = /[^\n]+\n/y;

// eslint-disable-next-line no-misleading-character-class
const RT_BLANK_NODE_LABEL_VALID = /^(?:[@{RANGE_PN_CHARS_U()}0-9])(?:(?:[@{RANGE_PN_CHARS()}.])*[@{RANGE_PN_CHARS()}])?$/u;
const RT_LANGUAGE_VALID = /^[a-z]+(-[a-z0-9]+)*$/;

const R_WS = /\s*/y;
const R_HWS = /[ \t]*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\s+|(?=[.,;\])#]))/y;

const R_IRIREF = /<([^>]*)>\s*/y;


@{unescape_literals()}



@>> R_NAMED_NODE(b_escapeless=false, b_open_cap=false)
	@//@regex
	@{b_open_cap? '(<': '<('}[^@{b_escapeless? '\\\\': ''}>]*)>
@;

@>> R_BLANK_NODE()
	@//@regex
	_:([^\x20\t<]+)
@;

@>> R_NODE(b_escapeless=false, b_open_cap=false)
	@//@regex
	@{R_NAMED_NODE(b_escapeless, b_open_cap)}
	| @{R_BLANK_NODE()}
@;

@>> R_LITERAL(b_escapeless=false)
	@//@regex
	"(@{(b_escapeless? /[^"\\]/: /(?:[^"\\]|\\.)/).source}*)"(?:\^\^@{R_NAMED_NODE(b_escapeless)}|@([^\x20\t.]+)|)
@;

@>> R_LITERAL_X(b_escapeless=false)
	@//@regex
	"(@{(b_escapeless? /[^"\\]/: /(?:[^"\\]|\\.)/).source}*)
	(?:
		(")(?:
			\^\^@{R_NAMED_NODE(b_escapeless)}
			| @([^\x20\t.]+)
			|
		) @{R_STMT_TERM(b_escapeless)}
	)?
@;

@>> R_OBJECT(b_escapeless=false)
	@//@regex
	@{R_NODE(b_escapeless, true)}
	| @{R_LITERAL(b_escapeless)}
@;

@>> R_COMMENT()
	@//@regex
	\.\s*(#[^\n]*\n\s*|\n\s*)+
@;

@>> R_TRIPLE(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:@{R_OBJECT(b_escapeless)})
	[\x20\t]* @{R_COMMENT()}
@;

@>> R_STMT_TERM(b_escapeless=false)
	@- B_QUADS
		@//@regex
		[\x20\t]* (?:@{R_NODE(b_escapeless)}|)  @// optional graph component
	@;
	@//@regex
	[\x20\t]* @{R_COMMENT()}
@;


@>> R_TRIPLE_X(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:
		(?:@{R_NODE(b_escapeless, true)}) @{R_STMT_TERM(b_escapeless)}
		| @{R_LITERAL_X(b_escapeless)}
	)
@;


@>> R_QUAD(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:@{R_OBJECT(b_escapeless)})
	[\x20\t]* (?:@{R_NODE(b_escapeless)}|)
	[\x20\t]* @{R_COMMENT()}
@;

@>> R_QUAD_X(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:
		(?:@{R_NODE(b_escapeless, true)}) @{R_STMT_TERM(b_escapeless)}
		| @{R_LITERAL_X(b_escapeless)}
	)
@;

@- B_QUADS
	@$ STATEMENT_REGEX = 'R_QUAD';

	const R_QUAD_ESCAPELESS_SP = /@{R_QUAD_X(true)}/y;
	const R_QUAD = /@{R_QUAD_X()}/y;
	const R_BLANK_NODE = /@{R_BLANK_NODE()}/y;
@:
	@$ STATEMENT_REGEX = 'R_TRIPLE';

	const R_TRIPLE_ESCAPELESS_SP = /@{R_TRIPLE_X(true)}/y;
	const R_TRIPLE = /@{R_TRIPLE_X()}/y;
@;


@> unescape_iri(term)
	RT_HAS_ESCAPES.test(@{term})? @{term}.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): @{term}
@;

@> clean()
	// remove whitespace & comments from beginning
	R_CLEAN.lastIndex = 0;
	let m_clean = R_CLEAN.exec(s);

	// comments
	if(this.emit_comments) {
		this.emit_comments(m_clean[1]);
	}

	// update index and prepare to match statement
	let i = R_CLEAN.lastIndex;
@;

@.{
	const ue_iri = (sv_iri, b_unescape=false) => b_unescape? unescape_iri(sv_iri): sv_iri;
}

@> match_body(sji_match, b_unescape=false)
	@.{
		let sji_named_node = /* syntax: js */ `create_named_node${b_unescape? '': '_escapeless'}`;
		let i_group_strlit = B_QUADS? 9: 7;
		let i_group_graph = B_QUADS? 11: 9;
	}
	// prep object term
	@- B_LOAD
		let sc1_object;
	@:
		let kt_object;
	@;

	@- B_QUADS
		// where to find the graph component
		let b_graph_late = false;
	@;

	// object term type is named node
	if(@{sji_match}[4]) {
		let p_object = @{sji_match}[4].slice(1);
		@- B_LOAD
			sc1_object = '>'+@{ue_iri('p_object', b_unescape)};
		@:
			kt_object = @{sji_named_node}(@{ue_iri('p_object', b_unescape)});
		@;
	}
	// object term type is blank node
	else if(@{sji_match}[5]) {
		@.{
			const sj_object_bnode = ue_iri(sji_match+'[5]', b_unescape)
		}
		@- B_LOAD
			sc1_object = '#'+@{sj_object_bnode};
		@:
			kt_object = create_blank_node(@{sj_object_bnode});
		@;
	}
	// object term type is literal
	else {
		@- B_QUADS
			// graph is in late capture group
			b_graph_late = true;
		@;

		// contents
		let s_contents = @{sji_match}[@{i_group_strlit}];

		// string terminator
		if(@{sji_match}[@{i_group_strlit+1}]) {
			@- b_unescape
				// unescape contents
				s_contents = unescape_literal_short_hard(s_contents);
			@;

			// datatype is present
			if(@{sji_match}[@{i_group_strlit+2}]) {
				@.{
					const sj_datatype = @{ue_iri(sji_match+'['+(i_group_strlit+2)+']')};
				}
				@- B_LOAD
					// create datatype term
					let sc1_datatype = '>'+@{sj_datatype};

					// create object term
					sc1_object = '^'+sc1_datatype+'"'+s_contents;
				@:
					// create datatype term
					let kt_datatype = this.create_named_node@{b_unescape? '': '_escapeless'}(@{sj_datatype});

					// create object term
					kt_object = datatyped_literal(s_contents, kt_datatype);
				@;
			}
			// language tag is present
			else if(@{sji_match}[@{i_group_strlit+3}]) {
				// normalize language
				let s_language = @{sji_match}[@{i_group_strlit+3}].toLowerCase();

				@- B_LOAD
					sc1_object = '@'+s_language+'"'+s_contents;
				@:
					// create object term
					kt_object = create_languaged_literal(s_contents, s_language);
				@;
			}
			// simple literal
			else {
				@- B_LOAD
					sc1_object = '"'+s_contents;
				@:
					kt_object = simple_literal(s_contents);
				@;
			}
		}
		// no string terminator
		else {
			// save contents
			this._s_literal = s_contents;

			// update index
			this.i = i;

			// save subject
			{
				let s_subject = @{sji_match}[1]

				// named node
				if(s_subject || 'string' === typeof s_subject) {
					@.{
						const sj_subject_name = @{ue_iri('s_subject', b_unescape)};
					}
					@- B_LOAD
						const sc1_subject = this._sc1_subject = '>'+@{sj_subject_name};
						this._kh_grub = this._kh_graph.openC1Subject(sc1_subject);
					@:
						this._kt_subject = @{sji_named_node}(@{sj_subject_name})
					@;
				}
				// blank node
				else {
					@.{
						const sj_subject_blank = @{sji_match}[2];
					}
					@- B_LOAD
						const sc1_subject = this._sc1_subject = '#'+@{sj_subject_blank};
						this._kh_grub = this._kh_graph.openC1Subject(sc1_subject);
					@:
						this._kt_subject = create_blank_node(@{sj_subject_blank});
					@;
				}
			}

			// save predicate
			@.{
				const sj_predicate = @{ue_iri(sji_match+'[3]', b_unescape)};
			}
			@- B_LOAD
				const sc1_predicate = this._sc1_predicate = '>'+@{sj_predicate};
				this._kh_greed = this._kh_grub.openC1Predicate(sc1_predicate);
			@:
				this._kt_predicate = @{sji_named_node}(@{sj_predicate});
			@;

			// parse contents
			let z_bail = this.strlit_contents();

			// bail out of stack
			if(z_bail && this.statement !== z_bail) {
				return z_bail;
			}
			// statement completed
			else {
				// clean
				let r_clean = this._r_clean;
				r_clean.lastIndex = this.i;
				let m_clean = r_clean.exec(s);
				if(this.emit_comments) {
					this.emit_comments(m_clean[1]);
				}

				// update local index and prepare to match next statement
				i = r_clean.lastIndex;

				// resume
				continue;
			}
		}
	}

	@- B_QUADS
		@- B_LOAD
			let sc1_graph = '*';
		@:
			let kt_graph = kt_default_graph;
		@;

		// graph after literal
		if(b_graph_late) {
			// ref capture group
			let s_graph = @{sji_match}[13];

			// named node
			if(s_graph || 'string' === typeof s_graph) {
				@.{
					const sj_graph_named = @{ue_iri('s_graph', b_unescape)};
				}
				@- B_LOAD
					sc1_graph = '>'+@{sj_graph_named};
				@:
					kt_graph = @{sji_named_node}(@{sj_graph_named});
				@;
			}
			// blank node
			else if(@{sji_match}[14]) {
				@.{
					const sj_graph_blank = @{sji_match}[14];
				}
				@- B_LOAD
					sc1_graph = '#'+@{sj_graph_blank};
				@:
					kt_graph = create_blank_node(@{sj_graph_blank});
				@;
			}
		}
		// graph after node
		else {
			// ref capture group
			let s_graph = @{sji_match}[6];

			// named node
			if(s_graph || 'string' === typeof s_graph) {
				@.{
					const sj_graph_named = @{ue_iri('s_graph', b_unescape)};
				}
				@- B_LOAD
					sc1_graph = '>'+@{sj_graph_named};
				@:
					kt_graph = @{sji_named_node}(@{sj_graph_named});
				@;
			}
			// blank node
			else if(@{sji_match}[7]) {
				@.{
					const sj_graph_blank = @{sji_match}[7];
				}
				@- B_LOAD
					sc1_graph = '#'+@{sj_graph_blank};
				@:
					kt_graph = create_blank_node(@{sj_graph_blank});
				@;
			}
		}
	@;

	@- B_LOAD
		let sc1_subject;
	@:
		let kt_subject;
	@;
	{
		let s_subject = @{sji_match}[1]

		// named node
		if(s_subject || 'string' === typeof s_subject) {
			@.{
				const sj_subject_named = @{ue_iri('s_subject', b_unescape)};
			}
			@- B_LOAD
				sc1_subject = '>'+@{sj_subject_named};
			@:
				kt_subject = @{sji_named_node}(@{sj_subject_named})
			@;
		}
		// blank node
		else {
			@.{
				const sj_subject_blank = @{sji_match}[2];
			}
			@- B_LOAD
				sc1_subject = '#'+@{sj_subject_blank};
			@:
				kt_subject = create_blank_node(@{sj_subject_blank});
			@;
		}
	}

	let s_predicate = @{sji_match}[3];

	@.{
		const sj_predicate = ue_iri('s_predicate', b_unescape);
	}
	@- B_LOAD
		const sc1_predicate = '>'+@{sj_predicate};

		if(sc1_graph !== sc1_graph_prev) {
			kh_graph = k_builder.openC1Graph(sc1_graph);
			sc1_graph_prev = sc1_graph;

			kh_grub = kh_graph.openC1Subject(sc1_subject);
			sc1_subject_prev = sc1_subject;

			kh_greed = kh_grub.openC1Predicate(sc1_predicate);
			sc1_predicate_prev = sc1_predicate;
		}
		else if(sc1_subject !== sc1_subject_prev) {
			kh_grub = kh_graph.openC1Subject(sc1_subject);
			sc1_subject_prev = sc1_subject;

			kh_greed = kh_grub.openC1Predicate(sc1_predicate);
			sc1_predicate_prev = sc1_predicate;
		}
		else if(sc1_predicate !== sc1_predicate_prev) {
			kh_greed = kh_grub.openC1Predicate(sc1_predicate);
			sc1_predicate_prev = sc1_predicate;
		}

		kh_greed.addC1Object(sc1_object);
	@:
		// emit data event
		f_data_quad(
			kt_subject,
			@{sji_named_node}(@{ue_iri('s_predicate', b_unescape)}),
			kt_object,
			@{B_QUADS? 'kt_graph': 'kt_default_graph'}
		);
	@;

	// comments
	if(this.emit_comments) {
		@- B_QUADS
			this.emit_comments(@{sji_match}[8] || @{sji_match}[15]);
		@:
			this.emit_comments(@{sji_match}[6] || @{sji_match}[11]);
		@;
	}
@;

const F_NOOP = () => {};
const F_THROW = (e_read) => {
	throw e_read;
};


@{create_parsing_export_class()}

class Consumer {
	constructor(gc_consumer) {
		let {
			// input medium
			input: g_input=null,

			// relax validation
			relax: b_relax=false,

			// debug
			debug: b_debug=false,
		} = gc_consumer;

		// allow relative iris flag
		let b_allow_relative_iris = gc_consumer.allow_relative_iris || gc_consumer.allowRelativeIRIs || gc_consumer.allowRelativeIris || false;

		// adopt factory
		let dc_factory = this._dc_factory = DataFactory.adopt(gc_consumer.dataFactory || gc_consumer.data_factory || DataFactory.unfiltered);

		let f_quad = this._f_quad = dc_factory.quad;

		const kt_default_graph = dc_factory.defaultGraph();

		// fields
		Object.assign(this, {
			// string buffer, accept left-over string from previous data chunk
			s: gc_consumer.prepend || '',

			// string buffer length
			n: 0,

			_b_debug: b_debug,

			// tolerant
			_b_tolerant: !!gc_consumer.tolerant || !!gc_consumer.relax,

			_b_destroyed: false,

			_b_trim_start: true,

			_f_state: this.statement,

			// current data
			@- B_LOAD
				_sc1_subject: '',
				_sc1_predicate: '',
				_sc1_object: '',
				_sc1_graph: '*',

				_k_builder: k_builder,
				_kh_graph: k_builder.openC1Graph('*'),
				_kh_grub: null,
				_kh_greed: null,
			@:
				_kt_subject: null,
				_kt_predicate: null,
				@- B_QUADS
					_kt_object: null,
					_kt_graph: kt_default_graph,
				@;
				_kq_star: null,
			@;

			_s_literal: '',
		});

		this._kt_rdfs_lang_string = dc_factory.namedNode('@{P_IRI_RDFS}langString');

		// clean regex
		let r_clean = this._r_clean = R_CLEAN;

		if('relaxed' in gc_consumer) {
			console.warn((new TypeError(`No such option 'relaxed'; did you mean 'relax' ? Suggestion: use 'tolerant' instead`)).stack.replace(/^Error:/, 'Warning:'));
		}

		if('relax' in gc_consumer) {
			console.warn((new TypeError(`Option 'relax' will be deprecated in future release. Use the 'tolerant' option if you wish to disable validation for faster parsing.`)));
		}

		if('input' in gc_consumer) {
			console.warn((new TypeError(`Option 'input' has been deprecated. You can either use this parser as a Transform or use the static 'run' method.`)));
		}

		if('validate' in gc_consumer) {
			console.warn((new TypeError(`Option 'validate' has been deprecated. Validation is now enabled by default. Use the 'tolerant' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));
		}

		// test for valid named node
		let rt_named_node_valid = b_allow_relative_iris? RT_NAMED_NODE_VALID: RT_ABSOLUTE_IRI_VALID;

		// test for valid named node escapeless
		let rt_named_node_valid_escapeless = b_allow_relative_iris? RT_NAMED_NODE_ESCAPELESS_VALID: RT_ABSOLUTE_IRI_ESCAPELESS_VALID;

		@- B_READ
			let namedNode = dc_factory.namedNode;
			let blankNode = dc_factory.blankNode;
			let languagedLiteral = dc_factory.languagedLiteral;

			// validation
			let k_self = this;
			Object.assign(this, !b_relax
				? {
					create_named_node(p_iri) {
						if(!rt_named_node_valid.test(p_iri)) return k_self._error(`invalid IRI: "${p_iri}"`);
						return namedNode(p_iri);
					},

					create_named_node_escapeless(p_iri) {
						if(!rt_named_node_valid_escapeless.test(p_iri)) return k_self._error(`invalid IRI: "${p_iri}"`);
						return namedNode(p_iri);
					},

					create_blank_node(s_label) {
						if(!RT_BLANK_NODE_LABEL_VALID.test(s_label)) return k_self._error(`Invalid blank node label: "${s_label}"`);
						return blankNode(s_label);
					},

					create_languaged_literal(s_contents, s_language) {
						if(!RT_LANGUAGE_VALID.test(s_language)) {
							return k_self._error(`Invalid literal language tag: ${s_language}`);
						}

						return languagedLiteral(s_contents, s_language);
					},
				}
				: {
					create_named_node: namedNode,

					create_named_node_escapeless: namedNode,

					create_blank_node: blankNode,

					create_languaged_literal: languagedLiteral,
				});
		@;

		// transform stream
		let ds_transform;

		// whether or not data has been received before
		let b_init = false;
	}

	_error(s_message) {
		this._b_destroyed = true;
		throw new Error(s_message);
	}


@$ H_PARSE_EVENTS = {
	error: {},
	comment: {},
	read: {once:true},
	progress: {},
	eof: {once:true},
	end: {once:true},
	finish: {once:true},
	data: {},  // attach data listener last
};

	// begin parsing, keep applying until no more stack bail-outs
	parse() {
		let f_sync = this._f_state();
		while('function' === typeof f_sync) {
			f_sync = f_sync.apply(this);
		}
	}

	statement() {
		let s = this.s;
		let n = this.n;
		let i = this.i;
		@- B_LOAD
			let k_builder = this._k_builder;
			let kh_graph = this._kh_graph;
			let kh_grub = this._kh_grub;
			let kh_greed = this._kh_greed;

			let sc1_graph_prev = '';
			let sc1_subject_prev = '';
			let sc1_predicate_prev = '';
		@+ B_READ
			let f_data_quad = this._f_data_quad;
			let create_named_node = this.create_named_node;
			let create_named_node_escapeless = this.create_named_node_escapeless;
			let create_languaged_literal = this.create_languaged_literal;
			let create_blank_node = this.create_blank_node;
			let simple_literal = this._dc_factory.simpleLiteral;
			let datatyped_literal = this._dc_factory.datatypedLiteral;
			let kt_default_graph = this._kt_default_graph;
		@;

		// match triples/quads
		for(;;) {
			@{if_match(STATEMENT_REGEX+'_ESCAPELESS_SP', 'm_statement_e_sp', true)}
				@{match_body('m_statement_e_sp')}

			@{else_if_match(STATEMENT_REGEX, 'm_statement', true)}
				@{match_body('m_statement', true)}

			@{else_if_match('R_EOL', null, true)}
				this._error(`Failed to read statement:\n\`${s.substr(i, 80).replace(/\n/g, '\u23CE')} [...]\`\n ^ starting here`);

			@{else_retry()}
		} // end of while

		// update unparsed data string
		this.s = s.substr(i);

		// resume here
		this._f_state = this.statement;

		@- B_LOAD
			// save locals
			this._kh_graph = kh_graph;
			this._kh_grub = kh_grub;
			this._kh_greed = kh_greed;
		@;

		// exit
		return 1;
	}


	strlit_contents() {
		let {s, n, i} = this;

		// try to find end
		R_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i;
		let m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);

		// end is in this chunk
		if(m_term) {
			// index of terminator
			let i_term = m_term.index;

			// extract dirty potion
			let s_dirty = s.slice(i, i_term);

			// clean and save
			this._s_literal += unescape_literal_short_hard(s_dirty);

			// advance index beyond terminator
			this.i = i_term + m_term[0].length;

			// resume eating whitespace at start of next chunk
			this._b_trim_start = true;

			// proceed with datatype_or_lang, then bail out of stack or resume parsing
			return this.datatype_or_langtag() || this.statement;
		}
		// end is not in this chunk
		else {
			// extract whole portion
			let s_dirty = s.slice(i);

			// unescape to clean part
			let [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);

			// save
			this._s_literal += s_clean;

			// set unparsed index
			this.i = i = n - s_incomplete.length;

			// do not eat whitespace at start of next chunk
			this._b_trim_start = false;
		}

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('strlit_contents');
				}
			}
		}

		// resume here
		this._f_state = this.strlit_contents;

		// store what is unparsed
		this.s = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return 1;
	}

@.{
	let sji_save_object = B_LOAD
		? (B_QUADS
			? /* syntax: js */ `this._sc1_object`
			: /* syntax: js */ `let sc1_object`)
		: (B_QUADS
			? /* syntax: js */ `this._kt_object`
			: /* syntax: js */ `let kt_object`);
}

	// parse state for datatype_or_langtag
	datatype_or_langtag() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// ref character
		let x = s[i];

		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// datatype
			if('^' === x) {
				// enough to speculate datatype
				if((i+2) < n) {
					// correct token
					if('^' === s[i+1]) {
						// advance index beyond token
						R_IRIREF.lastIndex = i + 2;

						// execute regex
						let m_iriref = R_IRIREF.exec(s);

						// regex was a match
						if(m_iriref) {
							// advance index
							this.i = R_IRIREF.lastIndex;

							// prepare iri
							let p_datatype = m_iriref[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);

							@- B_LOAD
								// create datatype term
								let sc1_datatype = '>'+p_datatype;

								// create object term
								@{sji_save_object} = '^'+sc1_datatype+'"'+this._s_literal;
							@:
								// create datatype term
								let kt_datatype = this.create_named_node(p_datatype);

								// create object term
								@{sji_save_object} = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);
							@;

							// free literal string
							this._s_literal = '';

							@- B_QUADS
								// graph state
								return this.post_object();
							@:
								// emit data event
								this._f_data_quad(this._kt_subject, this._kt_predicate, kt_object, this._kt_default_graph);

								// complete with statement_term
								return this.statement_term();
							@;
						}
						// failed to match; try again next chunk
						else {
							break;
						}
					}
					// invalid
					else {
						this._error(`Failed to read token after literal:\n\`${s.substr(i+1, 80).replace(/\n/g, '\u23CE')} [...]\`\n ^ starting here`);
					}
				}
				// not enough to speculate; try again next chunk
				else {
					break;
				}
			}
			// language tag
			else if('@' === x) {
				// prepare sticky regex index
				R_LANGTAG.lastIndex = i;
				// execute regex
				let m_langtag = R_LANGTAG.exec(s);

				// regex was a match
				if(m_langtag) {
					// advance index
					this.i = R_LANGTAG.lastIndex;

					// use direct factory method since regex is validation
					@{sji_save_object} = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);

					// free literal string
					this._s_literal = '';

					@- B_QUADS
						// graph state
						return this.post_object();
					@:
						// emit data event
						this._f_data_quad(this._kt_subject, this._kt_predicate, kt_object, this._kt_default_graph);

						// complete with statement_term
						return this.statement_term();
					@;
				}
				// interrupted by eos; try again next chunk
				else {
					break;
				}
			}
			@- B_QUADS
				// graph component
				else if('<' === x || '_' === x) {
					// save simple literal
					this._kt_object = this._dc_factory.simpleLiteral(this._s_literal);

					// free literal string
					this._s_literal = '';

					// continue parsing graph component
					return this.graph();
				}
			@;
			// triple terminator
			else if('.' === x) {
				// save simple literal
				let kt_object = this._dc_factory.simpleLiteral(this._s_literal);

				// free literal string
				this._s_literal = '';

				// advance index beyond terminator
				this.i = i + 1;

				// emit data event
				this._f_data_quad(this._kt_subject, this._kt_predicate, kt_object, this._kt_default_graph);

				// reset state
				return this.statement;

				// // consume whitespace (and incidentally reset index)
				// R_WS.lastIndex = i + 1;
				// R_WS.exec(s);
				// this.i = R_WS.lastIndex;

				// // done
				// return;
			}
			// other
			else {
				break;
			}
		}

		// ran out of characters
		// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('datatype_or_langtag');
				}
			}
		}

		// resume here
		this._f_state = this.datatype_or_langtag;

		// store what is unparsed
		this.s = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return 1;
	}

	statement_term() {
		let {s, n, i} = this;

		// find full stop
		let i_stop = s.indexOf('.', i);

		// found
		if(i_stop > -1) {
			// consume whitespace again
			this._b_trim_start = true;

			// advance beyond token
			this.i = i_stop + 1;

			// reset state
			return this.statement;
		}
		// anything other than whitespace
		else if(!/^\s*$/.test(s.slice(i))) {
			this.parse_error('statement_term');
		}

		// do not consume whitespace
		this._b_trim_start = false;

		// resume here
		this._f_state = this.statement_term;

		// store what is unparsed
		this.s = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return 1;
	}

	@- B_QUADS
		post_object() {
			let {s, n, i} = this;

			// eat horizontal whitespace
			R_HWS.lastIndex = i;
			R_HWS.exec(s);
			i = R_HWS.lastIndex;

			// ran out of characters
			if(i >= n) {
				// resume here
				this._f_state = this.post_object;

				// store what is unparsed
				this.s = s.slice(i);

				// if we're not parsing a stream, then this is an error
				if(this.eos) this.eos();
				return 1;
			}

			// depending on char
			switch(s[i]) {
				// statement term
				case '.': {
					// advance index beyond terminator
					this.i = i + 1;

					// emit data event
					this._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_default_graph);

					// reset state
					return this.statement;
				}

				// graph
				case '<':
				case '_': {
					// save index
					this.i = i;

					// consume graph component
					return this.graph();
				}

				// invalid
				default: {
					// save index
					this.i = i;

					// emit parsing error
					this.parse_error('post_object');
				}
			}
		}

		graph() {
			let {s, n, i} = this;

			@{if_match('R_IRIREF', 'm_iriref')}
				@.{
					const sj_graph_iri = /* syntax: js */ `m_iriref[1]`;
				}
				@- B_LOAD
					// create graph term
					let sc1_graph = '>'+@{sj_graph_iri};

					// create object
					this._k_builder.openC1Graph(sc1_graph)
						.openC1Subject(this._sc1_subject)
						.openC1Predicatte(this._sc1_predicate)
						.addC1Object(this._sc1_object);
				@:
					// create graph term
					let kt_graph = this.create_named_node(@{sj_graph_iri});

					// emit data event
					this._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, kt_graph);
				@;

				// complete with statement_term
				return this.statement_term();
			@{else_if_match('R_BLANK_NODE', 'm_blank')}
				// create graph term
				let kt_graph = this._dc_factory.blankNode(m_blank[1]);

				// emit data event
				this._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, kt_graph);

				// complete with statement_term
				return this.statement_term();
			@{end_else()}

			// resume here
			this._f_state = this.graph;

			// store what is unparsed
			this.s = s.slice(i);

			// if we're not parsing a stream, then this is an error
			if(this.eos) this.eos();
			return 1;
		}
	@;

	parse_error(s_state) {
		return this._error(`Failed to read ${s_state}:\n\`${this.s.substr(this.i, 80).replace(/\n/g, '\u23CE')} [...]\`\n ^ starting here`);
	}

	destroy(e_destroy) {
		this._f_data_quad = () => {};

		if(!e_destroy && this._ds_input) {
			this._ds_input.destroy(e_destroy);
		}

		this.transform.demolish(e_destroy);
	}
}

